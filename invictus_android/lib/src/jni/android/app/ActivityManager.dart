// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../java/io/FileDescriptor.dart' as filedescriptor$_;

import '../../java/lang/CharSequence.dart' as charsequence$_;

import '../../java/util/concurrent/Executor.dart' as executor$_;

import '../content/Context.dart' as context$_;

import '../content/Intent.dart' as intent$_;

import 'Activity.dart' as activity$_;

import 'PendingIntent.dart' as pendingintent$_;

/// from: `android.app.ActivityManager$AppTask`
class ActivityManager$AppTask extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager$AppTask> $type;

  @jni$_.internal
  ActivityManager$AppTask.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/app/ActivityManager$AppTask',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$AppTask?> nullableType =
      $ActivityManager$AppTask$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$AppTask> type =
      $ActivityManager$AppTask$Type$();
  static final _id_finishAndRemoveTask = _class.instanceMethodId(
    r'finishAndRemoveTask',
    r'()V',
  );

  static final _finishAndRemoveTask =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void finishAndRemoveTask()`
  void finishAndRemoveTask() {
    _finishAndRemoveTask(
      reference.pointer,
      _id_finishAndRemoveTask as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_getTaskInfo = _class.instanceMethodId(
    r'getTaskInfo',
    r'()Landroid/app/ActivityManager$RecentTaskInfo;',
  );

  static final _getTaskInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.app.ActivityManager$RecentTaskInfo getTaskInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  ActivityManager$RecentTaskInfo? getTaskInfo() {
    return _getTaskInfo(
      reference.pointer,
      _id_getTaskInfo as jni$_.JMethodIDPtr,
    ).object<ActivityManager$RecentTaskInfo?>(
      const $ActivityManager$RecentTaskInfo$NullableType$(),
    );
  }

  static final _id_moveToFront = _class.instanceMethodId(
    r'moveToFront',
    r'()V',
  );

  static final _moveToFront =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void moveToFront()`
  void moveToFront() {
    _moveToFront(
      reference.pointer,
      _id_moveToFront as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_setExcludeFromRecents = _class.instanceMethodId(
    r'setExcludeFromRecents',
    r'(Z)V',
  );

  static final _setExcludeFromRecents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setExcludeFromRecents(boolean z)`
  void setExcludeFromRecents(bool z) {
    _setExcludeFromRecents(
      reference.pointer,
      _id_setExcludeFromRecents as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_startActivity = _class.instanceMethodId(
    r'startActivity',
    r'(Landroid/content/Context;Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivity =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void startActivity(android.content.Context context, android.content.Intent intent, android.os.Bundle bundle)`
  void startActivity(
    context$_.Context? context,
    intent$_.Intent? intent,
    jni$_.JObject? bundle,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _startActivity(
      reference.pointer,
      _id_startActivity as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$intent.pointer,
      _$bundle.pointer,
    ).check();
  }
}

final class $ActivityManager$AppTask$NullableType$
    extends jni$_.JType<ActivityManager$AppTask?> {
  @jni$_.internal
  const $ActivityManager$AppTask$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$AppTask;';

  @jni$_.internal
  @core$_.override
  ActivityManager$AppTask? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : ActivityManager$AppTask.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$AppTask?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$AppTask$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$AppTask$NullableType$) &&
        other is $ActivityManager$AppTask$NullableType$;
  }
}

final class $ActivityManager$AppTask$Type$
    extends jni$_.JType<ActivityManager$AppTask> {
  @jni$_.internal
  const $ActivityManager$AppTask$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$AppTask;';

  @jni$_.internal
  @core$_.override
  ActivityManager$AppTask fromReference(jni$_.JReference reference) =>
      ActivityManager$AppTask.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$AppTask?> get nullableType =>
      const $ActivityManager$AppTask$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$AppTask$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$AppTask$Type$) &&
        other is $ActivityManager$AppTask$Type$;
  }
}

/// from: `android.app.ActivityManager$MemoryInfo`
class ActivityManager$MemoryInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager$MemoryInfo> $type;

  @jni$_.internal
  ActivityManager$MemoryInfo.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/app/ActivityManager$MemoryInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$MemoryInfo?> nullableType =
      $ActivityManager$MemoryInfo$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$MemoryInfo> type =
      $ActivityManager$MemoryInfo$Type$();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.app.ActivityManager$MemoryInfo> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$Type$());

  static final _id_advertisedMem = _class.instanceFieldId(
    r'advertisedMem',
    r'J',
  );

  /// from: `public long advertisedMem`
  int get advertisedMem => _id_advertisedMem.get(this, const jni$_.jlongType());

  /// from: `public long advertisedMem`
  set advertisedMem(int value) =>
      _id_advertisedMem.set(this, const jni$_.jlongType(), value);

  static final _id_availMem = _class.instanceFieldId(r'availMem', r'J');

  /// from: `public long availMem`
  int get availMem => _id_availMem.get(this, const jni$_.jlongType());

  /// from: `public long availMem`
  set availMem(int value) =>
      _id_availMem.set(this, const jni$_.jlongType(), value);

  static final _id_lowMemory = _class.instanceFieldId(r'lowMemory', r'Z');

  /// from: `public boolean lowMemory`
  bool get lowMemory => _id_lowMemory.get(this, const jni$_.jbooleanType());

  /// from: `public boolean lowMemory`
  set lowMemory(bool value) =>
      _id_lowMemory.set(this, const jni$_.jbooleanType(), value);

  static final _id_threshold = _class.instanceFieldId(r'threshold', r'J');

  /// from: `public long threshold`
  int get threshold => _id_threshold.get(this, const jni$_.jlongType());

  /// from: `public long threshold`
  set threshold(int value) =>
      _id_threshold.set(this, const jni$_.jlongType(), value);

  static final _id_totalMem = _class.instanceFieldId(r'totalMem', r'J');

  /// from: `public long totalMem`
  int get totalMem => _id_totalMem.get(this, const jni$_.jlongType());

  /// from: `public long totalMem`
  set totalMem(int value) =>
      _id_totalMem.set(this, const jni$_.jlongType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$MemoryInfo() {
    return ActivityManager$MemoryInfo.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readFromParcel = _class.instanceMethodId(
    r'readFromParcel',
    r'(Landroid/os/Parcel;)V',
  );

  static final _readFromParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void readFromParcel(android.os.Parcel parcel)`
  void readFromParcel(jni$_.JObject? parcel) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _readFromParcel(
      reference.pointer,
      _id_readFromParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
    ).check();
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $ActivityManager$MemoryInfo$NullableType$
    extends jni$_.JType<ActivityManager$MemoryInfo?> {
  @jni$_.internal
  const $ActivityManager$MemoryInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$MemoryInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$MemoryInfo? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : ActivityManager$MemoryInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$MemoryInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$MemoryInfo$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$MemoryInfo$NullableType$) &&
        other is $ActivityManager$MemoryInfo$NullableType$;
  }
}

final class $ActivityManager$MemoryInfo$Type$
    extends jni$_.JType<ActivityManager$MemoryInfo> {
  @jni$_.internal
  const $ActivityManager$MemoryInfo$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$MemoryInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$MemoryInfo fromReference(jni$_.JReference reference) =>
      ActivityManager$MemoryInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$MemoryInfo?> get nullableType =>
      const $ActivityManager$MemoryInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$MemoryInfo$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$MemoryInfo$Type$) &&
        other is $ActivityManager$MemoryInfo$Type$;
  }
}

/// from: `android.app.ActivityManager$ProcessErrorStateInfo`
class ActivityManager$ProcessErrorStateInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager$ProcessErrorStateInfo> $type;

  @jni$_.internal
  ActivityManager$ProcessErrorStateInfo.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/app/ActivityManager$ProcessErrorStateInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$ProcessErrorStateInfo?>
  nullableType = $ActivityManager$ProcessErrorStateInfo$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$ProcessErrorStateInfo> type =
      $ActivityManager$ProcessErrorStateInfo$Type$();

  /// from: `static public final int CRASHED`
  static const CRASHED = 1;
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.app.ActivityManager$ProcessErrorStateInfo> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$Type$());

  /// from: `static public final int NOT_RESPONDING`
  static const NOT_RESPONDING = 2;

  /// from: `static public final int NO_ERROR`
  static const NO_ERROR = 0;
  static final _id_condition = _class.instanceFieldId(r'condition', r'I');

  /// from: `public int condition`
  int get condition => _id_condition.get(this, const jni$_.jintType());

  /// from: `public int condition`
  set condition(int value) =>
      _id_condition.set(this, const jni$_.jintType(), value);

  static final _id_crashData = _class.instanceFieldId(r'crashData', r'[B');

  /// from: `public byte[] crashData`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? get crashData =>
      _id_crashData.get(this, const jni$_.$JByteArray$NullableType$());

  /// from: `public byte[] crashData`
  /// The returned object must be released after use, by calling the [release] method.
  set crashData(jni$_.JByteArray? value) =>
      _id_crashData.set(this, const jni$_.$JByteArray$NullableType$(), value);

  static final _id_longMsg = _class.instanceFieldId(
    r'longMsg',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String longMsg`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get longMsg =>
      _id_longMsg.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String longMsg`
  /// The returned object must be released after use, by calling the [release] method.
  set longMsg(jni$_.JString? value) =>
      _id_longMsg.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_pid = _class.instanceFieldId(r'pid', r'I');

  /// from: `public int pid`
  int get pid => _id_pid.get(this, const jni$_.jintType());

  /// from: `public int pid`
  set pid(int value) => _id_pid.set(this, const jni$_.jintType(), value);

  static final _id_processName = _class.instanceFieldId(
    r'processName',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String processName`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get processName =>
      _id_processName.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String processName`
  /// The returned object must be released after use, by calling the [release] method.
  set processName(jni$_.JString? value) =>
      _id_processName.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_shortMsg = _class.instanceFieldId(
    r'shortMsg',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String shortMsg`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get shortMsg =>
      _id_shortMsg.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String shortMsg`
  /// The returned object must be released after use, by calling the [release] method.
  set shortMsg(jni$_.JString? value) =>
      _id_shortMsg.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_stackTrace = _class.instanceFieldId(
    r'stackTrace',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String stackTrace`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get stackTrace =>
      _id_stackTrace.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String stackTrace`
  /// The returned object must be released after use, by calling the [release] method.
  set stackTrace(jni$_.JString? value) =>
      _id_stackTrace.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_tag = _class.instanceFieldId(r'tag', r'Ljava/lang/String;');

  /// from: `public java.lang.String tag`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get tag =>
      _id_tag.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String tag`
  /// The returned object must be released after use, by calling the [release] method.
  set tag(jni$_.JString? value) =>
      _id_tag.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_uid = _class.instanceFieldId(r'uid', r'I');

  /// from: `public int uid`
  int get uid => _id_uid.get(this, const jni$_.jintType());

  /// from: `public int uid`
  set uid(int value) => _id_uid.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$ProcessErrorStateInfo() {
    return ActivityManager$ProcessErrorStateInfo.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readFromParcel = _class.instanceMethodId(
    r'readFromParcel',
    r'(Landroid/os/Parcel;)V',
  );

  static final _readFromParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void readFromParcel(android.os.Parcel parcel)`
  void readFromParcel(jni$_.JObject? parcel) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _readFromParcel(
      reference.pointer,
      _id_readFromParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
    ).check();
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $ActivityManager$ProcessErrorStateInfo$NullableType$
    extends jni$_.JType<ActivityManager$ProcessErrorStateInfo?> {
  @jni$_.internal
  const $ActivityManager$ProcessErrorStateInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/app/ActivityManager$ProcessErrorStateInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$ProcessErrorStateInfo? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : ActivityManager$ProcessErrorStateInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$ProcessErrorStateInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ActivityManager$ProcessErrorStateInfo$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$ProcessErrorStateInfo$NullableType$) &&
        other is $ActivityManager$ProcessErrorStateInfo$NullableType$;
  }
}

final class $ActivityManager$ProcessErrorStateInfo$Type$
    extends jni$_.JType<ActivityManager$ProcessErrorStateInfo> {
  @jni$_.internal
  const $ActivityManager$ProcessErrorStateInfo$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/app/ActivityManager$ProcessErrorStateInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$ProcessErrorStateInfo fromReference(
    jni$_.JReference reference,
  ) => ActivityManager$ProcessErrorStateInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$ProcessErrorStateInfo?> get nullableType =>
      const $ActivityManager$ProcessErrorStateInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$ProcessErrorStateInfo$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$ProcessErrorStateInfo$Type$) &&
        other is $ActivityManager$ProcessErrorStateInfo$Type$;
  }
}

/// from: `android.app.ActivityManager$RecentTaskInfo`
class ActivityManager$RecentTaskInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager$RecentTaskInfo> $type;

  @jni$_.internal
  ActivityManager$RecentTaskInfo.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/app/ActivityManager$RecentTaskInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$RecentTaskInfo?> nullableType =
      $ActivityManager$RecentTaskInfo$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$RecentTaskInfo> type =
      $ActivityManager$RecentTaskInfo$Type$();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.app.ActivityManager$RecentTaskInfo> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$Type$());

  static final _id_affiliatedTaskId = _class.instanceFieldId(
    r'affiliatedTaskId',
    r'I',
  );

  /// from: `public int affiliatedTaskId`
  int get affiliatedTaskId =>
      _id_affiliatedTaskId.get(this, const jni$_.jintType());

  /// from: `public int affiliatedTaskId`
  set affiliatedTaskId(int value) =>
      _id_affiliatedTaskId.set(this, const jni$_.jintType(), value);

  static final _id_description = _class.instanceFieldId(
    r'description',
    r'Ljava/lang/CharSequence;',
  );

  /// from: `public java.lang.CharSequence description`
  /// The returned object must be released after use, by calling the [release] method.
  charsequence$_.CharSequence? get description => _id_description.get(
    this,
    const charsequence$_.$CharSequence$NullableType$(),
  );

  /// from: `public java.lang.CharSequence description`
  /// The returned object must be released after use, by calling the [release] method.
  set description(charsequence$_.CharSequence? value) => _id_description.set(
    this,
    const charsequence$_.$CharSequence$NullableType$(),
    value,
  );

  static final _id_id = _class.instanceFieldId(r'id', r'I');

  /// from: `public int id`
  int get id => _id_id.get(this, const jni$_.jintType());

  /// from: `public int id`
  set id(int value) => _id_id.set(this, const jni$_.jintType(), value);

  static final _id_persistentId = _class.instanceFieldId(r'persistentId', r'I');

  /// from: `public int persistentId`
  int get persistentId => _id_persistentId.get(this, const jni$_.jintType());

  /// from: `public int persistentId`
  set persistentId(int value) =>
      _id_persistentId.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$RecentTaskInfo() {
    return ActivityManager$RecentTaskInfo.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readFromParcel = _class.instanceMethodId(
    r'readFromParcel',
    r'(Landroid/os/Parcel;)V',
  );

  static final _readFromParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void readFromParcel(android.os.Parcel parcel)`
  void readFromParcel(jni$_.JObject? parcel) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _readFromParcel(
      reference.pointer,
      _id_readFromParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
    ).check();
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $ActivityManager$RecentTaskInfo$NullableType$
    extends jni$_.JType<ActivityManager$RecentTaskInfo?> {
  @jni$_.internal
  const $ActivityManager$RecentTaskInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$RecentTaskInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$RecentTaskInfo? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : ActivityManager$RecentTaskInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$RecentTaskInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$RecentTaskInfo$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$RecentTaskInfo$NullableType$) &&
        other is $ActivityManager$RecentTaskInfo$NullableType$;
  }
}

final class $ActivityManager$RecentTaskInfo$Type$
    extends jni$_.JType<ActivityManager$RecentTaskInfo> {
  @jni$_.internal
  const $ActivityManager$RecentTaskInfo$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$RecentTaskInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$RecentTaskInfo fromReference(jni$_.JReference reference) =>
      ActivityManager$RecentTaskInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$RecentTaskInfo?> get nullableType =>
      const $ActivityManager$RecentTaskInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$RecentTaskInfo$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$RecentTaskInfo$Type$) &&
        other is $ActivityManager$RecentTaskInfo$Type$;
  }
}

/// from: `android.app.ActivityManager$RunningAppProcessInfo`
class ActivityManager$RunningAppProcessInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager$RunningAppProcessInfo> $type;

  @jni$_.internal
  ActivityManager$RunningAppProcessInfo.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/app/ActivityManager$RunningAppProcessInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$RunningAppProcessInfo?>
  nullableType = $ActivityManager$RunningAppProcessInfo$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$RunningAppProcessInfo> type =
      $ActivityManager$RunningAppProcessInfo$Type$();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.app.ActivityManager$RunningAppProcessInfo> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$Type$());

  /// from: `static public final int IMPORTANCE_BACKGROUND`
  static const IMPORTANCE_BACKGROUND = 400;

  /// from: `static public final int IMPORTANCE_CACHED`
  static const IMPORTANCE_CACHED = 400;

  /// from: `static public final int IMPORTANCE_CANT_SAVE_STATE`
  static const IMPORTANCE_CANT_SAVE_STATE = 350;

  /// from: `static public final int IMPORTANCE_EMPTY`
  static const IMPORTANCE_EMPTY = 500;

  /// from: `static public final int IMPORTANCE_FOREGROUND`
  static const IMPORTANCE_FOREGROUND = 100;

  /// from: `static public final int IMPORTANCE_FOREGROUND_SERVICE`
  static const IMPORTANCE_FOREGROUND_SERVICE = 125;

  /// from: `static public final int IMPORTANCE_GONE`
  static const IMPORTANCE_GONE = 1000;

  /// from: `static public final int IMPORTANCE_PERCEPTIBLE`
  static const IMPORTANCE_PERCEPTIBLE = 230;

  /// from: `static public final int IMPORTANCE_PERCEPTIBLE_PRE_26`
  static const IMPORTANCE_PERCEPTIBLE_PRE_26 = 130;

  /// from: `static public final int IMPORTANCE_SERVICE`
  static const IMPORTANCE_SERVICE = 300;

  /// from: `static public final int IMPORTANCE_TOP_SLEEPING`
  static const IMPORTANCE_TOP_SLEEPING = 325;

  /// from: `static public final int IMPORTANCE_TOP_SLEEPING_PRE_28`
  static const IMPORTANCE_TOP_SLEEPING_PRE_28 = 150;

  /// from: `static public final int IMPORTANCE_VISIBLE`
  static const IMPORTANCE_VISIBLE = 200;

  /// from: `static public final int REASON_PROVIDER_IN_USE`
  static const REASON_PROVIDER_IN_USE = 1;

  /// from: `static public final int REASON_SERVICE_IN_USE`
  static const REASON_SERVICE_IN_USE = 2;

  /// from: `static public final int REASON_UNKNOWN`
  static const REASON_UNKNOWN = 0;
  static final _id_importance = _class.instanceFieldId(r'importance', r'I');

  /// from: `public int importance`
  int get importance => _id_importance.get(this, const jni$_.jintType());

  /// from: `public int importance`
  set importance(int value) =>
      _id_importance.set(this, const jni$_.jintType(), value);

  static final _id_importanceReasonCode = _class.instanceFieldId(
    r'importanceReasonCode',
    r'I',
  );

  /// from: `public int importanceReasonCode`
  int get importanceReasonCode =>
      _id_importanceReasonCode.get(this, const jni$_.jintType());

  /// from: `public int importanceReasonCode`
  set importanceReasonCode(int value) =>
      _id_importanceReasonCode.set(this, const jni$_.jintType(), value);

  static final _id_importanceReasonComponent = _class.instanceFieldId(
    r'importanceReasonComponent',
    r'Landroid/content/ComponentName;',
  );

  /// from: `public android.content.ComponentName importanceReasonComponent`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get importanceReasonComponent => _id_importanceReasonComponent
      .get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.content.ComponentName importanceReasonComponent`
  /// The returned object must be released after use, by calling the [release] method.
  set importanceReasonComponent(jni$_.JObject? value) =>
      _id_importanceReasonComponent.set(
        this,
        const jni$_.$JObject$NullableType$(),
        value,
      );

  static final _id_importanceReasonPid = _class.instanceFieldId(
    r'importanceReasonPid',
    r'I',
  );

  /// from: `public int importanceReasonPid`
  int get importanceReasonPid =>
      _id_importanceReasonPid.get(this, const jni$_.jintType());

  /// from: `public int importanceReasonPid`
  set importanceReasonPid(int value) =>
      _id_importanceReasonPid.set(this, const jni$_.jintType(), value);

  static final _id_lastTrimLevel = _class.instanceFieldId(
    r'lastTrimLevel',
    r'I',
  );

  /// from: `public int lastTrimLevel`
  int get lastTrimLevel => _id_lastTrimLevel.get(this, const jni$_.jintType());

  /// from: `public int lastTrimLevel`
  set lastTrimLevel(int value) =>
      _id_lastTrimLevel.set(this, const jni$_.jintType(), value);

  static final _id_lru = _class.instanceFieldId(r'lru', r'I');

  /// from: `public int lru`
  int get lru => _id_lru.get(this, const jni$_.jintType());

  /// from: `public int lru`
  set lru(int value) => _id_lru.set(this, const jni$_.jintType(), value);

  static final _id_pid = _class.instanceFieldId(r'pid', r'I');

  /// from: `public int pid`
  int get pid => _id_pid.get(this, const jni$_.jintType());

  /// from: `public int pid`
  set pid(int value) => _id_pid.set(this, const jni$_.jintType(), value);

  static final _id_pkgList = _class.instanceFieldId(
    r'pkgList',
    r'[Ljava/lang/String;',
  );

  /// from: `public java.lang.String[] pkgList`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? get pkgList => _id_pkgList.get(
    this,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
  );

  /// from: `public java.lang.String[] pkgList`
  /// The returned object must be released after use, by calling the [release] method.
  set pkgList(jni$_.JArray<jni$_.JString?>? value) => _id_pkgList.set(
    this,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
    value,
  );

  static final _id_processName = _class.instanceFieldId(
    r'processName',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String processName`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get processName =>
      _id_processName.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String processName`
  /// The returned object must be released after use, by calling the [release] method.
  set processName(jni$_.JString? value) =>
      _id_processName.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_uid = _class.instanceFieldId(r'uid', r'I');

  /// from: `public int uid`
  int get uid => _id_uid.get(this, const jni$_.jintType());

  /// from: `public int uid`
  set uid(int value) => _id_uid.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$RunningAppProcessInfo() {
    return ActivityManager$RunningAppProcessInfo.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;I[Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i, java.lang.String[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$RunningAppProcessInfo.new$1(
    jni$_.JString? string,
    int i,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return ActivityManager$RunningAppProcessInfo.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
        _$strings.pointer,
      ).reference,
    );
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readFromParcel = _class.instanceMethodId(
    r'readFromParcel',
    r'(Landroid/os/Parcel;)V',
  );

  static final _readFromParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void readFromParcel(android.os.Parcel parcel)`
  void readFromParcel(jni$_.JObject? parcel) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _readFromParcel(
      reference.pointer,
      _id_readFromParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
    ).check();
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $ActivityManager$RunningAppProcessInfo$NullableType$
    extends jni$_.JType<ActivityManager$RunningAppProcessInfo?> {
  @jni$_.internal
  const $ActivityManager$RunningAppProcessInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/app/ActivityManager$RunningAppProcessInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$RunningAppProcessInfo? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : ActivityManager$RunningAppProcessInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$RunningAppProcessInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ActivityManager$RunningAppProcessInfo$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$RunningAppProcessInfo$NullableType$) &&
        other is $ActivityManager$RunningAppProcessInfo$NullableType$;
  }
}

final class $ActivityManager$RunningAppProcessInfo$Type$
    extends jni$_.JType<ActivityManager$RunningAppProcessInfo> {
  @jni$_.internal
  const $ActivityManager$RunningAppProcessInfo$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/app/ActivityManager$RunningAppProcessInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$RunningAppProcessInfo fromReference(
    jni$_.JReference reference,
  ) => ActivityManager$RunningAppProcessInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$RunningAppProcessInfo?> get nullableType =>
      const $ActivityManager$RunningAppProcessInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$RunningAppProcessInfo$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$RunningAppProcessInfo$Type$) &&
        other is $ActivityManager$RunningAppProcessInfo$Type$;
  }
}

/// from: `android.app.ActivityManager$RunningServiceInfo`
class ActivityManager$RunningServiceInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager$RunningServiceInfo> $type;

  @jni$_.internal
  ActivityManager$RunningServiceInfo.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/app/ActivityManager$RunningServiceInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$RunningServiceInfo?> nullableType =
      $ActivityManager$RunningServiceInfo$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$RunningServiceInfo> type =
      $ActivityManager$RunningServiceInfo$Type$();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.app.ActivityManager$RunningServiceInfo> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$Type$());

  /// from: `static public final int FLAG_FOREGROUND`
  static const FLAG_FOREGROUND = 2;

  /// from: `static public final int FLAG_PERSISTENT_PROCESS`
  static const FLAG_PERSISTENT_PROCESS = 8;

  /// from: `static public final int FLAG_STARTED`
  static const FLAG_STARTED = 1;

  /// from: `static public final int FLAG_SYSTEM_PROCESS`
  static const FLAG_SYSTEM_PROCESS = 4;
  static final _id_activeSince = _class.instanceFieldId(r'activeSince', r'J');

  /// from: `public long activeSince`
  int get activeSince => _id_activeSince.get(this, const jni$_.jlongType());

  /// from: `public long activeSince`
  set activeSince(int value) =>
      _id_activeSince.set(this, const jni$_.jlongType(), value);

  static final _id_clientCount = _class.instanceFieldId(r'clientCount', r'I');

  /// from: `public int clientCount`
  int get clientCount => _id_clientCount.get(this, const jni$_.jintType());

  /// from: `public int clientCount`
  set clientCount(int value) =>
      _id_clientCount.set(this, const jni$_.jintType(), value);

  static final _id_clientLabel = _class.instanceFieldId(r'clientLabel', r'I');

  /// from: `public int clientLabel`
  int get clientLabel => _id_clientLabel.get(this, const jni$_.jintType());

  /// from: `public int clientLabel`
  set clientLabel(int value) =>
      _id_clientLabel.set(this, const jni$_.jintType(), value);

  static final _id_clientPackage = _class.instanceFieldId(
    r'clientPackage',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String clientPackage`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get clientPackage =>
      _id_clientPackage.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String clientPackage`
  /// The returned object must be released after use, by calling the [release] method.
  set clientPackage(jni$_.JString? value) =>
      _id_clientPackage.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_crashCount = _class.instanceFieldId(r'crashCount', r'I');

  /// from: `public int crashCount`
  int get crashCount => _id_crashCount.get(this, const jni$_.jintType());

  /// from: `public int crashCount`
  set crashCount(int value) =>
      _id_crashCount.set(this, const jni$_.jintType(), value);

  static final _id_flags = _class.instanceFieldId(r'flags', r'I');

  /// from: `public int flags`
  int get flags => _id_flags.get(this, const jni$_.jintType());

  /// from: `public int flags`
  set flags(int value) => _id_flags.set(this, const jni$_.jintType(), value);

  static final _id_foreground = _class.instanceFieldId(r'foreground', r'Z');

  /// from: `public boolean foreground`
  bool get foreground => _id_foreground.get(this, const jni$_.jbooleanType());

  /// from: `public boolean foreground`
  set foreground(bool value) =>
      _id_foreground.set(this, const jni$_.jbooleanType(), value);

  static final _id_lastActivityTime = _class.instanceFieldId(
    r'lastActivityTime',
    r'J',
  );

  /// from: `public long lastActivityTime`
  int get lastActivityTime =>
      _id_lastActivityTime.get(this, const jni$_.jlongType());

  /// from: `public long lastActivityTime`
  set lastActivityTime(int value) =>
      _id_lastActivityTime.set(this, const jni$_.jlongType(), value);

  static final _id_pid = _class.instanceFieldId(r'pid', r'I');

  /// from: `public int pid`
  int get pid => _id_pid.get(this, const jni$_.jintType());

  /// from: `public int pid`
  set pid(int value) => _id_pid.set(this, const jni$_.jintType(), value);

  static final _id_process = _class.instanceFieldId(
    r'process',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String process`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get process =>
      _id_process.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String process`
  /// The returned object must be released after use, by calling the [release] method.
  set process(jni$_.JString? value) =>
      _id_process.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_restarting = _class.instanceFieldId(r'restarting', r'J');

  /// from: `public long restarting`
  int get restarting => _id_restarting.get(this, const jni$_.jlongType());

  /// from: `public long restarting`
  set restarting(int value) =>
      _id_restarting.set(this, const jni$_.jlongType(), value);

  static final _id_service = _class.instanceFieldId(
    r'service',
    r'Landroid/content/ComponentName;',
  );

  /// from: `public android.content.ComponentName service`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get service =>
      _id_service.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.content.ComponentName service`
  /// The returned object must be released after use, by calling the [release] method.
  set service(jni$_.JObject? value) =>
      _id_service.set(this, const jni$_.$JObject$NullableType$(), value);

  static final _id_started = _class.instanceFieldId(r'started', r'Z');

  /// from: `public boolean started`
  bool get started => _id_started.get(this, const jni$_.jbooleanType());

  /// from: `public boolean started`
  set started(bool value) =>
      _id_started.set(this, const jni$_.jbooleanType(), value);

  static final _id_uid = _class.instanceFieldId(r'uid', r'I');

  /// from: `public int uid`
  int get uid => _id_uid.get(this, const jni$_.jintType());

  /// from: `public int uid`
  set uid(int value) => _id_uid.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$RunningServiceInfo() {
    return ActivityManager$RunningServiceInfo.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readFromParcel = _class.instanceMethodId(
    r'readFromParcel',
    r'(Landroid/os/Parcel;)V',
  );

  static final _readFromParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void readFromParcel(android.os.Parcel parcel)`
  void readFromParcel(jni$_.JObject? parcel) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _readFromParcel(
      reference.pointer,
      _id_readFromParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
    ).check();
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $ActivityManager$RunningServiceInfo$NullableType$
    extends jni$_.JType<ActivityManager$RunningServiceInfo?> {
  @jni$_.internal
  const $ActivityManager$RunningServiceInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$RunningServiceInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$RunningServiceInfo? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : ActivityManager$RunningServiceInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$RunningServiceInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ActivityManager$RunningServiceInfo$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$RunningServiceInfo$NullableType$) &&
        other is $ActivityManager$RunningServiceInfo$NullableType$;
  }
}

final class $ActivityManager$RunningServiceInfo$Type$
    extends jni$_.JType<ActivityManager$RunningServiceInfo> {
  @jni$_.internal
  const $ActivityManager$RunningServiceInfo$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$RunningServiceInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$RunningServiceInfo fromReference(
    jni$_.JReference reference,
  ) => ActivityManager$RunningServiceInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$RunningServiceInfo?> get nullableType =>
      const $ActivityManager$RunningServiceInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$RunningServiceInfo$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$RunningServiceInfo$Type$) &&
        other is $ActivityManager$RunningServiceInfo$Type$;
  }
}

/// from: `android.app.ActivityManager$RunningTaskInfo`
class ActivityManager$RunningTaskInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager$RunningTaskInfo> $type;

  @jni$_.internal
  ActivityManager$RunningTaskInfo.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/app/ActivityManager$RunningTaskInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$RunningTaskInfo?> nullableType =
      $ActivityManager$RunningTaskInfo$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$RunningTaskInfo> type =
      $ActivityManager$RunningTaskInfo$Type$();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.app.ActivityManager$RunningTaskInfo> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$Type$());

  static final _id_description = _class.instanceFieldId(
    r'description',
    r'Ljava/lang/CharSequence;',
  );

  /// from: `public java.lang.CharSequence description`
  /// The returned object must be released after use, by calling the [release] method.
  charsequence$_.CharSequence? get description => _id_description.get(
    this,
    const charsequence$_.$CharSequence$NullableType$(),
  );

  /// from: `public java.lang.CharSequence description`
  /// The returned object must be released after use, by calling the [release] method.
  set description(charsequence$_.CharSequence? value) => _id_description.set(
    this,
    const charsequence$_.$CharSequence$NullableType$(),
    value,
  );

  static final _id_id = _class.instanceFieldId(r'id', r'I');

  /// from: `public int id`
  int get id => _id_id.get(this, const jni$_.jintType());

  /// from: `public int id`
  set id(int value) => _id_id.set(this, const jni$_.jintType(), value);

  static final _id_numRunning = _class.instanceFieldId(r'numRunning', r'I');

  /// from: `public int numRunning`
  int get numRunning => _id_numRunning.get(this, const jni$_.jintType());

  /// from: `public int numRunning`
  set numRunning(int value) =>
      _id_numRunning.set(this, const jni$_.jintType(), value);

  static final _id_thumbnail = _class.instanceFieldId(
    r'thumbnail',
    r'Landroid/graphics/Bitmap;',
  );

  /// from: `public android.graphics.Bitmap thumbnail`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get thumbnail =>
      _id_thumbnail.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.graphics.Bitmap thumbnail`
  /// The returned object must be released after use, by calling the [release] method.
  set thumbnail(jni$_.JObject? value) =>
      _id_thumbnail.set(this, const jni$_.$JObject$NullableType$(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$RunningTaskInfo() {
    return ActivityManager$RunningTaskInfo.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readFromParcel = _class.instanceMethodId(
    r'readFromParcel',
    r'(Landroid/os/Parcel;)V',
  );

  static final _readFromParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void readFromParcel(android.os.Parcel parcel)`
  void readFromParcel(jni$_.JObject? parcel) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _readFromParcel(
      reference.pointer,
      _id_readFromParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
    ).check();
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $ActivityManager$RunningTaskInfo$NullableType$
    extends jni$_.JType<ActivityManager$RunningTaskInfo?> {
  @jni$_.internal
  const $ActivityManager$RunningTaskInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$RunningTaskInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$RunningTaskInfo? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : ActivityManager$RunningTaskInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$RunningTaskInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$RunningTaskInfo$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$RunningTaskInfo$NullableType$) &&
        other is $ActivityManager$RunningTaskInfo$NullableType$;
  }
}

final class $ActivityManager$RunningTaskInfo$Type$
    extends jni$_.JType<ActivityManager$RunningTaskInfo> {
  @jni$_.internal
  const $ActivityManager$RunningTaskInfo$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$RunningTaskInfo;';

  @jni$_.internal
  @core$_.override
  ActivityManager$RunningTaskInfo fromReference(jni$_.JReference reference) =>
      ActivityManager$RunningTaskInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$RunningTaskInfo?> get nullableType =>
      const $ActivityManager$RunningTaskInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$RunningTaskInfo$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$RunningTaskInfo$Type$) &&
        other is $ActivityManager$RunningTaskInfo$Type$;
  }
}

/// from: `android.app.ActivityManager$TaskDescription$Builder`
class ActivityManager$TaskDescription$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager$TaskDescription$Builder> $type;

  @jni$_.internal
  ActivityManager$TaskDescription$Builder.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/app/ActivityManager$TaskDescription$Builder',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$TaskDescription$Builder?>
  nullableType = $ActivityManager$TaskDescription$Builder$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$TaskDescription$Builder> type =
      $ActivityManager$TaskDescription$Builder$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$TaskDescription$Builder() {
    return ActivityManager$TaskDescription$Builder.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Landroid/app/ActivityManager$TaskDescription;',
  );

  static final _build =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.app.ActivityManager$TaskDescription build()`
  /// The returned object must be released after use, by calling the [release] method.
  ActivityManager$TaskDescription build() {
    return _build(
      reference.pointer,
      _id_build as jni$_.JMethodIDPtr,
    ).object<ActivityManager$TaskDescription>(
      const $ActivityManager$TaskDescription$Type$(),
    );
  }

  static final _id_setBackgroundColor = _class.instanceMethodId(
    r'setBackgroundColor',
    r'(I)Landroid/app/ActivityManager$TaskDescription$Builder;',
  );

  static final _setBackgroundColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public android.app.ActivityManager$TaskDescription$Builder setBackgroundColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ActivityManager$TaskDescription$Builder setBackgroundColor(int i) {
    return _setBackgroundColor(
      reference.pointer,
      _id_setBackgroundColor as jni$_.JMethodIDPtr,
      i,
    ).object<ActivityManager$TaskDescription$Builder>(
      const $ActivityManager$TaskDescription$Builder$Type$(),
    );
  }

  static final _id_setIcon = _class.instanceMethodId(
    r'setIcon',
    r'(I)Landroid/app/ActivityManager$TaskDescription$Builder;',
  );

  static final _setIcon =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public android.app.ActivityManager$TaskDescription$Builder setIcon(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ActivityManager$TaskDescription$Builder setIcon(int i) {
    return _setIcon(
      reference.pointer,
      _id_setIcon as jni$_.JMethodIDPtr,
      i,
    ).object<ActivityManager$TaskDescription$Builder>(
      const $ActivityManager$TaskDescription$Builder$Type$(),
    );
  }

  static final _id_setLabel = _class.instanceMethodId(
    r'setLabel',
    r'(Ljava/lang/String;)Landroid/app/ActivityManager$TaskDescription$Builder;',
  );

  static final _setLabel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.app.ActivityManager$TaskDescription$Builder setLabel(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ActivityManager$TaskDescription$Builder setLabel(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setLabel(
      reference.pointer,
      _id_setLabel as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ActivityManager$TaskDescription$Builder>(
      const $ActivityManager$TaskDescription$Builder$Type$(),
    );
  }

  static final _id_setNavigationBarColor = _class.instanceMethodId(
    r'setNavigationBarColor',
    r'(I)Landroid/app/ActivityManager$TaskDescription$Builder;',
  );

  static final _setNavigationBarColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public android.app.ActivityManager$TaskDescription$Builder setNavigationBarColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ActivityManager$TaskDescription$Builder setNavigationBarColor(int i) {
    return _setNavigationBarColor(
      reference.pointer,
      _id_setNavigationBarColor as jni$_.JMethodIDPtr,
      i,
    ).object<ActivityManager$TaskDescription$Builder>(
      const $ActivityManager$TaskDescription$Builder$Type$(),
    );
  }

  static final _id_setPrimaryColor = _class.instanceMethodId(
    r'setPrimaryColor',
    r'(I)Landroid/app/ActivityManager$TaskDescription$Builder;',
  );

  static final _setPrimaryColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public android.app.ActivityManager$TaskDescription$Builder setPrimaryColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ActivityManager$TaskDescription$Builder setPrimaryColor(int i) {
    return _setPrimaryColor(
      reference.pointer,
      _id_setPrimaryColor as jni$_.JMethodIDPtr,
      i,
    ).object<ActivityManager$TaskDescription$Builder>(
      const $ActivityManager$TaskDescription$Builder$Type$(),
    );
  }

  static final _id_setStatusBarColor = _class.instanceMethodId(
    r'setStatusBarColor',
    r'(I)Landroid/app/ActivityManager$TaskDescription$Builder;',
  );

  static final _setStatusBarColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public android.app.ActivityManager$TaskDescription$Builder setStatusBarColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ActivityManager$TaskDescription$Builder setStatusBarColor(int i) {
    return _setStatusBarColor(
      reference.pointer,
      _id_setStatusBarColor as jni$_.JMethodIDPtr,
      i,
    ).object<ActivityManager$TaskDescription$Builder>(
      const $ActivityManager$TaskDescription$Builder$Type$(),
    );
  }
}

final class $ActivityManager$TaskDescription$Builder$NullableType$
    extends jni$_.JType<ActivityManager$TaskDescription$Builder?> {
  @jni$_.internal
  const $ActivityManager$TaskDescription$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/app/ActivityManager$TaskDescription$Builder;';

  @jni$_.internal
  @core$_.override
  ActivityManager$TaskDescription$Builder? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : ActivityManager$TaskDescription$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$TaskDescription$Builder?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ActivityManager$TaskDescription$Builder$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$TaskDescription$Builder$NullableType$) &&
        other is $ActivityManager$TaskDescription$Builder$NullableType$;
  }
}

final class $ActivityManager$TaskDescription$Builder$Type$
    extends jni$_.JType<ActivityManager$TaskDescription$Builder> {
  @jni$_.internal
  const $ActivityManager$TaskDescription$Builder$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/app/ActivityManager$TaskDescription$Builder;';

  @jni$_.internal
  @core$_.override
  ActivityManager$TaskDescription$Builder fromReference(
    jni$_.JReference reference,
  ) => ActivityManager$TaskDescription$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$TaskDescription$Builder?> get nullableType =>
      const $ActivityManager$TaskDescription$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$TaskDescription$Builder$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$TaskDescription$Builder$Type$) &&
        other is $ActivityManager$TaskDescription$Builder$Type$;
  }
}

/// from: `android.app.ActivityManager$TaskDescription`
class ActivityManager$TaskDescription extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager$TaskDescription> $type;

  @jni$_.internal
  ActivityManager$TaskDescription.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/app/ActivityManager$TaskDescription',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$TaskDescription?> nullableType =
      $ActivityManager$TaskDescription$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager$TaskDescription> type =
      $ActivityManager$TaskDescription$Type$();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.app.ActivityManager$TaskDescription> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$Type$());

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$TaskDescription() {
    return ActivityManager$TaskDescription.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Landroid/app/ActivityManager$TaskDescription;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(android.app.ActivityManager$TaskDescription taskDescription)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$TaskDescription.new$1(
    ActivityManager$TaskDescription? taskDescription,
  ) {
    final _$taskDescription =
        taskDescription?.reference ?? jni$_.jNullReference;
    return ActivityManager$TaskDescription.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$taskDescription.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$TaskDescription.new$2(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return ActivityManager$TaskDescription.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, android.graphics.Bitmap bitmap)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$TaskDescription.new$3(
    jni$_.JString? string,
    jni$_.JObject? bitmap,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return ActivityManager$TaskDescription.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$bitmap.pointer,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;I)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, android.graphics.Bitmap bitmap, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$TaskDescription.new$4(
    jni$_.JString? string,
    jni$_.JObject? bitmap,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return ActivityManager$TaskDescription.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$bitmap.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'(Ljava/lang/String;I)V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$TaskDescription.new$5(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return ActivityManager$TaskDescription.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(r'(Ljava/lang/String;II)V');

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ActivityManager$TaskDescription.new$6(
    jni$_.JString? string,
    int i,
    int i1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return ActivityManager$TaskDescription.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
        i1,
      ).reference,
    );
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_getBackgroundColor = _class.instanceMethodId(
    r'getBackgroundColor',
    r'()I',
  );

  static final _getBackgroundColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getBackgroundColor()`
  int getBackgroundColor() {
    return _getBackgroundColor(
      reference.pointer,
      _id_getBackgroundColor as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getIcon = _class.instanceMethodId(
    r'getIcon',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _getIcon =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Bitmap getIcon()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getIcon() {
    return _getIcon(
      reference.pointer,
      _id_getIcon as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getLabel = _class.instanceMethodId(
    r'getLabel',
    r'()Ljava/lang/String;',
  );

  static final _getLabel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getLabel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getLabel() {
    return _getLabel(
      reference.pointer,
      _id_getLabel as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getNavigationBarColor = _class.instanceMethodId(
    r'getNavigationBarColor',
    r'()I',
  );

  static final _getNavigationBarColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNavigationBarColor()`
  int getNavigationBarColor() {
    return _getNavigationBarColor(
      reference.pointer,
      _id_getNavigationBarColor as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getPrimaryColor = _class.instanceMethodId(
    r'getPrimaryColor',
    r'()I',
  );

  static final _getPrimaryColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPrimaryColor()`
  int getPrimaryColor() {
    return _getPrimaryColor(
      reference.pointer,
      _id_getPrimaryColor as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getStatusBarColor = _class.instanceMethodId(
    r'getStatusBarColor',
    r'()I',
  );

  static final _getStatusBarColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getStatusBarColor()`
  int getStatusBarColor() {
    return _getStatusBarColor(
      reference.pointer,
      _id_getStatusBarColor as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readFromParcel = _class.instanceMethodId(
    r'readFromParcel',
    r'(Landroid/os/Parcel;)V',
  );

  static final _readFromParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void readFromParcel(android.os.Parcel parcel)`
  void readFromParcel(jni$_.JObject? parcel) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _readFromParcel(
      reference.pointer,
      _id_readFromParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $ActivityManager$TaskDescription$NullableType$
    extends jni$_.JType<ActivityManager$TaskDescription?> {
  @jni$_.internal
  const $ActivityManager$TaskDescription$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$TaskDescription;';

  @jni$_.internal
  @core$_.override
  ActivityManager$TaskDescription? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : ActivityManager$TaskDescription.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$TaskDescription?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$TaskDescription$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ActivityManager$TaskDescription$NullableType$) &&
        other is $ActivityManager$TaskDescription$NullableType$;
  }
}

final class $ActivityManager$TaskDescription$Type$
    extends jni$_.JType<ActivityManager$TaskDescription> {
  @jni$_.internal
  const $ActivityManager$TaskDescription$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager$TaskDescription;';

  @jni$_.internal
  @core$_.override
  ActivityManager$TaskDescription fromReference(jni$_.JReference reference) =>
      ActivityManager$TaskDescription.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager$TaskDescription?> get nullableType =>
      const $ActivityManager$TaskDescription$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$TaskDescription$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$TaskDescription$Type$) &&
        other is $ActivityManager$TaskDescription$Type$;
  }
}

/// from: `android.app.ActivityManager`
class ActivityManager extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ActivityManager> $type;

  @jni$_.internal
  ActivityManager.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/app/ActivityManager');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager?> nullableType =
      $ActivityManager$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ActivityManager> type = $ActivityManager$Type$();
  static final _id_ACTION_REPORT_HEAP_LIMIT = _class.staticFieldId(
    r'ACTION_REPORT_HEAP_LIMIT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_REPORT_HEAP_LIMIT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_REPORT_HEAP_LIMIT =>
      _id_ACTION_REPORT_HEAP_LIMIT.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  /// from: `static public final int LOCK_TASK_MODE_LOCKED`
  static const LOCK_TASK_MODE_LOCKED = 1;

  /// from: `static public final int LOCK_TASK_MODE_NONE`
  static const LOCK_TASK_MODE_NONE = 0;

  /// from: `static public final int LOCK_TASK_MODE_PINNED`
  static const LOCK_TASK_MODE_PINNED = 2;
  static final _id_META_HOME_ALTERNATE = _class.staticFieldId(
    r'META_HOME_ALTERNATE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String META_HOME_ALTERNATE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get META_HOME_ALTERNATE =>
      _id_META_HOME_ALTERNATE.get(_class, const jni$_.$JString$NullableType$());

  /// from: `static public final int MOVE_TASK_NO_USER_ACTION`
  static const MOVE_TASK_NO_USER_ACTION = 2;

  /// from: `static public final int MOVE_TASK_WITH_HOME`
  static const MOVE_TASK_WITH_HOME = 1;

  /// from: `static public final int RECENT_IGNORE_UNAVAILABLE`
  static const RECENT_IGNORE_UNAVAILABLE = 2;

  /// from: `static public final int RECENT_WITH_EXCLUDED`
  static const RECENT_WITH_EXCLUDED = 1;
  static final _id_addAppTask = _class.instanceMethodId(
    r'addAppTask',
    r'(Landroid/app/Activity;Landroid/content/Intent;Landroid/app/ActivityManager$TaskDescription;Landroid/graphics/Bitmap;)I',
  );

  static final _addAppTask =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int addAppTask(android.app.Activity activity, android.content.Intent intent, android.app.ActivityManager$TaskDescription taskDescription, android.graphics.Bitmap bitmap)`
  int addAppTask(
    activity$_.Activity activity,
    intent$_.Intent intent,
    ActivityManager$TaskDescription? taskDescription,
    jni$_.JObject bitmap,
  ) {
    final _$activity = activity.reference;
    final _$intent = intent.reference;
    final _$taskDescription =
        taskDescription?.reference ?? jni$_.jNullReference;
    final _$bitmap = bitmap.reference;
    return _addAppTask(
      reference.pointer,
      _id_addAppTask as jni$_.JMethodIDPtr,
      _$activity.pointer,
      _$intent.pointer,
      _$taskDescription.pointer,
      _$bitmap.pointer,
    ).integer;
  }

  static final _id_addApplicationStartInfoCompletionListener = _class
      .instanceMethodId(
        r'addApplicationStartInfoCompletionListener',
        r'(Ljava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
      );

  static final _addApplicationStartInfoCompletionListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addApplicationStartInfoCompletionListener(java.util.concurrent.Executor executor, java.util.function.Consumer<android.app.ApplicationStartInfo> consumer)`
  void addApplicationStartInfoCompletionListener(
    executor$_.Executor executor,
    jni$_.JObject consumer,
  ) {
    final _$executor = executor.reference;
    final _$consumer = consumer.reference;
    _addApplicationStartInfoCompletionListener(
      reference.pointer,
      _id_addApplicationStartInfoCompletionListener as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$consumer.pointer,
    ).check();
  }

  static final _id_addStartInfoTimestamp = _class.instanceMethodId(
    r'addStartInfoTimestamp',
    r'(IJ)V',
  );

  static final _addStartInfoTimestamp =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void addStartInfoTimestamp(int i, long j)`
  void addStartInfoTimestamp(int i, int j) {
    _addStartInfoTimestamp(
      reference.pointer,
      _id_addStartInfoTimestamp as jni$_.JMethodIDPtr,
      i,
      j,
    ).check();
  }

  static final _id_appNotResponding = _class.instanceMethodId(
    r'appNotResponding',
    r'(Ljava/lang/String;)V',
  );

  static final _appNotResponding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void appNotResponding(java.lang.String string)`
  void appNotResponding(jni$_.JString string) {
    final _$string = string.reference;
    _appNotResponding(
      reference.pointer,
      _id_appNotResponding as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_clearApplicationUserData = _class.instanceMethodId(
    r'clearApplicationUserData',
    r'()Z',
  );

  static final _clearApplicationUserData =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean clearApplicationUserData()`
  bool clearApplicationUserData() {
    return _clearApplicationUserData(
      reference.pointer,
      _id_clearApplicationUserData as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_clearWatchHeapLimit = _class.instanceMethodId(
    r'clearWatchHeapLimit',
    r'()V',
  );

  static final _clearWatchHeapLimit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void clearWatchHeapLimit()`
  void clearWatchHeapLimit() {
    _clearWatchHeapLimit(
      reference.pointer,
      _id_clearWatchHeapLimit as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_dumpPackageState = _class.instanceMethodId(
    r'dumpPackageState',
    r'(Ljava/io/FileDescriptor;Ljava/lang/String;)V',
  );

  static final _dumpPackageState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void dumpPackageState(java.io.FileDescriptor fileDescriptor, java.lang.String string)`
  void dumpPackageState(
    filedescriptor$_.FileDescriptor? fileDescriptor,
    jni$_.JString? string,
  ) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _dumpPackageState(
      reference.pointer,
      _id_dumpPackageState as jni$_.JMethodIDPtr,
      _$fileDescriptor.pointer,
      _$string.pointer,
    ).check();
  }

  static final _id_getAppTaskThumbnailSize = _class.instanceMethodId(
    r'getAppTaskThumbnailSize',
    r'()Landroid/util/Size;',
  );

  static final _getAppTaskThumbnailSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.util.Size getAppTaskThumbnailSize()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAppTaskThumbnailSize() {
    return _getAppTaskThumbnailSize(
      reference.pointer,
      _id_getAppTaskThumbnailSize as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getAppTasks = _class.instanceMethodId(
    r'getAppTasks',
    r'()Ljava/util/List;',
  );

  static final _getAppTasks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.app.ActivityManager$AppTask> getAppTasks()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<ActivityManager$AppTask?>? getAppTasks() {
    return _getAppTasks(
      reference.pointer,
      _id_getAppTasks as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<ActivityManager$AppTask?>?>(
      const jni$_.$JList$NullableType$<ActivityManager$AppTask?>(
        $ActivityManager$AppTask$NullableType$(),
      ),
    );
  }

  static final _id_getDeviceConfigurationInfo = _class.instanceMethodId(
    r'getDeviceConfigurationInfo',
    r'()Landroid/content/pm/ConfigurationInfo;',
  );

  static final _getDeviceConfigurationInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.content.pm.ConfigurationInfo getDeviceConfigurationInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDeviceConfigurationInfo() {
    return _getDeviceConfigurationInfo(
      reference.pointer,
      _id_getDeviceConfigurationInfo as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getHistoricalProcessExitReasons = _class.instanceMethodId(
    r'getHistoricalProcessExitReasons',
    r'(Ljava/lang/String;II)Ljava/util/List;',
  );

  static final _getHistoricalProcessExitReasons =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.util.List<android.app.ApplicationExitInfo> getHistoricalProcessExitReasons(java.lang.String string, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getHistoricalProcessExitReasons(
    jni$_.JString? string,
    int i,
    int i1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHistoricalProcessExitReasons(
      reference.pointer,
      _id_getHistoricalProcessExitReasons as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getHistoricalProcessStartReasons = _class.instanceMethodId(
    r'getHistoricalProcessStartReasons',
    r'(I)Ljava/util/List;',
  );

  static final _getHistoricalProcessStartReasons =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.util.List<android.app.ApplicationStartInfo> getHistoricalProcessStartReasons(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getHistoricalProcessStartReasons(int i) {
    return _getHistoricalProcessStartReasons(
      reference.pointer,
      _id_getHistoricalProcessStartReasons as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getLargeMemoryClass = _class.instanceMethodId(
    r'getLargeMemoryClass',
    r'()I',
  );

  static final _getLargeMemoryClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLargeMemoryClass()`
  int getLargeMemoryClass() {
    return _getLargeMemoryClass(
      reference.pointer,
      _id_getLargeMemoryClass as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getLauncherLargeIconDensity = _class.instanceMethodId(
    r'getLauncherLargeIconDensity',
    r'()I',
  );

  static final _getLauncherLargeIconDensity =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLauncherLargeIconDensity()`
  int getLauncherLargeIconDensity() {
    return _getLauncherLargeIconDensity(
      reference.pointer,
      _id_getLauncherLargeIconDensity as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getLauncherLargeIconSize = _class.instanceMethodId(
    r'getLauncherLargeIconSize',
    r'()I',
  );

  static final _getLauncherLargeIconSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLauncherLargeIconSize()`
  int getLauncherLargeIconSize() {
    return _getLauncherLargeIconSize(
      reference.pointer,
      _id_getLauncherLargeIconSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getLockTaskModeState = _class.instanceMethodId(
    r'getLockTaskModeState',
    r'()I',
  );

  static final _getLockTaskModeState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLockTaskModeState()`
  int getLockTaskModeState() {
    return _getLockTaskModeState(
      reference.pointer,
      _id_getLockTaskModeState as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMemoryClass = _class.instanceMethodId(
    r'getMemoryClass',
    r'()I',
  );

  static final _getMemoryClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMemoryClass()`
  int getMemoryClass() {
    return _getMemoryClass(
      reference.pointer,
      _id_getMemoryClass as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMemoryInfo = _class.instanceMethodId(
    r'getMemoryInfo',
    r'(Landroid/app/ActivityManager$MemoryInfo;)V',
  );

  static final _getMemoryInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getMemoryInfo(android.app.ActivityManager$MemoryInfo memoryInfo)`
  void getMemoryInfo(ActivityManager$MemoryInfo? memoryInfo) {
    final _$memoryInfo = memoryInfo?.reference ?? jni$_.jNullReference;
    _getMemoryInfo(
      reference.pointer,
      _id_getMemoryInfo as jni$_.JMethodIDPtr,
      _$memoryInfo.pointer,
    ).check();
  }

  static final _id_getMyMemoryState = _class.staticMethodId(
    r'getMyMemoryState',
    r'(Landroid/app/ActivityManager$RunningAppProcessInfo;)V',
  );

  static final _getMyMemoryState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void getMyMemoryState(android.app.ActivityManager$RunningAppProcessInfo runningAppProcessInfo)`
  static void getMyMemoryState(
    ActivityManager$RunningAppProcessInfo? runningAppProcessInfo,
  ) {
    final _$runningAppProcessInfo =
        runningAppProcessInfo?.reference ?? jni$_.jNullReference;
    _getMyMemoryState(
      _class.reference.pointer,
      _id_getMyMemoryState as jni$_.JMethodIDPtr,
      _$runningAppProcessInfo.pointer,
    ).check();
  }

  static final _id_getProcessMemoryInfo = _class.instanceMethodId(
    r'getProcessMemoryInfo',
    r'([I)[Landroid/os/Debug$MemoryInfo;',
  );

  static final _getProcessMemoryInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.os.Debug$MemoryInfo[] getProcessMemoryInfo(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getProcessMemoryInfo(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _getProcessMemoryInfo(
      reference.pointer,
      _id_getProcessMemoryInfo as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JArray<jni$_.JObject?>?>(
      const jni$_.$JArray$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getProcessesInErrorState = _class.instanceMethodId(
    r'getProcessesInErrorState',
    r'()Ljava/util/List;',
  );

  static final _getProcessesInErrorState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.app.ActivityManager$ProcessErrorStateInfo> getProcessesInErrorState()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<ActivityManager$ProcessErrorStateInfo?>?
  getProcessesInErrorState() {
    return _getProcessesInErrorState(
      reference.pointer,
      _id_getProcessesInErrorState as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<ActivityManager$ProcessErrorStateInfo?>?>(
      const jni$_.$JList$NullableType$<ActivityManager$ProcessErrorStateInfo?>(
        $ActivityManager$ProcessErrorStateInfo$NullableType$(),
      ),
    );
  }

  static final _id_getRecentTasks = _class.instanceMethodId(
    r'getRecentTasks',
    r'(II)Ljava/util/List;',
  );

  static final _getRecentTasks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public java.util.List<android.app.ActivityManager$RecentTaskInfo> getRecentTasks(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<ActivityManager$RecentTaskInfo?>? getRecentTasks(int i, int i1) {
    return _getRecentTasks(
      reference.pointer,
      _id_getRecentTasks as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<jni$_.JList<ActivityManager$RecentTaskInfo?>?>(
      const jni$_.$JList$NullableType$<ActivityManager$RecentTaskInfo?>(
        $ActivityManager$RecentTaskInfo$NullableType$(),
      ),
    );
  }

  static final _id_getRunningAppProcesses = _class.instanceMethodId(
    r'getRunningAppProcesses',
    r'()Ljava/util/List;',
  );

  static final _getRunningAppProcesses =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.app.ActivityManager$RunningAppProcessInfo> getRunningAppProcesses()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<ActivityManager$RunningAppProcessInfo?>?
  getRunningAppProcesses() {
    return _getRunningAppProcesses(
      reference.pointer,
      _id_getRunningAppProcesses as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<ActivityManager$RunningAppProcessInfo?>?>(
      const jni$_.$JList$NullableType$<ActivityManager$RunningAppProcessInfo?>(
        $ActivityManager$RunningAppProcessInfo$NullableType$(),
      ),
    );
  }

  static final _id_getRunningServiceControlPanel = _class.instanceMethodId(
    r'getRunningServiceControlPanel',
    r'(Landroid/content/ComponentName;)Landroid/app/PendingIntent;',
  );

  static final _getRunningServiceControlPanel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.app.PendingIntent getRunningServiceControlPanel(android.content.ComponentName componentName)`
  /// The returned object must be released after use, by calling the [release] method.
  pendingintent$_.PendingIntent? getRunningServiceControlPanel(
    jni$_.JObject? componentName,
  ) {
    final _$componentName = componentName?.reference ?? jni$_.jNullReference;
    return _getRunningServiceControlPanel(
      reference.pointer,
      _id_getRunningServiceControlPanel as jni$_.JMethodIDPtr,
      _$componentName.pointer,
    ).object<pendingintent$_.PendingIntent?>(
      const pendingintent$_.$PendingIntent$NullableType$(),
    );
  }

  static final _id_getRunningServices = _class.instanceMethodId(
    r'getRunningServices',
    r'(I)Ljava/util/List;',
  );

  static final _getRunningServices =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.util.List<android.app.ActivityManager$RunningServiceInfo> getRunningServices(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<ActivityManager$RunningServiceInfo?>? getRunningServices(int i) {
    return _getRunningServices(
      reference.pointer,
      _id_getRunningServices as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JList<ActivityManager$RunningServiceInfo?>?>(
      const jni$_.$JList$NullableType$<ActivityManager$RunningServiceInfo?>(
        $ActivityManager$RunningServiceInfo$NullableType$(),
      ),
    );
  }

  static final _id_getRunningTasks = _class.instanceMethodId(
    r'getRunningTasks',
    r'(I)Ljava/util/List;',
  );

  static final _getRunningTasks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.util.List<android.app.ActivityManager$RunningTaskInfo> getRunningTasks(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<ActivityManager$RunningTaskInfo?>? getRunningTasks(int i) {
    return _getRunningTasks(
      reference.pointer,
      _id_getRunningTasks as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JList<ActivityManager$RunningTaskInfo?>?>(
      const jni$_.$JList$NullableType$<ActivityManager$RunningTaskInfo?>(
        $ActivityManager$RunningTaskInfo$NullableType$(),
      ),
    );
  }

  static final _id_isActivityStartAllowedOnDisplay = _class.instanceMethodId(
    r'isActivityStartAllowedOnDisplay',
    r'(Landroid/content/Context;ILandroid/content/Intent;)Z',
  );

  static final _isActivityStartAllowedOnDisplay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isActivityStartAllowedOnDisplay(android.content.Context context, int i, android.content.Intent intent)`
  bool isActivityStartAllowedOnDisplay(
    context$_.Context context,
    int i,
    intent$_.Intent intent,
  ) {
    final _$context = context.reference;
    final _$intent = intent.reference;
    return _isActivityStartAllowedOnDisplay(
      reference.pointer,
      _id_isActivityStartAllowedOnDisplay as jni$_.JMethodIDPtr,
      _$context.pointer,
      i,
      _$intent.pointer,
    ).boolean;
  }

  static final _id_isBackgroundRestricted = _class.instanceMethodId(
    r'isBackgroundRestricted',
    r'()Z',
  );

  static final _isBackgroundRestricted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBackgroundRestricted()`
  bool isBackgroundRestricted() {
    return _isBackgroundRestricted(
      reference.pointer,
      _id_isBackgroundRestricted as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isInLockTaskMode = _class.instanceMethodId(
    r'isInLockTaskMode',
    r'()Z',
  );

  static final _isInLockTaskMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isInLockTaskMode()`
  bool isInLockTaskMode() {
    return _isInLockTaskMode(
      reference.pointer,
      _id_isInLockTaskMode as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isLowMemoryKillReportSupported = _class.staticMethodId(
    r'isLowMemoryKillReportSupported',
    r'()Z',
  );

  static final _isLowMemoryKillReportSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public boolean isLowMemoryKillReportSupported()`
  static bool isLowMemoryKillReportSupported() {
    return _isLowMemoryKillReportSupported(
      _class.reference.pointer,
      _id_isLowMemoryKillReportSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isLowRamDevice = _class.instanceMethodId(
    r'isLowRamDevice',
    r'()Z',
  );

  static final _isLowRamDevice =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLowRamDevice()`
  bool isLowRamDevice() {
    return _isLowRamDevice(
      reference.pointer,
      _id_isLowRamDevice as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isRunningInTestHarness = _class.staticMethodId(
    r'isRunningInTestHarness',
    r'()Z',
  );

  static final _isRunningInTestHarness =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public boolean isRunningInTestHarness()`
  static bool isRunningInTestHarness() {
    return _isRunningInTestHarness(
      _class.reference.pointer,
      _id_isRunningInTestHarness as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isRunningInUserTestHarness = _class.staticMethodId(
    r'isRunningInUserTestHarness',
    r'()Z',
  );

  static final _isRunningInUserTestHarness =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public boolean isRunningInUserTestHarness()`
  static bool isRunningInUserTestHarness() {
    return _isRunningInUserTestHarness(
      _class.reference.pointer,
      _id_isRunningInUserTestHarness as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isUserAMonkey = _class.staticMethodId(
    r'isUserAMonkey',
    r'()Z',
  );

  static final _isUserAMonkey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public boolean isUserAMonkey()`
  static bool isUserAMonkey() {
    return _isUserAMonkey(
      _class.reference.pointer,
      _id_isUserAMonkey as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_killBackgroundProcesses = _class.instanceMethodId(
    r'killBackgroundProcesses',
    r'(Ljava/lang/String;)V',
  );

  static final _killBackgroundProcesses =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void killBackgroundProcesses(java.lang.String string)`
  void killBackgroundProcesses(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _killBackgroundProcesses(
      reference.pointer,
      _id_killBackgroundProcesses as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_moveTaskToFront = _class.instanceMethodId(
    r'moveTaskToFront',
    r'(II)V',
  );

  static final _moveTaskToFront =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void moveTaskToFront(int i, int i1)`
  void moveTaskToFront(int i, int i1) {
    _moveTaskToFront(
      reference.pointer,
      _id_moveTaskToFront as jni$_.JMethodIDPtr,
      i,
      i1,
    ).check();
  }

  static final _id_moveTaskToFront$1 = _class.instanceMethodId(
    r'moveTaskToFront',
    r'(IILandroid/os/Bundle;)V',
  );

  static final _moveTaskToFront$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void moveTaskToFront(int i, int i1, android.os.Bundle bundle)`
  void moveTaskToFront$1(int i, int i1, jni$_.JObject? bundle) {
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _moveTaskToFront$1(
      reference.pointer,
      _id_moveTaskToFront$1 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$bundle.pointer,
    ).check();
  }

  static final _id_removeApplicationStartInfoCompletionListener = _class
      .instanceMethodId(
        r'removeApplicationStartInfoCompletionListener',
        r'(Ljava/util/function/Consumer;)V',
      );

  static final _removeApplicationStartInfoCompletionListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeApplicationStartInfoCompletionListener(java.util.function.Consumer<android.app.ApplicationStartInfo> consumer)`
  void removeApplicationStartInfoCompletionListener(jni$_.JObject consumer) {
    final _$consumer = consumer.reference;
    _removeApplicationStartInfoCompletionListener(
      reference.pointer,
      _id_removeApplicationStartInfoCompletionListener as jni$_.JMethodIDPtr,
      _$consumer.pointer,
    ).check();
  }

  static final _id_restartPackage = _class.instanceMethodId(
    r'restartPackage',
    r'(Ljava/lang/String;)V',
  );

  static final _restartPackage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void restartPackage(java.lang.String string)`
  void restartPackage(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _restartPackage(
      reference.pointer,
      _id_restartPackage as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_setProcessStateSummary = _class.instanceMethodId(
    r'setProcessStateSummary',
    r'([B)V',
  );

  static final _setProcessStateSummary =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setProcessStateSummary(byte[] bs)`
  void setProcessStateSummary(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _setProcessStateSummary(
      reference.pointer,
      _id_setProcessStateSummary as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_setVrThread = _class.staticMethodId(r'setVrThread', r'(I)V');

  static final _setVrThread =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public void setVrThread(int i)`
  static void setVrThread(int i) {
    _setVrThread(
      _class.reference.pointer,
      _id_setVrThread as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setWatchHeapLimit = _class.instanceMethodId(
    r'setWatchHeapLimit',
    r'(J)V',
  );

  static final _setWatchHeapLimit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setWatchHeapLimit(long j)`
  void setWatchHeapLimit(int j) {
    _setWatchHeapLimit(
      reference.pointer,
      _id_setWatchHeapLimit as jni$_.JMethodIDPtr,
      j,
    ).check();
  }
}

final class $ActivityManager$NullableType$
    extends jni$_.JType<ActivityManager?> {
  @jni$_.internal
  const $ActivityManager$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager;';

  @jni$_.internal
  @core$_.override
  ActivityManager? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ActivityManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$NullableType$) &&
        other is $ActivityManager$NullableType$;
  }
}

final class $ActivityManager$Type$ extends jni$_.JType<ActivityManager> {
  @jni$_.internal
  const $ActivityManager$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/app/ActivityManager;';

  @jni$_.internal
  @core$_.override
  ActivityManager fromReference(jni$_.JReference reference) =>
      ActivityManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ActivityManager?> get nullableType =>
      const $ActivityManager$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityManager$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityManager$Type$) &&
        other is $ActivityManager$Type$;
  }
}
