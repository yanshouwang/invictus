// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../../java/io/InputStream.dart' as inputstream$_;

import '../../../java/io/OutputStream.dart' as outputstream$_;

import '../../../java/util/HashMap.dart' as hashmap$_;

import '../../app/PendingIntent.dart' as pendingintent$_;

import '../../os/ParcelFileDescriptor.dart' as parcelfiledescriptor$_;

import 'UsbAccessory.dart' as usbaccessory$_;

import 'UsbDevice.dart' as usbdevice$_;

import 'UsbDeviceConnection.dart' as usbdeviceconnection$_;

/// from: `android.hardware.usb.UsbManager`
class UsbManager extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UsbManager> $type;

  @jni$_.internal
  UsbManager.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/hardware/usb/UsbManager',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UsbManager?> nullableType =
      $UsbManager$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UsbManager> type = $UsbManager$Type$();
  static final _id_ACTION_USB_ACCESSORY_ATTACHED = _class.staticFieldId(
    r'ACTION_USB_ACCESSORY_ATTACHED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_USB_ACCESSORY_ATTACHED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_USB_ACCESSORY_ATTACHED =>
      _id_ACTION_USB_ACCESSORY_ATTACHED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_ACTION_USB_ACCESSORY_DETACHED = _class.staticFieldId(
    r'ACTION_USB_ACCESSORY_DETACHED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_USB_ACCESSORY_DETACHED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_USB_ACCESSORY_DETACHED =>
      _id_ACTION_USB_ACCESSORY_DETACHED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_ACTION_USB_DEVICE_ATTACHED = _class.staticFieldId(
    r'ACTION_USB_DEVICE_ATTACHED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_USB_DEVICE_ATTACHED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_USB_DEVICE_ATTACHED =>
      _id_ACTION_USB_DEVICE_ATTACHED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_ACTION_USB_DEVICE_DETACHED = _class.staticFieldId(
    r'ACTION_USB_DEVICE_DETACHED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_USB_DEVICE_DETACHED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_USB_DEVICE_DETACHED =>
      _id_ACTION_USB_DEVICE_DETACHED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_EXTRA_ACCESSORY = _class.staticFieldId(
    r'EXTRA_ACCESSORY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_ACCESSORY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_ACCESSORY =>
      _id_EXTRA_ACCESSORY.get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_DEVICE = _class.staticFieldId(
    r'EXTRA_DEVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_DEVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_DEVICE =>
      _id_EXTRA_DEVICE.get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_PERMISSION_GRANTED = _class.staticFieldId(
    r'EXTRA_PERMISSION_GRANTED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_PERMISSION_GRANTED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_PERMISSION_GRANTED =>
      _id_EXTRA_PERMISSION_GRANTED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_getAccessoryList = _class.instanceMethodId(
    r'getAccessoryList',
    r'()[Landroid/hardware/usb/UsbAccessory;',
  );

  static final _getAccessoryList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.hardware.usb.UsbAccessory[] getAccessoryList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<usbaccessory$_.UsbAccessory?>? getAccessoryList() {
    return _getAccessoryList(
      reference.pointer,
      _id_getAccessoryList as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<usbaccessory$_.UsbAccessory?>?>(
      const jni$_.$JArray$NullableType$<usbaccessory$_.UsbAccessory?>(
        usbaccessory$_.$UsbAccessory$NullableType$(),
      ),
    );
  }

  static final _id_getDeviceList = _class.instanceMethodId(
    r'getDeviceList',
    r'()Ljava/util/HashMap;',
  );

  static final _getDeviceList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.HashMap<java.lang.String, android.hardware.usb.UsbDevice> getDeviceList()`
  /// The returned object must be released after use, by calling the [release] method.
  hashmap$_.HashMap<jni$_.JString?, usbdevice$_.UsbDevice?>? getDeviceList() {
    return _getDeviceList(
      reference.pointer,
      _id_getDeviceList as jni$_.JMethodIDPtr,
    ).object<hashmap$_.HashMap<jni$_.JString?, usbdevice$_.UsbDevice?>?>(
      const hashmap$_.$HashMap$NullableType$<
        jni$_.JString?,
        usbdevice$_.UsbDevice?
      >(jni$_.$JString$NullableType$(), usbdevice$_.$UsbDevice$NullableType$()),
    );
  }

  static final _id_hasPermission = _class.instanceMethodId(
    r'hasPermission',
    r'(Landroid/hardware/usb/UsbAccessory;)Z',
  );

  static final _hasPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean hasPermission(android.hardware.usb.UsbAccessory usbAccessory)`
  bool hasPermission(usbaccessory$_.UsbAccessory? usbAccessory) {
    final _$usbAccessory = usbAccessory?.reference ?? jni$_.jNullReference;
    return _hasPermission(
      reference.pointer,
      _id_hasPermission as jni$_.JMethodIDPtr,
      _$usbAccessory.pointer,
    ).boolean;
  }

  static final _id_hasPermission$1 = _class.instanceMethodId(
    r'hasPermission',
    r'(Landroid/hardware/usb/UsbDevice;)Z',
  );

  static final _hasPermission$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean hasPermission(android.hardware.usb.UsbDevice usbDevice)`
  bool hasPermission$1(usbdevice$_.UsbDevice? usbDevice) {
    final _$usbDevice = usbDevice?.reference ?? jni$_.jNullReference;
    return _hasPermission$1(
      reference.pointer,
      _id_hasPermission$1 as jni$_.JMethodIDPtr,
      _$usbDevice.pointer,
    ).boolean;
  }

  static final _id_openAccessory = _class.instanceMethodId(
    r'openAccessory',
    r'(Landroid/hardware/usb/UsbAccessory;)Landroid/os/ParcelFileDescriptor;',
  );

  static final _openAccessory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.os.ParcelFileDescriptor openAccessory(android.hardware.usb.UsbAccessory usbAccessory)`
  /// The returned object must be released after use, by calling the [release] method.
  parcelfiledescriptor$_.ParcelFileDescriptor? openAccessory(
    usbaccessory$_.UsbAccessory? usbAccessory,
  ) {
    final _$usbAccessory = usbAccessory?.reference ?? jni$_.jNullReference;
    return _openAccessory(
      reference.pointer,
      _id_openAccessory as jni$_.JMethodIDPtr,
      _$usbAccessory.pointer,
    ).object<parcelfiledescriptor$_.ParcelFileDescriptor?>(
      const parcelfiledescriptor$_.$ParcelFileDescriptor$NullableType$(),
    );
  }

  static final _id_openAccessoryInputStream = _class.instanceMethodId(
    r'openAccessoryInputStream',
    r'(Landroid/hardware/usb/UsbAccessory;)Ljava/io/InputStream;',
  );

  static final _openAccessoryInputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.InputStream openAccessoryInputStream(android.hardware.usb.UsbAccessory usbAccessory)`
  /// The returned object must be released after use, by calling the [release] method.
  inputstream$_.InputStream openAccessoryInputStream(
    usbaccessory$_.UsbAccessory usbAccessory,
  ) {
    final _$usbAccessory = usbAccessory.reference;
    return _openAccessoryInputStream(
      reference.pointer,
      _id_openAccessoryInputStream as jni$_.JMethodIDPtr,
      _$usbAccessory.pointer,
    ).object<inputstream$_.InputStream>(
      const inputstream$_.$InputStream$Type$(),
    );
  }

  static final _id_openAccessoryOutputStream = _class.instanceMethodId(
    r'openAccessoryOutputStream',
    r'(Landroid/hardware/usb/UsbAccessory;)Ljava/io/OutputStream;',
  );

  static final _openAccessoryOutputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.OutputStream openAccessoryOutputStream(android.hardware.usb.UsbAccessory usbAccessory)`
  /// The returned object must be released after use, by calling the [release] method.
  outputstream$_.OutputStream openAccessoryOutputStream(
    usbaccessory$_.UsbAccessory usbAccessory,
  ) {
    final _$usbAccessory = usbAccessory.reference;
    return _openAccessoryOutputStream(
      reference.pointer,
      _id_openAccessoryOutputStream as jni$_.JMethodIDPtr,
      _$usbAccessory.pointer,
    ).object<outputstream$_.OutputStream>(
      const outputstream$_.$OutputStream$Type$(),
    );
  }

  static final _id_openDevice = _class.instanceMethodId(
    r'openDevice',
    r'(Landroid/hardware/usb/UsbDevice;)Landroid/hardware/usb/UsbDeviceConnection;',
  );

  static final _openDevice =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.hardware.usb.UsbDeviceConnection openDevice(android.hardware.usb.UsbDevice usbDevice)`
  /// The returned object must be released after use, by calling the [release] method.
  usbdeviceconnection$_.UsbDeviceConnection? openDevice(
    usbdevice$_.UsbDevice? usbDevice,
  ) {
    final _$usbDevice = usbDevice?.reference ?? jni$_.jNullReference;
    return _openDevice(
      reference.pointer,
      _id_openDevice as jni$_.JMethodIDPtr,
      _$usbDevice.pointer,
    ).object<usbdeviceconnection$_.UsbDeviceConnection?>(
      const usbdeviceconnection$_.$UsbDeviceConnection$NullableType$(),
    );
  }

  static final _id_requestPermission = _class.instanceMethodId(
    r'requestPermission',
    r'(Landroid/hardware/usb/UsbAccessory;Landroid/app/PendingIntent;)V',
  );

  static final _requestPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void requestPermission(android.hardware.usb.UsbAccessory usbAccessory, android.app.PendingIntent pendingIntent)`
  void requestPermission(
    usbaccessory$_.UsbAccessory? usbAccessory,
    pendingintent$_.PendingIntent? pendingIntent,
  ) {
    final _$usbAccessory = usbAccessory?.reference ?? jni$_.jNullReference;
    final _$pendingIntent = pendingIntent?.reference ?? jni$_.jNullReference;
    _requestPermission(
      reference.pointer,
      _id_requestPermission as jni$_.JMethodIDPtr,
      _$usbAccessory.pointer,
      _$pendingIntent.pointer,
    ).check();
  }

  static final _id_requestPermission$1 = _class.instanceMethodId(
    r'requestPermission',
    r'(Landroid/hardware/usb/UsbDevice;Landroid/app/PendingIntent;)V',
  );

  static final _requestPermission$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void requestPermission(android.hardware.usb.UsbDevice usbDevice, android.app.PendingIntent pendingIntent)`
  void requestPermission$1(
    usbdevice$_.UsbDevice? usbDevice,
    pendingintent$_.PendingIntent? pendingIntent,
  ) {
    final _$usbDevice = usbDevice?.reference ?? jni$_.jNullReference;
    final _$pendingIntent = pendingIntent?.reference ?? jni$_.jNullReference;
    _requestPermission$1(
      reference.pointer,
      _id_requestPermission$1 as jni$_.JMethodIDPtr,
      _$usbDevice.pointer,
      _$pendingIntent.pointer,
    ).check();
  }
}

final class $UsbManager$NullableType$ extends jni$_.JType<UsbManager?> {
  @jni$_.internal
  const $UsbManager$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/hardware/usb/UsbManager;';

  @jni$_.internal
  @core$_.override
  UsbManager? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : UsbManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UsbManager?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UsbManager$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UsbManager$NullableType$) &&
        other is $UsbManager$NullableType$;
  }
}

final class $UsbManager$Type$ extends jni$_.JType<UsbManager> {
  @jni$_.internal
  const $UsbManager$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/hardware/usb/UsbManager;';

  @jni$_.internal
  @core$_.override
  UsbManager fromReference(jni$_.JReference reference) =>
      UsbManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UsbManager?> get nullableType =>
      const $UsbManager$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UsbManager$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UsbManager$Type$) &&
        other is $UsbManager$Type$;
  }
}
