// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../java/io/FileDescriptor.dart' as filedescriptor$_;

import '../../java/net/DatagramSocket.dart' as datagramsocket$_;

import '../../java/net/InetAddress.dart' as inetaddress$_;

import '../../java/net/Socket.dart' as socket$_;

/// from: `android.net.IpSecManager$ResourceUnavailableException`
class IpSecManager$ResourceUnavailableException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpSecManager$ResourceUnavailableException> $type;

  @jni$_.internal
  IpSecManager$ResourceUnavailableException.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/IpSecManager$ResourceUnavailableException',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager$ResourceUnavailableException?>
  nullableType = $IpSecManager$ResourceUnavailableException$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager$ResourceUnavailableException> type =
      $IpSecManager$ResourceUnavailableException$Type$();
}

final class $IpSecManager$ResourceUnavailableException$NullableType$
    extends jni$_.JType<IpSecManager$ResourceUnavailableException?> {
  @jni$_.internal
  const $IpSecManager$ResourceUnavailableException$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/IpSecManager$ResourceUnavailableException;';

  @jni$_.internal
  @core$_.override
  IpSecManager$ResourceUnavailableException? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : IpSecManager$ResourceUnavailableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager$ResourceUnavailableException?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($IpSecManager$ResourceUnavailableException$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($IpSecManager$ResourceUnavailableException$NullableType$) &&
        other is $IpSecManager$ResourceUnavailableException$NullableType$;
  }
}

final class $IpSecManager$ResourceUnavailableException$Type$
    extends jni$_.JType<IpSecManager$ResourceUnavailableException> {
  @jni$_.internal
  const $IpSecManager$ResourceUnavailableException$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/IpSecManager$ResourceUnavailableException;';

  @jni$_.internal
  @core$_.override
  IpSecManager$ResourceUnavailableException fromReference(
    jni$_.JReference reference,
  ) => IpSecManager$ResourceUnavailableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager$ResourceUnavailableException?> get nullableType =>
      const $IpSecManager$ResourceUnavailableException$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($IpSecManager$ResourceUnavailableException$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($IpSecManager$ResourceUnavailableException$Type$) &&
        other is $IpSecManager$ResourceUnavailableException$Type$;
  }
}

/// from: `android.net.IpSecManager$SecurityParameterIndex`
class IpSecManager$SecurityParameterIndex extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpSecManager$SecurityParameterIndex> $type;

  @jni$_.internal
  IpSecManager$SecurityParameterIndex.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/IpSecManager$SecurityParameterIndex',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager$SecurityParameterIndex?> nullableType =
      $IpSecManager$SecurityParameterIndex$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager$SecurityParameterIndex> type =
      $IpSecManager$SecurityParameterIndex$Type$();
  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_getSpi = _class.instanceMethodId(r'getSpi', r'()I');

  static final _getSpi =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSpi()`
  int getSpi() {
    return _getSpi(reference.pointer, _id_getSpi as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $IpSecManager$SecurityParameterIndex$NullableType$
    extends jni$_.JType<IpSecManager$SecurityParameterIndex?> {
  @jni$_.internal
  const $IpSecManager$SecurityParameterIndex$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/IpSecManager$SecurityParameterIndex;';

  @jni$_.internal
  @core$_.override
  IpSecManager$SecurityParameterIndex? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : IpSecManager$SecurityParameterIndex.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager$SecurityParameterIndex?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($IpSecManager$SecurityParameterIndex$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($IpSecManager$SecurityParameterIndex$NullableType$) &&
        other is $IpSecManager$SecurityParameterIndex$NullableType$;
  }
}

final class $IpSecManager$SecurityParameterIndex$Type$
    extends jni$_.JType<IpSecManager$SecurityParameterIndex> {
  @jni$_.internal
  const $IpSecManager$SecurityParameterIndex$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/IpSecManager$SecurityParameterIndex;';

  @jni$_.internal
  @core$_.override
  IpSecManager$SecurityParameterIndex fromReference(
    jni$_.JReference reference,
  ) => IpSecManager$SecurityParameterIndex.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager$SecurityParameterIndex?> get nullableType =>
      const $IpSecManager$SecurityParameterIndex$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpSecManager$SecurityParameterIndex$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpSecManager$SecurityParameterIndex$Type$) &&
        other is $IpSecManager$SecurityParameterIndex$Type$;
  }
}

/// from: `android.net.IpSecManager$SpiUnavailableException`
class IpSecManager$SpiUnavailableException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpSecManager$SpiUnavailableException> $type;

  @jni$_.internal
  IpSecManager$SpiUnavailableException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/IpSecManager$SpiUnavailableException',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager$SpiUnavailableException?> nullableType =
      $IpSecManager$SpiUnavailableException$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager$SpiUnavailableException> type =
      $IpSecManager$SpiUnavailableException$Type$();
  static final _id_getSpi = _class.instanceMethodId(r'getSpi', r'()I');

  static final _getSpi =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSpi()`
  int getSpi() {
    return _getSpi(reference.pointer, _id_getSpi as jni$_.JMethodIDPtr).integer;
  }
}

final class $IpSecManager$SpiUnavailableException$NullableType$
    extends jni$_.JType<IpSecManager$SpiUnavailableException?> {
  @jni$_.internal
  const $IpSecManager$SpiUnavailableException$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/IpSecManager$SpiUnavailableException;';

  @jni$_.internal
  @core$_.override
  IpSecManager$SpiUnavailableException? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : IpSecManager$SpiUnavailableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager$SpiUnavailableException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($IpSecManager$SpiUnavailableException$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($IpSecManager$SpiUnavailableException$NullableType$) &&
        other is $IpSecManager$SpiUnavailableException$NullableType$;
  }
}

final class $IpSecManager$SpiUnavailableException$Type$
    extends jni$_.JType<IpSecManager$SpiUnavailableException> {
  @jni$_.internal
  const $IpSecManager$SpiUnavailableException$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/IpSecManager$SpiUnavailableException;';

  @jni$_.internal
  @core$_.override
  IpSecManager$SpiUnavailableException fromReference(
    jni$_.JReference reference,
  ) => IpSecManager$SpiUnavailableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager$SpiUnavailableException?> get nullableType =>
      const $IpSecManager$SpiUnavailableException$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpSecManager$SpiUnavailableException$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpSecManager$SpiUnavailableException$Type$) &&
        other is $IpSecManager$SpiUnavailableException$Type$;
  }
}

/// from: `android.net.IpSecManager$UdpEncapsulationSocket`
class IpSecManager$UdpEncapsulationSocket extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpSecManager$UdpEncapsulationSocket> $type;

  @jni$_.internal
  IpSecManager$UdpEncapsulationSocket.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/IpSecManager$UdpEncapsulationSocket',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager$UdpEncapsulationSocket?> nullableType =
      $IpSecManager$UdpEncapsulationSocket$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager$UdpEncapsulationSocket> type =
      $IpSecManager$UdpEncapsulationSocket$Type$();
  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_getFileDescriptor = _class.instanceMethodId(
    r'getFileDescriptor',
    r'()Ljava/io/FileDescriptor;',
  );

  static final _getFileDescriptor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.FileDescriptor getFileDescriptor()`
  /// The returned object must be released after use, by calling the [release] method.
  filedescriptor$_.FileDescriptor? getFileDescriptor() {
    return _getFileDescriptor(
      reference.pointer,
      _id_getFileDescriptor as jni$_.JMethodIDPtr,
    ).object<filedescriptor$_.FileDescriptor?>(
      const filedescriptor$_.$FileDescriptor$NullableType$(),
    );
  }

  static final _id_getPort = _class.instanceMethodId(r'getPort', r'()I');

  static final _getPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPort()`
  int getPort() {
    return _getPort(
      reference.pointer,
      _id_getPort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $IpSecManager$UdpEncapsulationSocket$NullableType$
    extends jni$_.JType<IpSecManager$UdpEncapsulationSocket?> {
  @jni$_.internal
  const $IpSecManager$UdpEncapsulationSocket$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/IpSecManager$UdpEncapsulationSocket;';

  @jni$_.internal
  @core$_.override
  IpSecManager$UdpEncapsulationSocket? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : IpSecManager$UdpEncapsulationSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager$UdpEncapsulationSocket?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($IpSecManager$UdpEncapsulationSocket$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($IpSecManager$UdpEncapsulationSocket$NullableType$) &&
        other is $IpSecManager$UdpEncapsulationSocket$NullableType$;
  }
}

final class $IpSecManager$UdpEncapsulationSocket$Type$
    extends jni$_.JType<IpSecManager$UdpEncapsulationSocket> {
  @jni$_.internal
  const $IpSecManager$UdpEncapsulationSocket$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/IpSecManager$UdpEncapsulationSocket;';

  @jni$_.internal
  @core$_.override
  IpSecManager$UdpEncapsulationSocket fromReference(
    jni$_.JReference reference,
  ) => IpSecManager$UdpEncapsulationSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager$UdpEncapsulationSocket?> get nullableType =>
      const $IpSecManager$UdpEncapsulationSocket$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpSecManager$UdpEncapsulationSocket$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpSecManager$UdpEncapsulationSocket$Type$) &&
        other is $IpSecManager$UdpEncapsulationSocket$Type$;
  }
}

/// from: `android.net.IpSecManager`
class IpSecManager extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpSecManager> $type;

  @jni$_.internal
  IpSecManager.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/net/IpSecManager');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager?> nullableType =
      $IpSecManager$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpSecManager> type = $IpSecManager$Type$();

  /// from: `static public final int DIRECTION_IN`
  static const DIRECTION_IN = 0;

  /// from: `static public final int DIRECTION_OUT`
  static const DIRECTION_OUT = 1;
  static final _id_allocateSecurityParameterIndex = _class.instanceMethodId(
    r'allocateSecurityParameterIndex',
    r'(Ljava/net/InetAddress;)Landroid/net/IpSecManager$SecurityParameterIndex;',
  );

  static final _allocateSecurityParameterIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.net.IpSecManager$SecurityParameterIndex allocateSecurityParameterIndex(java.net.InetAddress inetAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  IpSecManager$SecurityParameterIndex allocateSecurityParameterIndex(
    inetaddress$_.InetAddress inetAddress,
  ) {
    final _$inetAddress = inetAddress.reference;
    return _allocateSecurityParameterIndex(
      reference.pointer,
      _id_allocateSecurityParameterIndex as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
    ).object<IpSecManager$SecurityParameterIndex>(
      const $IpSecManager$SecurityParameterIndex$Type$(),
    );
  }

  static final _id_allocateSecurityParameterIndex$1 = _class.instanceMethodId(
    r'allocateSecurityParameterIndex',
    r'(Ljava/net/InetAddress;I)Landroid/net/IpSecManager$SecurityParameterIndex;',
  );

  static final _allocateSecurityParameterIndex$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public android.net.IpSecManager$SecurityParameterIndex allocateSecurityParameterIndex(java.net.InetAddress inetAddress, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  IpSecManager$SecurityParameterIndex allocateSecurityParameterIndex$1(
    inetaddress$_.InetAddress inetAddress,
    int i,
  ) {
    final _$inetAddress = inetAddress.reference;
    return _allocateSecurityParameterIndex$1(
      reference.pointer,
      _id_allocateSecurityParameterIndex$1 as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
      i,
    ).object<IpSecManager$SecurityParameterIndex>(
      const $IpSecManager$SecurityParameterIndex$Type$(),
    );
  }

  static final _id_applyTransportModeTransform = _class.instanceMethodId(
    r'applyTransportModeTransform',
    r'(Ljava/io/FileDescriptor;ILandroid/net/IpSecTransform;)V',
  );

  static final _applyTransportModeTransform =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void applyTransportModeTransform(java.io.FileDescriptor fileDescriptor, int i, android.net.IpSecTransform ipSecTransform)`
  void applyTransportModeTransform(
    filedescriptor$_.FileDescriptor fileDescriptor,
    int i,
    jni$_.JObject ipSecTransform,
  ) {
    final _$fileDescriptor = fileDescriptor.reference;
    final _$ipSecTransform = ipSecTransform.reference;
    _applyTransportModeTransform(
      reference.pointer,
      _id_applyTransportModeTransform as jni$_.JMethodIDPtr,
      _$fileDescriptor.pointer,
      i,
      _$ipSecTransform.pointer,
    ).check();
  }

  static final _id_applyTransportModeTransform$1 = _class.instanceMethodId(
    r'applyTransportModeTransform',
    r'(Ljava/net/DatagramSocket;ILandroid/net/IpSecTransform;)V',
  );

  static final _applyTransportModeTransform$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void applyTransportModeTransform(java.net.DatagramSocket datagramSocket, int i, android.net.IpSecTransform ipSecTransform)`
  void applyTransportModeTransform$1(
    datagramsocket$_.DatagramSocket datagramSocket,
    int i,
    jni$_.JObject ipSecTransform,
  ) {
    final _$datagramSocket = datagramSocket.reference;
    final _$ipSecTransform = ipSecTransform.reference;
    _applyTransportModeTransform$1(
      reference.pointer,
      _id_applyTransportModeTransform$1 as jni$_.JMethodIDPtr,
      _$datagramSocket.pointer,
      i,
      _$ipSecTransform.pointer,
    ).check();
  }

  static final _id_applyTransportModeTransform$2 = _class.instanceMethodId(
    r'applyTransportModeTransform',
    r'(Ljava/net/Socket;ILandroid/net/IpSecTransform;)V',
  );

  static final _applyTransportModeTransform$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void applyTransportModeTransform(java.net.Socket socket, int i, android.net.IpSecTransform ipSecTransform)`
  void applyTransportModeTransform$2(
    socket$_.Socket socket,
    int i,
    jni$_.JObject ipSecTransform,
  ) {
    final _$socket = socket.reference;
    final _$ipSecTransform = ipSecTransform.reference;
    _applyTransportModeTransform$2(
      reference.pointer,
      _id_applyTransportModeTransform$2 as jni$_.JMethodIDPtr,
      _$socket.pointer,
      i,
      _$ipSecTransform.pointer,
    ).check();
  }

  static final _id_openUdpEncapsulationSocket = _class.instanceMethodId(
    r'openUdpEncapsulationSocket',
    r'()Landroid/net/IpSecManager$UdpEncapsulationSocket;',
  );

  static final _openUdpEncapsulationSocket =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.IpSecManager$UdpEncapsulationSocket openUdpEncapsulationSocket()`
  /// The returned object must be released after use, by calling the [release] method.
  IpSecManager$UdpEncapsulationSocket openUdpEncapsulationSocket() {
    return _openUdpEncapsulationSocket(
      reference.pointer,
      _id_openUdpEncapsulationSocket as jni$_.JMethodIDPtr,
    ).object<IpSecManager$UdpEncapsulationSocket>(
      const $IpSecManager$UdpEncapsulationSocket$Type$(),
    );
  }

  static final _id_openUdpEncapsulationSocket$1 = _class.instanceMethodId(
    r'openUdpEncapsulationSocket',
    r'(I)Landroid/net/IpSecManager$UdpEncapsulationSocket;',
  );

  static final _openUdpEncapsulationSocket$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public android.net.IpSecManager$UdpEncapsulationSocket openUdpEncapsulationSocket(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  IpSecManager$UdpEncapsulationSocket openUdpEncapsulationSocket$1(int i) {
    return _openUdpEncapsulationSocket$1(
      reference.pointer,
      _id_openUdpEncapsulationSocket$1 as jni$_.JMethodIDPtr,
      i,
    ).object<IpSecManager$UdpEncapsulationSocket>(
      const $IpSecManager$UdpEncapsulationSocket$Type$(),
    );
  }

  static final _id_removeTransportModeTransforms = _class.instanceMethodId(
    r'removeTransportModeTransforms',
    r'(Ljava/io/FileDescriptor;)V',
  );

  static final _removeTransportModeTransforms =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeTransportModeTransforms(java.io.FileDescriptor fileDescriptor)`
  void removeTransportModeTransforms(
    filedescriptor$_.FileDescriptor fileDescriptor,
  ) {
    final _$fileDescriptor = fileDescriptor.reference;
    _removeTransportModeTransforms(
      reference.pointer,
      _id_removeTransportModeTransforms as jni$_.JMethodIDPtr,
      _$fileDescriptor.pointer,
    ).check();
  }

  static final _id_removeTransportModeTransforms$1 = _class.instanceMethodId(
    r'removeTransportModeTransforms',
    r'(Ljava/net/DatagramSocket;)V',
  );

  static final _removeTransportModeTransforms$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeTransportModeTransforms(java.net.DatagramSocket datagramSocket)`
  void removeTransportModeTransforms$1(
    datagramsocket$_.DatagramSocket datagramSocket,
  ) {
    final _$datagramSocket = datagramSocket.reference;
    _removeTransportModeTransforms$1(
      reference.pointer,
      _id_removeTransportModeTransforms$1 as jni$_.JMethodIDPtr,
      _$datagramSocket.pointer,
    ).check();
  }

  static final _id_removeTransportModeTransforms$2 = _class.instanceMethodId(
    r'removeTransportModeTransforms',
    r'(Ljava/net/Socket;)V',
  );

  static final _removeTransportModeTransforms$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeTransportModeTransforms(java.net.Socket socket)`
  void removeTransportModeTransforms$2(socket$_.Socket socket) {
    final _$socket = socket.reference;
    _removeTransportModeTransforms$2(
      reference.pointer,
      _id_removeTransportModeTransforms$2 as jni$_.JMethodIDPtr,
      _$socket.pointer,
    ).check();
  }
}

final class $IpSecManager$NullableType$ extends jni$_.JType<IpSecManager?> {
  @jni$_.internal
  const $IpSecManager$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/IpSecManager;';

  @jni$_.internal
  @core$_.override
  IpSecManager? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : IpSecManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpSecManager$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpSecManager$NullableType$) &&
        other is $IpSecManager$NullableType$;
  }
}

final class $IpSecManager$Type$ extends jni$_.JType<IpSecManager> {
  @jni$_.internal
  const $IpSecManager$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/IpSecManager;';

  @jni$_.internal
  @core$_.override
  IpSecManager fromReference(jni$_.JReference reference) =>
      IpSecManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpSecManager?> get nullableType =>
      const $IpSecManager$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpSecManager$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpSecManager$Type$) &&
        other is $IpSecManager$Type$;
  }
}
