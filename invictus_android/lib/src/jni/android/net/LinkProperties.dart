// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../java/net/Inet4Address.dart' as inet4address$_;

import '../../java/net/InetAddress.dart' as inetaddress$_;

import '../../java/util/Collection.dart' as collection$_;

import 'IpPrefix.dart' as ipprefix$_;

import 'LinkAddress.dart' as linkaddress$_;

import 'ProxyInfo.dart' as proxyinfo$_;

import 'RouteInfo.dart' as routeinfo$_;

/// from: `android.net.LinkProperties`
class LinkProperties extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<LinkProperties> $type;

  @jni$_.internal
  LinkProperties.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/net/LinkProperties');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<LinkProperties?> nullableType =
      $LinkProperties$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<LinkProperties> type = $LinkProperties$Type$();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.net.LinkProperties> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$Type$());

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory LinkProperties() {
    return LinkProperties.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_addRoute = _class.instanceMethodId(
    r'addRoute',
    r'(Landroid/net/RouteInfo;)Z',
  );

  static final _addRoute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean addRoute(android.net.RouteInfo routeInfo)`
  bool addRoute(routeinfo$_.RouteInfo routeInfo) {
    final _$routeInfo = routeInfo.reference;
    return _addRoute(
      reference.pointer,
      _id_addRoute as jni$_.JMethodIDPtr,
      _$routeInfo.pointer,
    ).boolean;
  }

  static final _id_clear = _class.instanceMethodId(r'clear', r'()V');

  static final _clear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_getDhcpServerAddress = _class.instanceMethodId(
    r'getDhcpServerAddress',
    r'()Ljava/net/Inet4Address;',
  );

  static final _getDhcpServerAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.Inet4Address getDhcpServerAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  inet4address$_.Inet4Address? getDhcpServerAddress() {
    return _getDhcpServerAddress(
      reference.pointer,
      _id_getDhcpServerAddress as jni$_.JMethodIDPtr,
    ).object<inet4address$_.Inet4Address?>(
      const inet4address$_.$Inet4Address$NullableType$(),
    );
  }

  static final _id_getDnsServers = _class.instanceMethodId(
    r'getDnsServers',
    r'()Ljava/util/List;',
  );

  static final _getDnsServers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<java.net.InetAddress> getDnsServers()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<inetaddress$_.InetAddress?> getDnsServers() {
    return _getDnsServers(
      reference.pointer,
      _id_getDnsServers as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<inetaddress$_.InetAddress?>>(
      const jni$_.$JList$Type$<inetaddress$_.InetAddress?>(
        inetaddress$_.$InetAddress$NullableType$(),
      ),
    );
  }

  static final _id_getDomains = _class.instanceMethodId(
    r'getDomains',
    r'()Ljava/lang/String;',
  );

  static final _getDomains =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDomains()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDomains() {
    return _getDomains(
      reference.pointer,
      _id_getDomains as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getHttpProxy = _class.instanceMethodId(
    r'getHttpProxy',
    r'()Landroid/net/ProxyInfo;',
  );

  static final _getHttpProxy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.ProxyInfo getHttpProxy()`
  /// The returned object must be released after use, by calling the [release] method.
  proxyinfo$_.ProxyInfo? getHttpProxy() {
    return _getHttpProxy(
      reference.pointer,
      _id_getHttpProxy as jni$_.JMethodIDPtr,
    ).object<proxyinfo$_.ProxyInfo?>(
      const proxyinfo$_.$ProxyInfo$NullableType$(),
    );
  }

  static final _id_getInterfaceName = _class.instanceMethodId(
    r'getInterfaceName',
    r'()Ljava/lang/String;',
  );

  static final _getInterfaceName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getInterfaceName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getInterfaceName() {
    return _getInterfaceName(
      reference.pointer,
      _id_getInterfaceName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getLinkAddresses = _class.instanceMethodId(
    r'getLinkAddresses',
    r'()Ljava/util/List;',
  );

  static final _getLinkAddresses =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.net.LinkAddress> getLinkAddresses()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<linkaddress$_.LinkAddress?> getLinkAddresses() {
    return _getLinkAddresses(
      reference.pointer,
      _id_getLinkAddresses as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<linkaddress$_.LinkAddress?>>(
      const jni$_.$JList$Type$<linkaddress$_.LinkAddress?>(
        linkaddress$_.$LinkAddress$NullableType$(),
      ),
    );
  }

  static final _id_getMtu = _class.instanceMethodId(r'getMtu', r'()I');

  static final _getMtu =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMtu()`
  int getMtu() {
    return _getMtu(reference.pointer, _id_getMtu as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getNat64Prefix = _class.instanceMethodId(
    r'getNat64Prefix',
    r'()Landroid/net/IpPrefix;',
  );

  static final _getNat64Prefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.IpPrefix getNat64Prefix()`
  /// The returned object must be released after use, by calling the [release] method.
  ipprefix$_.IpPrefix? getNat64Prefix() {
    return _getNat64Prefix(
      reference.pointer,
      _id_getNat64Prefix as jni$_.JMethodIDPtr,
    ).object<ipprefix$_.IpPrefix?>(const ipprefix$_.$IpPrefix$NullableType$());
  }

  static final _id_getPrivateDnsServerName = _class.instanceMethodId(
    r'getPrivateDnsServerName',
    r'()Ljava/lang/String;',
  );

  static final _getPrivateDnsServerName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPrivateDnsServerName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPrivateDnsServerName() {
    return _getPrivateDnsServerName(
      reference.pointer,
      _id_getPrivateDnsServerName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getRoutes = _class.instanceMethodId(
    r'getRoutes',
    r'()Ljava/util/List;',
  );

  static final _getRoutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.net.RouteInfo> getRoutes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<routeinfo$_.RouteInfo?> getRoutes() {
    return _getRoutes(
      reference.pointer,
      _id_getRoutes as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<routeinfo$_.RouteInfo?>>(
      const jni$_.$JList$Type$<routeinfo$_.RouteInfo?>(
        routeinfo$_.$RouteInfo$NullableType$(),
      ),
    );
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isPrivateDnsActive = _class.instanceMethodId(
    r'isPrivateDnsActive',
    r'()Z',
  );

  static final _isPrivateDnsActive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPrivateDnsActive()`
  bool isPrivateDnsActive() {
    return _isPrivateDnsActive(
      reference.pointer,
      _id_isPrivateDnsActive as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWakeOnLanSupported = _class.instanceMethodId(
    r'isWakeOnLanSupported',
    r'()Z',
  );

  static final _isWakeOnLanSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWakeOnLanSupported()`
  bool isWakeOnLanSupported() {
    return _isWakeOnLanSupported(
      reference.pointer,
      _id_isWakeOnLanSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setDhcpServerAddress = _class.instanceMethodId(
    r'setDhcpServerAddress',
    r'(Ljava/net/Inet4Address;)V',
  );

  static final _setDhcpServerAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDhcpServerAddress(java.net.Inet4Address inet4Address)`
  void setDhcpServerAddress(inet4address$_.Inet4Address? inet4Address) {
    final _$inet4Address = inet4Address?.reference ?? jni$_.jNullReference;
    _setDhcpServerAddress(
      reference.pointer,
      _id_setDhcpServerAddress as jni$_.JMethodIDPtr,
      _$inet4Address.pointer,
    ).check();
  }

  static final _id_setDnsServers = _class.instanceMethodId(
    r'setDnsServers',
    r'(Ljava/util/Collection;)V',
  );

  static final _setDnsServers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDnsServers(java.util.Collection<java.net.InetAddress> collection)`
  void setDnsServers(
    collection$_.Collection<inetaddress$_.InetAddress?> collection,
  ) {
    final _$collection = collection.reference;
    _setDnsServers(
      reference.pointer,
      _id_setDnsServers as jni$_.JMethodIDPtr,
      _$collection.pointer,
    ).check();
  }

  static final _id_setDomains = _class.instanceMethodId(
    r'setDomains',
    r'(Ljava/lang/String;)V',
  );

  static final _setDomains =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDomains(java.lang.String string)`
  void setDomains(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDomains(
      reference.pointer,
      _id_setDomains as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_setHttpProxy = _class.instanceMethodId(
    r'setHttpProxy',
    r'(Landroid/net/ProxyInfo;)V',
  );

  static final _setHttpProxy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setHttpProxy(android.net.ProxyInfo proxyInfo)`
  void setHttpProxy(proxyinfo$_.ProxyInfo? proxyInfo) {
    final _$proxyInfo = proxyInfo?.reference ?? jni$_.jNullReference;
    _setHttpProxy(
      reference.pointer,
      _id_setHttpProxy as jni$_.JMethodIDPtr,
      _$proxyInfo.pointer,
    ).check();
  }

  static final _id_setInterfaceName = _class.instanceMethodId(
    r'setInterfaceName',
    r'(Ljava/lang/String;)V',
  );

  static final _setInterfaceName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setInterfaceName(java.lang.String string)`
  void setInterfaceName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setInterfaceName(
      reference.pointer,
      _id_setInterfaceName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_setLinkAddresses = _class.instanceMethodId(
    r'setLinkAddresses',
    r'(Ljava/util/Collection;)V',
  );

  static final _setLinkAddresses =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setLinkAddresses(java.util.Collection<android.net.LinkAddress> collection)`
  void setLinkAddresses(
    collection$_.Collection<linkaddress$_.LinkAddress?> collection,
  ) {
    final _$collection = collection.reference;
    _setLinkAddresses(
      reference.pointer,
      _id_setLinkAddresses as jni$_.JMethodIDPtr,
      _$collection.pointer,
    ).check();
  }

  static final _id_setMtu = _class.instanceMethodId(r'setMtu', r'(I)V');

  static final _setMtu =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMtu(int i)`
  void setMtu(int i) {
    _setMtu(reference.pointer, _id_setMtu as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_setNat64Prefix = _class.instanceMethodId(
    r'setNat64Prefix',
    r'(Landroid/net/IpPrefix;)V',
  );

  static final _setNat64Prefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setNat64Prefix(android.net.IpPrefix ipPrefix)`
  void setNat64Prefix(ipprefix$_.IpPrefix? ipPrefix) {
    final _$ipPrefix = ipPrefix?.reference ?? jni$_.jNullReference;
    _setNat64Prefix(
      reference.pointer,
      _id_setNat64Prefix as jni$_.JMethodIDPtr,
      _$ipPrefix.pointer,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $LinkProperties$NullableType$ extends jni$_.JType<LinkProperties?> {
  @jni$_.internal
  const $LinkProperties$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/LinkProperties;';

  @jni$_.internal
  @core$_.override
  LinkProperties? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LinkProperties.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<LinkProperties?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LinkProperties$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LinkProperties$NullableType$) &&
        other is $LinkProperties$NullableType$;
  }
}

final class $LinkProperties$Type$ extends jni$_.JType<LinkProperties> {
  @jni$_.internal
  const $LinkProperties$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/LinkProperties;';

  @jni$_.internal
  @core$_.override
  LinkProperties fromReference(jni$_.JReference reference) =>
      LinkProperties.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<LinkProperties?> get nullableType =>
      const $LinkProperties$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LinkProperties$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LinkProperties$Type$) &&
        other is $LinkProperties$Type$;
  }
}
