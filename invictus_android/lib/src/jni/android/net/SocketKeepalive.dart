// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `android.net.SocketKeepalive$Callback`
class SocketKeepalive$Callback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<SocketKeepalive$Callback> $type;

  @jni$_.internal
  SocketKeepalive$Callback.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/SocketKeepalive$Callback',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<SocketKeepalive$Callback?> nullableType =
      $SocketKeepalive$Callback$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<SocketKeepalive$Callback> type =
      $SocketKeepalive$Callback$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SocketKeepalive$Callback() {
    return SocketKeepalive$Callback.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_onDataReceived = _class.instanceMethodId(
    r'onDataReceived',
    r'()V',
  );

  static final _onDataReceived =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void onDataReceived()`
  void onDataReceived() {
    _onDataReceived(
      reference.pointer,
      _id_onDataReceived as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_onError = _class.instanceMethodId(r'onError', r'(I)V');

  static final _onError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void onError(int i)`
  void onError(int i) {
    _onError(reference.pointer, _id_onError as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_onStarted = _class.instanceMethodId(r'onStarted', r'()V');

  static final _onStarted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void onStarted()`
  void onStarted() {
    _onStarted(reference.pointer, _id_onStarted as jni$_.JMethodIDPtr).check();
  }

  static final _id_onStopped = _class.instanceMethodId(r'onStopped', r'()V');

  static final _onStopped =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void onStopped()`
  void onStopped() {
    _onStopped(reference.pointer, _id_onStopped as jni$_.JMethodIDPtr).check();
  }
}

final class $SocketKeepalive$Callback$NullableType$
    extends jni$_.JType<SocketKeepalive$Callback?> {
  @jni$_.internal
  const $SocketKeepalive$Callback$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/SocketKeepalive$Callback;';

  @jni$_.internal
  @core$_.override
  SocketKeepalive$Callback? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : SocketKeepalive$Callback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<SocketKeepalive$Callback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketKeepalive$Callback$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SocketKeepalive$Callback$NullableType$) &&
        other is $SocketKeepalive$Callback$NullableType$;
  }
}

final class $SocketKeepalive$Callback$Type$
    extends jni$_.JType<SocketKeepalive$Callback> {
  @jni$_.internal
  const $SocketKeepalive$Callback$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/SocketKeepalive$Callback;';

  @jni$_.internal
  @core$_.override
  SocketKeepalive$Callback fromReference(jni$_.JReference reference) =>
      SocketKeepalive$Callback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<SocketKeepalive$Callback?> get nullableType =>
      const $SocketKeepalive$Callback$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketKeepalive$Callback$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SocketKeepalive$Callback$Type$) &&
        other is $SocketKeepalive$Callback$Type$;
  }
}

/// from: `android.net.SocketKeepalive`
class SocketKeepalive extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<SocketKeepalive> $type;

  @jni$_.internal
  SocketKeepalive.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/net/SocketKeepalive');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<SocketKeepalive?> nullableType =
      $SocketKeepalive$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<SocketKeepalive> type = $SocketKeepalive$Type$();

  /// from: `static public final int ERROR_HARDWARE_ERROR`
  static const ERROR_HARDWARE_ERROR = -31;

  /// from: `static public final int ERROR_INSUFFICIENT_RESOURCES`
  static const ERROR_INSUFFICIENT_RESOURCES = -32;

  /// from: `static public final int ERROR_INVALID_INTERVAL`
  static const ERROR_INVALID_INTERVAL = -24;

  /// from: `static public final int ERROR_INVALID_IP_ADDRESS`
  static const ERROR_INVALID_IP_ADDRESS = -21;

  /// from: `static public final int ERROR_INVALID_LENGTH`
  static const ERROR_INVALID_LENGTH = -23;

  /// from: `static public final int ERROR_INVALID_NETWORK`
  static const ERROR_INVALID_NETWORK = -20;

  /// from: `static public final int ERROR_INVALID_PORT`
  static const ERROR_INVALID_PORT = -22;

  /// from: `static public final int ERROR_INVALID_SOCKET`
  static const ERROR_INVALID_SOCKET = -25;

  /// from: `static public final int ERROR_SOCKET_NOT_IDLE`
  static const ERROR_SOCKET_NOT_IDLE = -26;

  /// from: `static public final int ERROR_UNSUPPORTED`
  static const ERROR_UNSUPPORTED = -30;
  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_start = _class.instanceMethodId(r'start', r'(I)V');

  static final _start =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void start(int i)`
  void start(int i) {
    _start(reference.pointer, _id_start as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_stop = _class.instanceMethodId(r'stop', r'()V');

  static final _stop =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final void stop()`
  void stop() {
    _stop(reference.pointer, _id_stop as jni$_.JMethodIDPtr).check();
  }
}

final class $SocketKeepalive$NullableType$
    extends jni$_.JType<SocketKeepalive?> {
  @jni$_.internal
  const $SocketKeepalive$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/SocketKeepalive;';

  @jni$_.internal
  @core$_.override
  SocketKeepalive? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SocketKeepalive.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<SocketKeepalive?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketKeepalive$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SocketKeepalive$NullableType$) &&
        other is $SocketKeepalive$NullableType$;
  }
}

final class $SocketKeepalive$Type$ extends jni$_.JType<SocketKeepalive> {
  @jni$_.internal
  const $SocketKeepalive$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/SocketKeepalive;';

  @jni$_.internal
  @core$_.override
  SocketKeepalive fromReference(jni$_.JReference reference) =>
      SocketKeepalive.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<SocketKeepalive?> get nullableType =>
      const $SocketKeepalive$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketKeepalive$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SocketKeepalive$Type$) &&
        other is $SocketKeepalive$Type$;
  }
}
