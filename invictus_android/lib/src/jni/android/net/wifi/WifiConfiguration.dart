// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../MacAddress.dart' as macaddress$_;

import '../ProxyInfo.dart' as proxyinfo$_;

/// from: `android.net.wifi.WifiConfiguration$AuthAlgorithm`
class WifiConfiguration$AuthAlgorithm extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiConfiguration$AuthAlgorithm> $type;

  @jni$_.internal
  WifiConfiguration$AuthAlgorithm.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiConfiguration$AuthAlgorithm',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$AuthAlgorithm?> nullableType =
      $WifiConfiguration$AuthAlgorithm$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$AuthAlgorithm> type =
      $WifiConfiguration$AuthAlgorithm$Type$();

  /// from: `static public final int LEAP`
  static const LEAP = 2;

  /// from: `static public final int OPEN`
  static const OPEN = 0;

  /// from: `static public final int SAE`
  static const SAE = 3;

  /// from: `static public final int SHARED`
  static const SHARED = 1;
  static final _id_strings = _class.staticFieldId(
    r'strings',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] strings`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get strings => _id_strings.get(
    _class,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
  );

  static final _id_varName = _class.staticFieldId(
    r'varName',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String varName`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get varName =>
      _id_varName.get(_class, const jni$_.$JString$NullableType$());
}

final class $WifiConfiguration$AuthAlgorithm$NullableType$
    extends jni$_.JType<WifiConfiguration$AuthAlgorithm?> {
  @jni$_.internal
  const $WifiConfiguration$AuthAlgorithm$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$AuthAlgorithm;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$AuthAlgorithm? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiConfiguration$AuthAlgorithm.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$AuthAlgorithm?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$AuthAlgorithm$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiConfiguration$AuthAlgorithm$NullableType$) &&
        other is $WifiConfiguration$AuthAlgorithm$NullableType$;
  }
}

final class $WifiConfiguration$AuthAlgorithm$Type$
    extends jni$_.JType<WifiConfiguration$AuthAlgorithm> {
  @jni$_.internal
  const $WifiConfiguration$AuthAlgorithm$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$AuthAlgorithm;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$AuthAlgorithm fromReference(jni$_.JReference reference) =>
      WifiConfiguration$AuthAlgorithm.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$AuthAlgorithm?> get nullableType =>
      const $WifiConfiguration$AuthAlgorithm$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$AuthAlgorithm$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$AuthAlgorithm$Type$) &&
        other is $WifiConfiguration$AuthAlgorithm$Type$;
  }
}

/// from: `android.net.wifi.WifiConfiguration$GroupCipher`
class WifiConfiguration$GroupCipher extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiConfiguration$GroupCipher> $type;

  @jni$_.internal
  WifiConfiguration$GroupCipher.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiConfiguration$GroupCipher',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$GroupCipher?> nullableType =
      $WifiConfiguration$GroupCipher$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$GroupCipher> type =
      $WifiConfiguration$GroupCipher$Type$();

  /// from: `static public final int CCMP`
  static const CCMP = 3;

  /// from: `static public final int GCMP_128`
  static const GCMP_128 = 7;

  /// from: `static public final int GCMP_256`
  static const GCMP_256 = 5;

  /// from: `static public final int SMS4`
  static const SMS4 = 6;

  /// from: `static public final int TKIP`
  static const TKIP = 2;

  /// from: `static public final int WEP104`
  static const WEP104 = 1;

  /// from: `static public final int WEP40`
  static const WEP40 = 0;
  static final _id_strings = _class.staticFieldId(
    r'strings',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] strings`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get strings => _id_strings.get(
    _class,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
  );

  static final _id_varName = _class.staticFieldId(
    r'varName',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String varName`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get varName =>
      _id_varName.get(_class, const jni$_.$JString$NullableType$());
}

final class $WifiConfiguration$GroupCipher$NullableType$
    extends jni$_.JType<WifiConfiguration$GroupCipher?> {
  @jni$_.internal
  const $WifiConfiguration$GroupCipher$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$GroupCipher;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$GroupCipher? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiConfiguration$GroupCipher.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$GroupCipher?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$GroupCipher$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiConfiguration$GroupCipher$NullableType$) &&
        other is $WifiConfiguration$GroupCipher$NullableType$;
  }
}

final class $WifiConfiguration$GroupCipher$Type$
    extends jni$_.JType<WifiConfiguration$GroupCipher> {
  @jni$_.internal
  const $WifiConfiguration$GroupCipher$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$GroupCipher;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$GroupCipher fromReference(jni$_.JReference reference) =>
      WifiConfiguration$GroupCipher.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$GroupCipher?> get nullableType =>
      const $WifiConfiguration$GroupCipher$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$GroupCipher$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$GroupCipher$Type$) &&
        other is $WifiConfiguration$GroupCipher$Type$;
  }
}

/// from: `android.net.wifi.WifiConfiguration$GroupMgmtCipher`
class WifiConfiguration$GroupMgmtCipher extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiConfiguration$GroupMgmtCipher> $type;

  @jni$_.internal
  WifiConfiguration$GroupMgmtCipher.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiConfiguration$GroupMgmtCipher',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$GroupMgmtCipher?> nullableType =
      $WifiConfiguration$GroupMgmtCipher$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$GroupMgmtCipher> type =
      $WifiConfiguration$GroupMgmtCipher$Type$();

  /// from: `static public final int BIP_CMAC_256`
  static const BIP_CMAC_256 = 0;

  /// from: `static public final int BIP_GMAC_128`
  static const BIP_GMAC_128 = 1;

  /// from: `static public final int BIP_GMAC_256`
  static const BIP_GMAC_256 = 2;
}

final class $WifiConfiguration$GroupMgmtCipher$NullableType$
    extends jni$_.JType<WifiConfiguration$GroupMgmtCipher?> {
  @jni$_.internal
  const $WifiConfiguration$GroupMgmtCipher$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiConfiguration$GroupMgmtCipher;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$GroupMgmtCipher? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : WifiConfiguration$GroupMgmtCipher.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$GroupMgmtCipher?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiConfiguration$GroupMgmtCipher$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiConfiguration$GroupMgmtCipher$NullableType$) &&
        other is $WifiConfiguration$GroupMgmtCipher$NullableType$;
  }
}

final class $WifiConfiguration$GroupMgmtCipher$Type$
    extends jni$_.JType<WifiConfiguration$GroupMgmtCipher> {
  @jni$_.internal
  const $WifiConfiguration$GroupMgmtCipher$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiConfiguration$GroupMgmtCipher;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$GroupMgmtCipher fromReference(jni$_.JReference reference) =>
      WifiConfiguration$GroupMgmtCipher.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$GroupMgmtCipher?> get nullableType =>
      const $WifiConfiguration$GroupMgmtCipher$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$GroupMgmtCipher$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$GroupMgmtCipher$Type$) &&
        other is $WifiConfiguration$GroupMgmtCipher$Type$;
  }
}

/// from: `android.net.wifi.WifiConfiguration$KeyMgmt`
class WifiConfiguration$KeyMgmt extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiConfiguration$KeyMgmt> $type;

  @jni$_.internal
  WifiConfiguration$KeyMgmt.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiConfiguration$KeyMgmt',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$KeyMgmt?> nullableType =
      $WifiConfiguration$KeyMgmt$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$KeyMgmt> type =
      $WifiConfiguration$KeyMgmt$Type$();

  /// from: `static public final int DPP`
  static const DPP = 17;

  /// from: `static public final int FILS_SHA256`
  static const FILS_SHA256 = 15;

  /// from: `static public final int FILS_SHA384`
  static const FILS_SHA384 = 16;

  /// from: `static public final int FT_EAP`
  static const FT_EAP = 7;

  /// from: `static public final int FT_PSK`
  static const FT_PSK = 6;

  /// from: `static public final int IEEE8021X`
  static const IEEE8021X = 3;

  /// from: `static public final int NONE`
  static const NONE = 0;

  /// from: `static public final int OSEN`
  static const OSEN = 5;

  /// from: `static public final int OWE`
  static const OWE = 9;

  /// from: `static public final int SAE`
  static const SAE = 8;

  /// from: `static public final int SUITE_B_192`
  static const SUITE_B_192 = 10;

  /// from: `static public final int WAPI_CERT`
  static const WAPI_CERT = 14;

  /// from: `static public final int WAPI_PSK`
  static const WAPI_PSK = 13;

  /// from: `static public final int WPA2_PSK`
  static const WPA2_PSK = 4;

  /// from: `static public final int WPA_EAP`
  static const WPA_EAP = 2;

  /// from: `static public final int WPA_EAP_SHA256`
  static const WPA_EAP_SHA256 = 12;

  /// from: `static public final int WPA_PSK`
  static const WPA_PSK = 1;

  /// from: `static public final int WPA_PSK_SHA256`
  static const WPA_PSK_SHA256 = 11;
  static final _id_strings = _class.staticFieldId(
    r'strings',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] strings`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get strings => _id_strings.get(
    _class,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
  );

  static final _id_varName = _class.staticFieldId(
    r'varName',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String varName`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get varName =>
      _id_varName.get(_class, const jni$_.$JString$NullableType$());
}

final class $WifiConfiguration$KeyMgmt$NullableType$
    extends jni$_.JType<WifiConfiguration$KeyMgmt?> {
  @jni$_.internal
  const $WifiConfiguration$KeyMgmt$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$KeyMgmt;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$KeyMgmt? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiConfiguration$KeyMgmt.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$KeyMgmt?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$KeyMgmt$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$KeyMgmt$NullableType$) &&
        other is $WifiConfiguration$KeyMgmt$NullableType$;
  }
}

final class $WifiConfiguration$KeyMgmt$Type$
    extends jni$_.JType<WifiConfiguration$KeyMgmt> {
  @jni$_.internal
  const $WifiConfiguration$KeyMgmt$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$KeyMgmt;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$KeyMgmt fromReference(jni$_.JReference reference) =>
      WifiConfiguration$KeyMgmt.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$KeyMgmt?> get nullableType =>
      const $WifiConfiguration$KeyMgmt$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$KeyMgmt$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$KeyMgmt$Type$) &&
        other is $WifiConfiguration$KeyMgmt$Type$;
  }
}

/// from: `android.net.wifi.WifiConfiguration$PairwiseCipher`
class WifiConfiguration$PairwiseCipher extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiConfiguration$PairwiseCipher> $type;

  @jni$_.internal
  WifiConfiguration$PairwiseCipher.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiConfiguration$PairwiseCipher',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$PairwiseCipher?> nullableType =
      $WifiConfiguration$PairwiseCipher$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$PairwiseCipher> type =
      $WifiConfiguration$PairwiseCipher$Type$();

  /// from: `static public final int CCMP`
  static const CCMP = 2;

  /// from: `static public final int GCMP_128`
  static const GCMP_128 = 5;

  /// from: `static public final int GCMP_256`
  static const GCMP_256 = 3;

  /// from: `static public final int NONE`
  static const NONE = 0;

  /// from: `static public final int SMS4`
  static const SMS4 = 4;

  /// from: `static public final int TKIP`
  static const TKIP = 1;
  static final _id_strings = _class.staticFieldId(
    r'strings',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] strings`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get strings => _id_strings.get(
    _class,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
  );

  static final _id_varName = _class.staticFieldId(
    r'varName',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String varName`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get varName =>
      _id_varName.get(_class, const jni$_.$JString$NullableType$());
}

final class $WifiConfiguration$PairwiseCipher$NullableType$
    extends jni$_.JType<WifiConfiguration$PairwiseCipher?> {
  @jni$_.internal
  const $WifiConfiguration$PairwiseCipher$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiConfiguration$PairwiseCipher;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$PairwiseCipher? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiConfiguration$PairwiseCipher.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$PairwiseCipher?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiConfiguration$PairwiseCipher$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiConfiguration$PairwiseCipher$NullableType$) &&
        other is $WifiConfiguration$PairwiseCipher$NullableType$;
  }
}

final class $WifiConfiguration$PairwiseCipher$Type$
    extends jni$_.JType<WifiConfiguration$PairwiseCipher> {
  @jni$_.internal
  const $WifiConfiguration$PairwiseCipher$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiConfiguration$PairwiseCipher;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$PairwiseCipher fromReference(jni$_.JReference reference) =>
      WifiConfiguration$PairwiseCipher.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$PairwiseCipher?> get nullableType =>
      const $WifiConfiguration$PairwiseCipher$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$PairwiseCipher$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$PairwiseCipher$Type$) &&
        other is $WifiConfiguration$PairwiseCipher$Type$;
  }
}

/// from: `android.net.wifi.WifiConfiguration$Protocol`
class WifiConfiguration$Protocol extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiConfiguration$Protocol> $type;

  @jni$_.internal
  WifiConfiguration$Protocol.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiConfiguration$Protocol',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$Protocol?> nullableType =
      $WifiConfiguration$Protocol$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$Protocol> type =
      $WifiConfiguration$Protocol$Type$();

  /// from: `static public final int RSN`
  static const RSN = 1;

  /// from: `static public final int WAPI`
  static const WAPI = 3;

  /// from: `static public final int WPA`
  static const WPA = 0;
  static final _id_strings = _class.staticFieldId(
    r'strings',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] strings`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get strings => _id_strings.get(
    _class,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
  );

  static final _id_varName = _class.staticFieldId(
    r'varName',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String varName`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get varName =>
      _id_varName.get(_class, const jni$_.$JString$NullableType$());
}

final class $WifiConfiguration$Protocol$NullableType$
    extends jni$_.JType<WifiConfiguration$Protocol?> {
  @jni$_.internal
  const $WifiConfiguration$Protocol$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$Protocol;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$Protocol? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiConfiguration$Protocol.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$Protocol?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$Protocol$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$Protocol$NullableType$) &&
        other is $WifiConfiguration$Protocol$NullableType$;
  }
}

final class $WifiConfiguration$Protocol$Type$
    extends jni$_.JType<WifiConfiguration$Protocol> {
  @jni$_.internal
  const $WifiConfiguration$Protocol$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$Protocol;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$Protocol fromReference(jni$_.JReference reference) =>
      WifiConfiguration$Protocol.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$Protocol?> get nullableType =>
      const $WifiConfiguration$Protocol$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$Protocol$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$Protocol$Type$) &&
        other is $WifiConfiguration$Protocol$Type$;
  }
}

/// from: `android.net.wifi.WifiConfiguration$Status`
class WifiConfiguration$Status extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiConfiguration$Status> $type;

  @jni$_.internal
  WifiConfiguration$Status.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiConfiguration$Status',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$Status?> nullableType =
      $WifiConfiguration$Status$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration$Status> type =
      $WifiConfiguration$Status$Type$();

  /// from: `static public final int CURRENT`
  static const CURRENT = 0;

  /// from: `static public final int DISABLED`
  static const DISABLED = 1;

  /// from: `static public final int ENABLED`
  static const ENABLED = 2;
  static final _id_strings = _class.staticFieldId(
    r'strings',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] strings`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get strings => _id_strings.get(
    _class,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
  );
}

final class $WifiConfiguration$Status$NullableType$
    extends jni$_.JType<WifiConfiguration$Status?> {
  @jni$_.internal
  const $WifiConfiguration$Status$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$Status;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$Status? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiConfiguration$Status.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$Status?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$Status$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$Status$NullableType$) &&
        other is $WifiConfiguration$Status$NullableType$;
  }
}

final class $WifiConfiguration$Status$Type$
    extends jni$_.JType<WifiConfiguration$Status> {
  @jni$_.internal
  const $WifiConfiguration$Status$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration$Status;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration$Status fromReference(jni$_.JReference reference) =>
      WifiConfiguration$Status.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration$Status?> get nullableType =>
      const $WifiConfiguration$Status$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$Status$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$Status$Type$) &&
        other is $WifiConfiguration$Status$Type$;
  }
}

/// from: `android.net.wifi.WifiConfiguration`
class WifiConfiguration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiConfiguration> $type;

  @jni$_.internal
  WifiConfiguration.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiConfiguration',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration?> nullableType =
      $WifiConfiguration$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiConfiguration> type = $WifiConfiguration$Type$();
  static final _id_BSSID = _class.instanceFieldId(
    r'BSSID',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String BSSID`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get BSSID =>
      _id_BSSID.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String BSSID`
  /// The returned object must be released after use, by calling the [release] method.
  set BSSID(jni$_.JString? value) =>
      _id_BSSID.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_FQDN = _class.instanceFieldId(
    r'FQDN',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String FQDN`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get FQDN =>
      _id_FQDN.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String FQDN`
  /// The returned object must be released after use, by calling the [release] method.
  set FQDN(jni$_.JString? value) =>
      _id_FQDN.set(this, const jni$_.$JString$NullableType$(), value);

  /// from: `static public final int RANDOMIZATION_AUTO`
  static const RANDOMIZATION_AUTO = 3;

  /// from: `static public final int RANDOMIZATION_NONE`
  static const RANDOMIZATION_NONE = 0;

  /// from: `static public final int RANDOMIZATION_NON_PERSISTENT`
  static const RANDOMIZATION_NON_PERSISTENT = 2;

  /// from: `static public final int RANDOMIZATION_PERSISTENT`
  static const RANDOMIZATION_PERSISTENT = 1;

  /// from: `static public final int SECURITY_TYPE_DPP`
  static const SECURITY_TYPE_DPP = 13;

  /// from: `static public final int SECURITY_TYPE_EAP`
  static const SECURITY_TYPE_EAP = 3;

  /// from: `static public final int SECURITY_TYPE_EAP_SUITE_B`
  static const SECURITY_TYPE_EAP_SUITE_B = 5;

  /// from: `static public final int SECURITY_TYPE_EAP_WPA3_ENTERPRISE`
  static const SECURITY_TYPE_EAP_WPA3_ENTERPRISE = 9;

  /// from: `static public final int SECURITY_TYPE_EAP_WPA3_ENTERPRISE_192_BIT`
  static const SECURITY_TYPE_EAP_WPA3_ENTERPRISE_192_BIT = 5;

  /// from: `static public final int SECURITY_TYPE_OPEN`
  static const SECURITY_TYPE_OPEN = 0;

  /// from: `static public final int SECURITY_TYPE_OWE`
  static const SECURITY_TYPE_OWE = 6;

  /// from: `static public final int SECURITY_TYPE_PSK`
  static const SECURITY_TYPE_PSK = 2;

  /// from: `static public final int SECURITY_TYPE_SAE`
  static const SECURITY_TYPE_SAE = 4;

  /// from: `static public final int SECURITY_TYPE_WAPI_CERT`
  static const SECURITY_TYPE_WAPI_CERT = 8;

  /// from: `static public final int SECURITY_TYPE_WAPI_PSK`
  static const SECURITY_TYPE_WAPI_PSK = 7;

  /// from: `static public final int SECURITY_TYPE_WEP`
  static const SECURITY_TYPE_WEP = 1;
  static final _id_SSID = _class.instanceFieldId(
    r'SSID',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String SSID`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get SSID =>
      _id_SSID.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String SSID`
  /// The returned object must be released after use, by calling the [release] method.
  set SSID(jni$_.JString? value) =>
      _id_SSID.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_allowedAuthAlgorithms = _class.instanceFieldId(
    r'allowedAuthAlgorithms',
    r'Ljava/util/BitSet;',
  );

  /// from: `public java.util.BitSet allowedAuthAlgorithms`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject get allowedAuthAlgorithms =>
      _id_allowedAuthAlgorithms.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.util.BitSet allowedAuthAlgorithms`
  /// The returned object must be released after use, by calling the [release] method.
  set allowedAuthAlgorithms(jni$_.JObject value) =>
      _id_allowedAuthAlgorithms.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_allowedGroupCiphers = _class.instanceFieldId(
    r'allowedGroupCiphers',
    r'Ljava/util/BitSet;',
  );

  /// from: `public java.util.BitSet allowedGroupCiphers`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject get allowedGroupCiphers =>
      _id_allowedGroupCiphers.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.util.BitSet allowedGroupCiphers`
  /// The returned object must be released after use, by calling the [release] method.
  set allowedGroupCiphers(jni$_.JObject value) =>
      _id_allowedGroupCiphers.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_allowedGroupManagementCiphers = _class.instanceFieldId(
    r'allowedGroupManagementCiphers',
    r'Ljava/util/BitSet;',
  );

  /// from: `public java.util.BitSet allowedGroupManagementCiphers`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject get allowedGroupManagementCiphers =>
      _id_allowedGroupManagementCiphers.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.util.BitSet allowedGroupManagementCiphers`
  /// The returned object must be released after use, by calling the [release] method.
  set allowedGroupManagementCiphers(jni$_.JObject value) =>
      _id_allowedGroupManagementCiphers.set(
        this,
        const jni$_.$JObject$Type$(),
        value,
      );

  static final _id_allowedKeyManagement = _class.instanceFieldId(
    r'allowedKeyManagement',
    r'Ljava/util/BitSet;',
  );

  /// from: `public java.util.BitSet allowedKeyManagement`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject get allowedKeyManagement =>
      _id_allowedKeyManagement.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.util.BitSet allowedKeyManagement`
  /// The returned object must be released after use, by calling the [release] method.
  set allowedKeyManagement(jni$_.JObject value) =>
      _id_allowedKeyManagement.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_allowedPairwiseCiphers = _class.instanceFieldId(
    r'allowedPairwiseCiphers',
    r'Ljava/util/BitSet;',
  );

  /// from: `public java.util.BitSet allowedPairwiseCiphers`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject get allowedPairwiseCiphers =>
      _id_allowedPairwiseCiphers.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.util.BitSet allowedPairwiseCiphers`
  /// The returned object must be released after use, by calling the [release] method.
  set allowedPairwiseCiphers(jni$_.JObject value) =>
      _id_allowedPairwiseCiphers.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_allowedProtocols = _class.instanceFieldId(
    r'allowedProtocols',
    r'Ljava/util/BitSet;',
  );

  /// from: `public java.util.BitSet allowedProtocols`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject get allowedProtocols =>
      _id_allowedProtocols.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.util.BitSet allowedProtocols`
  /// The returned object must be released after use, by calling the [release] method.
  set allowedProtocols(jni$_.JObject value) =>
      _id_allowedProtocols.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_allowedSuiteBCiphers = _class.instanceFieldId(
    r'allowedSuiteBCiphers',
    r'Ljava/util/BitSet;',
  );

  /// from: `public java.util.BitSet allowedSuiteBCiphers`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject get allowedSuiteBCiphers =>
      _id_allowedSuiteBCiphers.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.util.BitSet allowedSuiteBCiphers`
  /// The returned object must be released after use, by calling the [release] method.
  set allowedSuiteBCiphers(jni$_.JObject value) =>
      _id_allowedSuiteBCiphers.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_enterpriseConfig = _class.instanceFieldId(
    r'enterpriseConfig',
    r'Landroid/net/wifi/WifiEnterpriseConfig;',
  );

  /// from: `public android.net.wifi.WifiEnterpriseConfig enterpriseConfig`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get enterpriseConfig =>
      _id_enterpriseConfig.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.net.wifi.WifiEnterpriseConfig enterpriseConfig`
  /// The returned object must be released after use, by calling the [release] method.
  set enterpriseConfig(jni$_.JObject? value) => _id_enterpriseConfig.set(
    this,
    const jni$_.$JObject$NullableType$(),
    value,
  );

  static final _id_hiddenSSID = _class.instanceFieldId(r'hiddenSSID', r'Z');

  /// from: `public boolean hiddenSSID`
  bool get hiddenSSID => _id_hiddenSSID.get(this, const jni$_.jbooleanType());

  /// from: `public boolean hiddenSSID`
  set hiddenSSID(bool value) =>
      _id_hiddenSSID.set(this, const jni$_.jbooleanType(), value);

  static final _id_isHomeProviderNetwork = _class.instanceFieldId(
    r'isHomeProviderNetwork',
    r'Z',
  );

  /// from: `public boolean isHomeProviderNetwork`
  bool get isHomeProviderNetwork =>
      _id_isHomeProviderNetwork.get(this, const jni$_.jbooleanType());

  /// from: `public boolean isHomeProviderNetwork`
  set isHomeProviderNetwork(bool value) =>
      _id_isHomeProviderNetwork.set(this, const jni$_.jbooleanType(), value);

  static final _id_networkId = _class.instanceFieldId(r'networkId', r'I');

  /// from: `public int networkId`
  int get networkId => _id_networkId.get(this, const jni$_.jintType());

  /// from: `public int networkId`
  set networkId(int value) =>
      _id_networkId.set(this, const jni$_.jintType(), value);

  static final _id_preSharedKey = _class.instanceFieldId(
    r'preSharedKey',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String preSharedKey`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get preSharedKey =>
      _id_preSharedKey.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String preSharedKey`
  /// The returned object must be released after use, by calling the [release] method.
  set preSharedKey(jni$_.JString? value) =>
      _id_preSharedKey.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_priority = _class.instanceFieldId(r'priority', r'I');

  /// from: `public int priority`
  int get priority => _id_priority.get(this, const jni$_.jintType());

  /// from: `public int priority`
  set priority(int value) =>
      _id_priority.set(this, const jni$_.jintType(), value);

  static final _id_providerFriendlyName = _class.instanceFieldId(
    r'providerFriendlyName',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String providerFriendlyName`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get providerFriendlyName =>
      _id_providerFriendlyName.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String providerFriendlyName`
  /// The returned object must be released after use, by calling the [release] method.
  set providerFriendlyName(jni$_.JString? value) => _id_providerFriendlyName
      .set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_roamingConsortiumIds = _class.instanceFieldId(
    r'roamingConsortiumIds',
    r'[J',
  );

  /// from: `public long[] roamingConsortiumIds`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? get roamingConsortiumIds => _id_roamingConsortiumIds.get(
    this,
    const jni$_.$JLongArray$NullableType$(),
  );

  /// from: `public long[] roamingConsortiumIds`
  /// The returned object must be released after use, by calling the [release] method.
  set roamingConsortiumIds(jni$_.JLongArray? value) => _id_roamingConsortiumIds
      .set(this, const jni$_.$JLongArray$NullableType$(), value);

  static final _id_status = _class.instanceFieldId(r'status', r'I');

  /// from: `public int status`
  int get status => _id_status.get(this, const jni$_.jintType());

  /// from: `public int status`
  set status(int value) => _id_status.set(this, const jni$_.jintType(), value);

  static final _id_wepKeys = _class.instanceFieldId(
    r'wepKeys',
    r'[Ljava/lang/String;',
  );

  /// from: `public java.lang.String[] wepKeys`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? get wepKeys => _id_wepKeys.get(
    this,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
  );

  /// from: `public java.lang.String[] wepKeys`
  /// The returned object must be released after use, by calling the [release] method.
  set wepKeys(jni$_.JArray<jni$_.JString?>? value) => _id_wepKeys.set(
    this,
    const jni$_.$JArray$NullableType$<jni$_.JString?>(
      jni$_.$JString$NullableType$(),
    ),
    value,
  );

  static final _id_wepTxKeyIndex = _class.instanceFieldId(
    r'wepTxKeyIndex',
    r'I',
  );

  /// from: `public int wepTxKeyIndex`
  int get wepTxKeyIndex => _id_wepTxKeyIndex.get(this, const jni$_.jintType());

  /// from: `public int wepTxKeyIndex`
  set wepTxKeyIndex(int value) =>
      _id_wepTxKeyIndex.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory WifiConfiguration() {
    return WifiConfiguration.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Landroid/net/wifi/WifiConfiguration;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(android.net.wifi.WifiConfiguration wifiConfiguration)`
  /// The returned object must be released after use, by calling the [release] method.
  factory WifiConfiguration.new$1(WifiConfiguration wifiConfiguration) {
    final _$wifiConfiguration = wifiConfiguration.reference;
    return WifiConfiguration.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$wifiConfiguration.pointer,
      ).reference,
    );
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getHttpProxy = _class.instanceMethodId(
    r'getHttpProxy',
    r'()Landroid/net/ProxyInfo;',
  );

  static final _getHttpProxy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.ProxyInfo getHttpProxy()`
  /// The returned object must be released after use, by calling the [release] method.
  proxyinfo$_.ProxyInfo? getHttpProxy() {
    return _getHttpProxy(
      reference.pointer,
      _id_getHttpProxy as jni$_.JMethodIDPtr,
    ).object<proxyinfo$_.ProxyInfo?>(
      const proxyinfo$_.$ProxyInfo$NullableType$(),
    );
  }

  static final _id_getKey = _class.instanceMethodId(
    r'getKey',
    r'()Ljava/lang/String;',
  );

  static final _getKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getKey()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getKey() {
    return _getKey(
      reference.pointer,
      _id_getKey as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getMacRandomizationSetting = _class.instanceMethodId(
    r'getMacRandomizationSetting',
    r'()I',
  );

  static final _getMacRandomizationSetting =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMacRandomizationSetting()`
  int getMacRandomizationSetting() {
    return _getMacRandomizationSetting(
      reference.pointer,
      _id_getMacRandomizationSetting as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getRandomizedMacAddress = _class.instanceMethodId(
    r'getRandomizedMacAddress',
    r'()Landroid/net/MacAddress;',
  );

  static final _getRandomizedMacAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.MacAddress getRandomizedMacAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  macaddress$_.MacAddress getRandomizedMacAddress() {
    return _getRandomizedMacAddress(
      reference.pointer,
      _id_getRandomizedMacAddress as jni$_.JMethodIDPtr,
    ).object<macaddress$_.MacAddress>(const macaddress$_.$MacAddress$Type$());
  }

  static final _id_isDppConfigurator = _class.instanceMethodId(
    r'isDppConfigurator',
    r'()Z',
  );

  static final _isDppConfigurator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDppConfigurator()`
  bool isDppConfigurator() {
    return _isDppConfigurator(
      reference.pointer,
      _id_isDppConfigurator as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isPasspoint = _class.instanceMethodId(
    r'isPasspoint',
    r'()Z',
  );

  static final _isPasspoint =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPasspoint()`
  bool isPasspoint() {
    return _isPasspoint(
      reference.pointer,
      _id_isPasspoint as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setHttpProxy = _class.instanceMethodId(
    r'setHttpProxy',
    r'(Landroid/net/ProxyInfo;)V',
  );

  static final _setHttpProxy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setHttpProxy(android.net.ProxyInfo proxyInfo)`
  void setHttpProxy(proxyinfo$_.ProxyInfo? proxyInfo) {
    final _$proxyInfo = proxyInfo?.reference ?? jni$_.jNullReference;
    _setHttpProxy(
      reference.pointer,
      _id_setHttpProxy as jni$_.JMethodIDPtr,
      _$proxyInfo.pointer,
    ).check();
  }

  static final _id_setIpConfiguration = _class.instanceMethodId(
    r'setIpConfiguration',
    r'(Landroid/net/IpConfiguration;)V',
  );

  static final _setIpConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setIpConfiguration(android.net.IpConfiguration ipConfiguration)`
  void setIpConfiguration(jni$_.JObject? ipConfiguration) {
    final _$ipConfiguration =
        ipConfiguration?.reference ?? jni$_.jNullReference;
    _setIpConfiguration(
      reference.pointer,
      _id_setIpConfiguration as jni$_.JMethodIDPtr,
      _$ipConfiguration.pointer,
    ).check();
  }

  static final _id_setMacRandomizationSetting = _class.instanceMethodId(
    r'setMacRandomizationSetting',
    r'(I)V',
  );

  static final _setMacRandomizationSetting =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMacRandomizationSetting(int i)`
  void setMacRandomizationSetting(int i) {
    _setMacRandomizationSetting(
      reference.pointer,
      _id_setMacRandomizationSetting as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setSecurityParams = _class.instanceMethodId(
    r'setSecurityParams',
    r'(I)V',
  );

  static final _setSecurityParams =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSecurityParams(int i)`
  void setSecurityParams(int i) {
    _setSecurityParams(
      reference.pointer,
      _id_setSecurityParams as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $WifiConfiguration$NullableType$
    extends jni$_.JType<WifiConfiguration?> {
  @jni$_.internal
  const $WifiConfiguration$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : WifiConfiguration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$NullableType$) &&
        other is $WifiConfiguration$NullableType$;
  }
}

final class $WifiConfiguration$Type$ extends jni$_.JType<WifiConfiguration> {
  @jni$_.internal
  const $WifiConfiguration$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiConfiguration;';

  @jni$_.internal
  @core$_.override
  WifiConfiguration fromReference(jni$_.JReference reference) =>
      WifiConfiguration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiConfiguration?> get nullableType =>
      const $WifiConfiguration$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiConfiguration$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiConfiguration$Type$) &&
        other is $WifiConfiguration$Type$;
  }
}
