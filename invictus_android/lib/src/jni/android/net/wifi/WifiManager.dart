// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../../java/net/InetAddress.dart' as inetaddress$_;

import '../../../java/util/concurrent/Executor.dart' as executor$_;

import '../../os/Handler.dart' as handler$_;

import '../DhcpInfo.dart' as dhcpinfo$_;

import 'ScanResult.dart' as scanresult$_;

import 'WifiConfiguration.dart' as wificonfiguration$_;

import 'WifiInfo.dart' as wifiinfo$_;

/// from: `android.net.wifi.WifiManager$AddNetworkResult`
class WifiManager$AddNetworkResult extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$AddNetworkResult> $type;

  @jni$_.internal
  WifiManager$AddNetworkResult.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$AddNetworkResult',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$AddNetworkResult?> nullableType =
      $WifiManager$AddNetworkResult$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$AddNetworkResult> type =
      $WifiManager$AddNetworkResult$Type$();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.net.wifi.WifiManager$AddNetworkResult> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$Type$());

  /// from: `static public final int STATUS_ADD_PASSPOINT_FAILURE`
  static const STATUS_ADD_PASSPOINT_FAILURE = 3;

  /// from: `static public final int STATUS_ADD_WIFI_CONFIG_FAILURE`
  static const STATUS_ADD_WIFI_CONFIG_FAILURE = 4;

  /// from: `static public final int STATUS_FAILURE_UNKNOWN`
  static const STATUS_FAILURE_UNKNOWN = 1;

  /// from: `static public final int STATUS_FAILURE_UPDATE_NETWORK_KEYS`
  static const STATUS_FAILURE_UPDATE_NETWORK_KEYS = 9;

  /// from: `static public final int STATUS_INVALID_CONFIGURATION`
  static const STATUS_INVALID_CONFIGURATION = 5;

  /// from: `static public final int STATUS_INVALID_CONFIGURATION_ENTERPRISE`
  static const STATUS_INVALID_CONFIGURATION_ENTERPRISE = 10;

  /// from: `static public final int STATUS_NO_PERMISSION`
  static const STATUS_NO_PERMISSION = 2;

  /// from: `static public final int STATUS_NO_PERMISSION_MODIFY_CONFIG`
  static const STATUS_NO_PERMISSION_MODIFY_CONFIG = 6;

  /// from: `static public final int STATUS_NO_PERMISSION_MODIFY_MAC_RANDOMIZATION`
  static const STATUS_NO_PERMISSION_MODIFY_MAC_RANDOMIZATION = 8;

  /// from: `static public final int STATUS_NO_PERMISSION_MODIFY_PROXY_SETTING`
  static const STATUS_NO_PERMISSION_MODIFY_PROXY_SETTING = 7;

  /// from: `static public final int STATUS_SUCCESS`
  static const STATUS_SUCCESS = 0;
  static final _id_networkId = _class.instanceFieldId(r'networkId', r'I');

  /// from: `public final int networkId`
  int get networkId => _id_networkId.get(this, const jni$_.jintType());

  static final _id_statusCode = _class.instanceFieldId(r'statusCode', r'I');

  /// from: `public final int statusCode`
  int get statusCode => _id_statusCode.get(this, const jni$_.jintType());

  static final _id_new$ = _class.constructorId(r'(II)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void <init>(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory WifiManager$AddNetworkResult(int i, int i1) {
    return WifiManager$AddNetworkResult.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        i,
        i1,
      ).reference,
    );
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject parcel, int i) {
    final _$parcel = parcel.reference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $WifiManager$AddNetworkResult$NullableType$
    extends jni$_.JType<WifiManager$AddNetworkResult?> {
  @jni$_.internal
  const $WifiManager$AddNetworkResult$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$AddNetworkResult;';

  @jni$_.internal
  @core$_.override
  WifiManager$AddNetworkResult? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiManager$AddNetworkResult.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$AddNetworkResult?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$AddNetworkResult$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$AddNetworkResult$NullableType$) &&
        other is $WifiManager$AddNetworkResult$NullableType$;
  }
}

final class $WifiManager$AddNetworkResult$Type$
    extends jni$_.JType<WifiManager$AddNetworkResult> {
  @jni$_.internal
  const $WifiManager$AddNetworkResult$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$AddNetworkResult;';

  @jni$_.internal
  @core$_.override
  WifiManager$AddNetworkResult fromReference(jni$_.JReference reference) =>
      WifiManager$AddNetworkResult.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$AddNetworkResult?> get nullableType =>
      const $WifiManager$AddNetworkResult$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$AddNetworkResult$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$AddNetworkResult$Type$) &&
        other is $WifiManager$AddNetworkResult$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$InterfaceCreationImpact`
class WifiManager$InterfaceCreationImpact extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$InterfaceCreationImpact> $type;

  @jni$_.internal
  WifiManager$InterfaceCreationImpact.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$InterfaceCreationImpact',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$InterfaceCreationImpact?> nullableType =
      $WifiManager$InterfaceCreationImpact$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$InterfaceCreationImpact> type =
      $WifiManager$InterfaceCreationImpact$Type$();
  static final _id_new$ = _class.constructorId(r'(ILjava/util/Set;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(int i, java.util.Set<java.lang.String> set)`
  /// The returned object must be released after use, by calling the [release] method.
  factory WifiManager$InterfaceCreationImpact(
    int i,
    jni$_.JSet<jni$_.JString?> set,
  ) {
    final _$set = set.reference;
    return WifiManager$InterfaceCreationImpact.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        i,
        _$set.pointer,
      ).reference,
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_getInterfaceType = _class.instanceMethodId(
    r'getInterfaceType',
    r'()I',
  );

  static final _getInterfaceType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getInterfaceType()`
  int getInterfaceType() {
    return _getInterfaceType(
      reference.pointer,
      _id_getInterfaceType as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getPackages = _class.instanceMethodId(
    r'getPackages',
    r'()Ljava/util/Set;',
  );

  static final _getPackages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.lang.String> getPackages()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JString?> getPackages() {
    return _getPackages(
      reference.pointer,
      _id_getPackages as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JString?>>(
      const jni$_.$JSet$Type$<jni$_.JString?>(jni$_.$JString$NullableType$()),
    );
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }
}

final class $WifiManager$InterfaceCreationImpact$NullableType$
    extends jni$_.JType<WifiManager$InterfaceCreationImpact?> {
  @jni$_.internal
  const $WifiManager$InterfaceCreationImpact$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$InterfaceCreationImpact;';

  @jni$_.internal
  @core$_.override
  WifiManager$InterfaceCreationImpact? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : WifiManager$InterfaceCreationImpact.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$InterfaceCreationImpact?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$InterfaceCreationImpact$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$InterfaceCreationImpact$NullableType$) &&
        other is $WifiManager$InterfaceCreationImpact$NullableType$;
  }
}

final class $WifiManager$InterfaceCreationImpact$Type$
    extends jni$_.JType<WifiManager$InterfaceCreationImpact> {
  @jni$_.internal
  const $WifiManager$InterfaceCreationImpact$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$InterfaceCreationImpact;';

  @jni$_.internal
  @core$_.override
  WifiManager$InterfaceCreationImpact fromReference(
    jni$_.JReference reference,
  ) => WifiManager$InterfaceCreationImpact.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$InterfaceCreationImpact?> get nullableType =>
      const $WifiManager$InterfaceCreationImpact$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$InterfaceCreationImpact$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$InterfaceCreationImpact$Type$) &&
        other is $WifiManager$InterfaceCreationImpact$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$LocalOnlyConnectionFailureListener`
class WifiManager$LocalOnlyConnectionFailureListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$LocalOnlyConnectionFailureListener> $type;

  @jni$_.internal
  WifiManager$LocalOnlyConnectionFailureListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$LocalOnlyConnectionFailureListener',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$LocalOnlyConnectionFailureListener?>
  nullableType =
      $WifiManager$LocalOnlyConnectionFailureListener$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$LocalOnlyConnectionFailureListener>
  type = $WifiManager$LocalOnlyConnectionFailureListener$Type$();
  static final _id_onConnectionFailed = _class.instanceMethodId(
    r'onConnectionFailed',
    r'(Landroid/net/wifi/WifiNetworkSpecifier;I)V',
  );

  static final _onConnectionFailed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void onConnectionFailed(android.net.wifi.WifiNetworkSpecifier wifiNetworkSpecifier, int i)`
  void onConnectionFailed(jni$_.JObject wifiNetworkSpecifier, int i) {
    final _$wifiNetworkSpecifier = wifiNetworkSpecifier.reference;
    _onConnectionFailed(
      reference.pointer,
      _id_onConnectionFailed as jni$_.JMethodIDPtr,
      _$wifiNetworkSpecifier.pointer,
      i,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $WifiManager$LocalOnlyConnectionFailureListener>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onConnectionFailed(Landroid/net/wifi/WifiNetworkSpecifier;I)V') {
        _$impls[$p]!.onConnectionFailed(
          $a![0]!.as(const jni$_.$JObject$Type$(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.$JInteger$Type$(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $WifiManager$LocalOnlyConnectionFailureListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'android.net.wifi.WifiManager$LocalOnlyConnectionFailureListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onConnectionFailed$async)
          r'onConnectionFailed(Landroid/net/wifi/WifiNetworkSpecifier;I)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory WifiManager$LocalOnlyConnectionFailureListener.implement(
    $WifiManager$LocalOnlyConnectionFailureListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return WifiManager$LocalOnlyConnectionFailureListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $WifiManager$LocalOnlyConnectionFailureListener {
  factory $WifiManager$LocalOnlyConnectionFailureListener({
    required void Function(jni$_.JObject wifiNetworkSpecifier, int i)
    onConnectionFailed,
    bool onConnectionFailed$async,
  }) = _$WifiManager$LocalOnlyConnectionFailureListener;

  void onConnectionFailed(jni$_.JObject wifiNetworkSpecifier, int i);
  bool get onConnectionFailed$async => false;
}

final class _$WifiManager$LocalOnlyConnectionFailureListener
    with $WifiManager$LocalOnlyConnectionFailureListener {
  _$WifiManager$LocalOnlyConnectionFailureListener({
    required void Function(jni$_.JObject wifiNetworkSpecifier, int i)
    onConnectionFailed,
    this.onConnectionFailed$async = false,
  }) : _onConnectionFailed = onConnectionFailed;

  final void Function(jni$_.JObject wifiNetworkSpecifier, int i)
  _onConnectionFailed;
  final bool onConnectionFailed$async;

  void onConnectionFailed(jni$_.JObject wifiNetworkSpecifier, int i) {
    return _onConnectionFailed(wifiNetworkSpecifier, i);
  }
}

final class $WifiManager$LocalOnlyConnectionFailureListener$NullableType$
    extends jni$_.JType<WifiManager$LocalOnlyConnectionFailureListener?> {
  @jni$_.internal
  const $WifiManager$LocalOnlyConnectionFailureListener$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$LocalOnlyConnectionFailureListener;';

  @jni$_.internal
  @core$_.override
  WifiManager$LocalOnlyConnectionFailureListener? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : WifiManager$LocalOnlyConnectionFailureListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$LocalOnlyConnectionFailureListener?>
  get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$LocalOnlyConnectionFailureListener$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$LocalOnlyConnectionFailureListener$NullableType$) &&
        other is $WifiManager$LocalOnlyConnectionFailureListener$NullableType$;
  }
}

final class $WifiManager$LocalOnlyConnectionFailureListener$Type$
    extends jni$_.JType<WifiManager$LocalOnlyConnectionFailureListener> {
  @jni$_.internal
  const $WifiManager$LocalOnlyConnectionFailureListener$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$LocalOnlyConnectionFailureListener;';

  @jni$_.internal
  @core$_.override
  WifiManager$LocalOnlyConnectionFailureListener fromReference(
    jni$_.JReference reference,
  ) => WifiManager$LocalOnlyConnectionFailureListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$LocalOnlyConnectionFailureListener?>
  get nullableType =>
      const $WifiManager$LocalOnlyConnectionFailureListener$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$LocalOnlyConnectionFailureListener$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$LocalOnlyConnectionFailureListener$Type$) &&
        other is $WifiManager$LocalOnlyConnectionFailureListener$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$LocalOnlyHotspotCallback`
class WifiManager$LocalOnlyHotspotCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$LocalOnlyHotspotCallback> $type;

  @jni$_.internal
  WifiManager$LocalOnlyHotspotCallback.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$LocalOnlyHotspotCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$LocalOnlyHotspotCallback?> nullableType =
      $WifiManager$LocalOnlyHotspotCallback$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$LocalOnlyHotspotCallback> type =
      $WifiManager$LocalOnlyHotspotCallback$Type$();

  /// from: `static public final int ERROR_GENERIC`
  static const ERROR_GENERIC = 2;

  /// from: `static public final int ERROR_INCOMPATIBLE_MODE`
  static const ERROR_INCOMPATIBLE_MODE = 3;

  /// from: `static public final int ERROR_NO_CHANNEL`
  static const ERROR_NO_CHANNEL = 1;

  /// from: `static public final int ERROR_TETHERING_DISALLOWED`
  static const ERROR_TETHERING_DISALLOWED = 4;
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory WifiManager$LocalOnlyHotspotCallback() {
    return WifiManager$LocalOnlyHotspotCallback.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_onFailed = _class.instanceMethodId(r'onFailed', r'(I)V');

  static final _onFailed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void onFailed(int i)`
  void onFailed(int i) {
    _onFailed(reference.pointer, _id_onFailed as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_onStarted = _class.instanceMethodId(
    r'onStarted',
    r'(Landroid/net/wifi/WifiManager$LocalOnlyHotspotReservation;)V',
  );

  static final _onStarted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void onStarted(android.net.wifi.WifiManager$LocalOnlyHotspotReservation localOnlyHotspotReservation)`
  void onStarted(
    WifiManager$LocalOnlyHotspotReservation? localOnlyHotspotReservation,
  ) {
    final _$localOnlyHotspotReservation =
        localOnlyHotspotReservation?.reference ?? jni$_.jNullReference;
    _onStarted(
      reference.pointer,
      _id_onStarted as jni$_.JMethodIDPtr,
      _$localOnlyHotspotReservation.pointer,
    ).check();
  }

  static final _id_onStopped = _class.instanceMethodId(r'onStopped', r'()V');

  static final _onStopped =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void onStopped()`
  void onStopped() {
    _onStopped(reference.pointer, _id_onStopped as jni$_.JMethodIDPtr).check();
  }
}

final class $WifiManager$LocalOnlyHotspotCallback$NullableType$
    extends jni$_.JType<WifiManager$LocalOnlyHotspotCallback?> {
  @jni$_.internal
  const $WifiManager$LocalOnlyHotspotCallback$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$LocalOnlyHotspotCallback;';

  @jni$_.internal
  @core$_.override
  WifiManager$LocalOnlyHotspotCallback? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : WifiManager$LocalOnlyHotspotCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$LocalOnlyHotspotCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$LocalOnlyHotspotCallback$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$LocalOnlyHotspotCallback$NullableType$) &&
        other is $WifiManager$LocalOnlyHotspotCallback$NullableType$;
  }
}

final class $WifiManager$LocalOnlyHotspotCallback$Type$
    extends jni$_.JType<WifiManager$LocalOnlyHotspotCallback> {
  @jni$_.internal
  const $WifiManager$LocalOnlyHotspotCallback$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$LocalOnlyHotspotCallback;';

  @jni$_.internal
  @core$_.override
  WifiManager$LocalOnlyHotspotCallback fromReference(
    jni$_.JReference reference,
  ) => WifiManager$LocalOnlyHotspotCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$LocalOnlyHotspotCallback?> get nullableType =>
      const $WifiManager$LocalOnlyHotspotCallback$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$LocalOnlyHotspotCallback$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$LocalOnlyHotspotCallback$Type$) &&
        other is $WifiManager$LocalOnlyHotspotCallback$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$LocalOnlyHotspotReservation`
class WifiManager$LocalOnlyHotspotReservation extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$LocalOnlyHotspotReservation> $type;

  @jni$_.internal
  WifiManager$LocalOnlyHotspotReservation.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$LocalOnlyHotspotReservation',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$LocalOnlyHotspotReservation?>
  nullableType = $WifiManager$LocalOnlyHotspotReservation$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$LocalOnlyHotspotReservation> type =
      $WifiManager$LocalOnlyHotspotReservation$Type$();
  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_getSoftApConfiguration = _class.instanceMethodId(
    r'getSoftApConfiguration',
    r'()Landroid/net/wifi/SoftApConfiguration;',
  );

  static final _getSoftApConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.wifi.SoftApConfiguration getSoftApConfiguration()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getSoftApConfiguration() {
    return _getSoftApConfiguration(
      reference.pointer,
      _id_getSoftApConfiguration as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_getWifiConfiguration = _class.instanceMethodId(
    r'getWifiConfiguration',
    r'()Landroid/net/wifi/WifiConfiguration;',
  );

  static final _getWifiConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.wifi.WifiConfiguration getWifiConfiguration()`
  /// The returned object must be released after use, by calling the [release] method.
  wificonfiguration$_.WifiConfiguration? getWifiConfiguration() {
    return _getWifiConfiguration(
      reference.pointer,
      _id_getWifiConfiguration as jni$_.JMethodIDPtr,
    ).object<wificonfiguration$_.WifiConfiguration?>(
      const wificonfiguration$_.$WifiConfiguration$NullableType$(),
    );
  }
}

final class $WifiManager$LocalOnlyHotspotReservation$NullableType$
    extends jni$_.JType<WifiManager$LocalOnlyHotspotReservation?> {
  @jni$_.internal
  const $WifiManager$LocalOnlyHotspotReservation$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$LocalOnlyHotspotReservation;';

  @jni$_.internal
  @core$_.override
  WifiManager$LocalOnlyHotspotReservation? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : WifiManager$LocalOnlyHotspotReservation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$LocalOnlyHotspotReservation?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$LocalOnlyHotspotReservation$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$LocalOnlyHotspotReservation$NullableType$) &&
        other is $WifiManager$LocalOnlyHotspotReservation$NullableType$;
  }
}

final class $WifiManager$LocalOnlyHotspotReservation$Type$
    extends jni$_.JType<WifiManager$LocalOnlyHotspotReservation> {
  @jni$_.internal
  const $WifiManager$LocalOnlyHotspotReservation$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$LocalOnlyHotspotReservation;';

  @jni$_.internal
  @core$_.override
  WifiManager$LocalOnlyHotspotReservation fromReference(
    jni$_.JReference reference,
  ) => WifiManager$LocalOnlyHotspotReservation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$LocalOnlyHotspotReservation?> get nullableType =>
      const $WifiManager$LocalOnlyHotspotReservation$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$LocalOnlyHotspotReservation$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$LocalOnlyHotspotReservation$Type$) &&
        other is $WifiManager$LocalOnlyHotspotReservation$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$MulticastLock`
class WifiManager$MulticastLock extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$MulticastLock> $type;

  @jni$_.internal
  WifiManager$MulticastLock.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$MulticastLock',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$MulticastLock?> nullableType =
      $WifiManager$MulticastLock$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$MulticastLock> type =
      $WifiManager$MulticastLock$Type$();
  static final _id_acquire = _class.instanceMethodId(r'acquire', r'()V');

  static final _acquire =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void acquire()`
  void acquire() {
    _acquire(reference.pointer, _id_acquire as jni$_.JMethodIDPtr).check();
  }

  static final _id_isHeld = _class.instanceMethodId(r'isHeld', r'()Z');

  static final _isHeld =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isHeld()`
  bool isHeld() {
    return _isHeld(reference.pointer, _id_isHeld as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_release$1 = _class.instanceMethodId(r'release', r'()V');

  static final _release$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void release()`
  void release$1() {
    _release$1(reference.pointer, _id_release$1 as jni$_.JMethodIDPtr).check();
  }

  static final _id_setReferenceCounted = _class.instanceMethodId(
    r'setReferenceCounted',
    r'(Z)V',
  );

  static final _setReferenceCounted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReferenceCounted(boolean z)`
  void setReferenceCounted(bool z) {
    _setReferenceCounted(
      reference.pointer,
      _id_setReferenceCounted as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $WifiManager$MulticastLock$NullableType$
    extends jni$_.JType<WifiManager$MulticastLock?> {
  @jni$_.internal
  const $WifiManager$MulticastLock$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$MulticastLock;';

  @jni$_.internal
  @core$_.override
  WifiManager$MulticastLock? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiManager$MulticastLock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$MulticastLock?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$MulticastLock$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$MulticastLock$NullableType$) &&
        other is $WifiManager$MulticastLock$NullableType$;
  }
}

final class $WifiManager$MulticastLock$Type$
    extends jni$_.JType<WifiManager$MulticastLock> {
  @jni$_.internal
  const $WifiManager$MulticastLock$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$MulticastLock;';

  @jni$_.internal
  @core$_.override
  WifiManager$MulticastLock fromReference(jni$_.JReference reference) =>
      WifiManager$MulticastLock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$MulticastLock?> get nullableType =>
      const $WifiManager$MulticastLock$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$MulticastLock$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$MulticastLock$Type$) &&
        other is $WifiManager$MulticastLock$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$ScanResultsCallback`
class WifiManager$ScanResultsCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$ScanResultsCallback> $type;

  @jni$_.internal
  WifiManager$ScanResultsCallback.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$ScanResultsCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$ScanResultsCallback?> nullableType =
      $WifiManager$ScanResultsCallback$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$ScanResultsCallback> type =
      $WifiManager$ScanResultsCallback$Type$();
  static final _id_onScanResultsAvailable = _class.instanceMethodId(
    r'onScanResultsAvailable',
    r'()V',
  );

  static final _onScanResultsAvailable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onScanResultsAvailable()`
  void onScanResultsAvailable() {
    _onScanResultsAvailable(
      reference.pointer,
      _id_onScanResultsAvailable as jni$_.JMethodIDPtr,
    ).check();
  }
}

final class $WifiManager$ScanResultsCallback$NullableType$
    extends jni$_.JType<WifiManager$ScanResultsCallback?> {
  @jni$_.internal
  const $WifiManager$ScanResultsCallback$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$ScanResultsCallback;';

  @jni$_.internal
  @core$_.override
  WifiManager$ScanResultsCallback? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiManager$ScanResultsCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$ScanResultsCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$ScanResultsCallback$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$ScanResultsCallback$NullableType$) &&
        other is $WifiManager$ScanResultsCallback$NullableType$;
  }
}

final class $WifiManager$ScanResultsCallback$Type$
    extends jni$_.JType<WifiManager$ScanResultsCallback> {
  @jni$_.internal
  const $WifiManager$ScanResultsCallback$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$ScanResultsCallback;';

  @jni$_.internal
  @core$_.override
  WifiManager$ScanResultsCallback fromReference(jni$_.JReference reference) =>
      WifiManager$ScanResultsCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$ScanResultsCallback?> get nullableType =>
      const $WifiManager$ScanResultsCallback$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$ScanResultsCallback$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$ScanResultsCallback$Type$) &&
        other is $WifiManager$ScanResultsCallback$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$SubsystemRestartTrackingCallback`
class WifiManager$SubsystemRestartTrackingCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$SubsystemRestartTrackingCallback> $type;

  @jni$_.internal
  WifiManager$SubsystemRestartTrackingCallback.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$SubsystemRestartTrackingCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$SubsystemRestartTrackingCallback?>
  nullableType = $WifiManager$SubsystemRestartTrackingCallback$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$SubsystemRestartTrackingCallback> type =
      $WifiManager$SubsystemRestartTrackingCallback$Type$();
  static final _id_onSubsystemRestarted = _class.instanceMethodId(
    r'onSubsystemRestarted',
    r'()V',
  );

  static final _onSubsystemRestarted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onSubsystemRestarted()`
  void onSubsystemRestarted() {
    _onSubsystemRestarted(
      reference.pointer,
      _id_onSubsystemRestarted as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_onSubsystemRestarting = _class.instanceMethodId(
    r'onSubsystemRestarting',
    r'()V',
  );

  static final _onSubsystemRestarting =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onSubsystemRestarting()`
  void onSubsystemRestarting() {
    _onSubsystemRestarting(
      reference.pointer,
      _id_onSubsystemRestarting as jni$_.JMethodIDPtr,
    ).check();
  }
}

final class $WifiManager$SubsystemRestartTrackingCallback$NullableType$
    extends jni$_.JType<WifiManager$SubsystemRestartTrackingCallback?> {
  @jni$_.internal
  const $WifiManager$SubsystemRestartTrackingCallback$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$SubsystemRestartTrackingCallback;';

  @jni$_.internal
  @core$_.override
  WifiManager$SubsystemRestartTrackingCallback? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : WifiManager$SubsystemRestartTrackingCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$SubsystemRestartTrackingCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$SubsystemRestartTrackingCallback$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$SubsystemRestartTrackingCallback$NullableType$) &&
        other is $WifiManager$SubsystemRestartTrackingCallback$NullableType$;
  }
}

final class $WifiManager$SubsystemRestartTrackingCallback$Type$
    extends jni$_.JType<WifiManager$SubsystemRestartTrackingCallback> {
  @jni$_.internal
  const $WifiManager$SubsystemRestartTrackingCallback$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$SubsystemRestartTrackingCallback;';

  @jni$_.internal
  @core$_.override
  WifiManager$SubsystemRestartTrackingCallback fromReference(
    jni$_.JReference reference,
  ) => WifiManager$SubsystemRestartTrackingCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$SubsystemRestartTrackingCallback?> get nullableType =>
      const $WifiManager$SubsystemRestartTrackingCallback$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$SubsystemRestartTrackingCallback$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$SubsystemRestartTrackingCallback$Type$) &&
        other is $WifiManager$SubsystemRestartTrackingCallback$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$SuggestionConnectionStatusListener`
class WifiManager$SuggestionConnectionStatusListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$SuggestionConnectionStatusListener> $type;

  @jni$_.internal
  WifiManager$SuggestionConnectionStatusListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$SuggestionConnectionStatusListener',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$SuggestionConnectionStatusListener?>
  nullableType =
      $WifiManager$SuggestionConnectionStatusListener$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$SuggestionConnectionStatusListener>
  type = $WifiManager$SuggestionConnectionStatusListener$Type$();
  static final _id_onConnectionStatus = _class.instanceMethodId(
    r'onConnectionStatus',
    r'(Landroid/net/wifi/WifiNetworkSuggestion;I)V',
  );

  static final _onConnectionStatus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void onConnectionStatus(android.net.wifi.WifiNetworkSuggestion wifiNetworkSuggestion, int i)`
  void onConnectionStatus(jni$_.JObject wifiNetworkSuggestion, int i) {
    final _$wifiNetworkSuggestion = wifiNetworkSuggestion.reference;
    _onConnectionStatus(
      reference.pointer,
      _id_onConnectionStatus as jni$_.JMethodIDPtr,
      _$wifiNetworkSuggestion.pointer,
      i,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $WifiManager$SuggestionConnectionStatusListener>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onConnectionStatus(Landroid/net/wifi/WifiNetworkSuggestion;I)V') {
        _$impls[$p]!.onConnectionStatus(
          $a![0]!.as(const jni$_.$JObject$Type$(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.$JInteger$Type$(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $WifiManager$SuggestionConnectionStatusListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'android.net.wifi.WifiManager$SuggestionConnectionStatusListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onConnectionStatus$async)
          r'onConnectionStatus(Landroid/net/wifi/WifiNetworkSuggestion;I)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory WifiManager$SuggestionConnectionStatusListener.implement(
    $WifiManager$SuggestionConnectionStatusListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return WifiManager$SuggestionConnectionStatusListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $WifiManager$SuggestionConnectionStatusListener {
  factory $WifiManager$SuggestionConnectionStatusListener({
    required void Function(jni$_.JObject wifiNetworkSuggestion, int i)
    onConnectionStatus,
    bool onConnectionStatus$async,
  }) = _$WifiManager$SuggestionConnectionStatusListener;

  void onConnectionStatus(jni$_.JObject wifiNetworkSuggestion, int i);
  bool get onConnectionStatus$async => false;
}

final class _$WifiManager$SuggestionConnectionStatusListener
    with $WifiManager$SuggestionConnectionStatusListener {
  _$WifiManager$SuggestionConnectionStatusListener({
    required void Function(jni$_.JObject wifiNetworkSuggestion, int i)
    onConnectionStatus,
    this.onConnectionStatus$async = false,
  }) : _onConnectionStatus = onConnectionStatus;

  final void Function(jni$_.JObject wifiNetworkSuggestion, int i)
  _onConnectionStatus;
  final bool onConnectionStatus$async;

  void onConnectionStatus(jni$_.JObject wifiNetworkSuggestion, int i) {
    return _onConnectionStatus(wifiNetworkSuggestion, i);
  }
}

final class $WifiManager$SuggestionConnectionStatusListener$NullableType$
    extends jni$_.JType<WifiManager$SuggestionConnectionStatusListener?> {
  @jni$_.internal
  const $WifiManager$SuggestionConnectionStatusListener$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$SuggestionConnectionStatusListener;';

  @jni$_.internal
  @core$_.override
  WifiManager$SuggestionConnectionStatusListener? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : WifiManager$SuggestionConnectionStatusListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$SuggestionConnectionStatusListener?>
  get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$SuggestionConnectionStatusListener$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$SuggestionConnectionStatusListener$NullableType$) &&
        other is $WifiManager$SuggestionConnectionStatusListener$NullableType$;
  }
}

final class $WifiManager$SuggestionConnectionStatusListener$Type$
    extends jni$_.JType<WifiManager$SuggestionConnectionStatusListener> {
  @jni$_.internal
  const $WifiManager$SuggestionConnectionStatusListener$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$SuggestionConnectionStatusListener;';

  @jni$_.internal
  @core$_.override
  WifiManager$SuggestionConnectionStatusListener fromReference(
    jni$_.JReference reference,
  ) => WifiManager$SuggestionConnectionStatusListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$SuggestionConnectionStatusListener?>
  get nullableType =>
      const $WifiManager$SuggestionConnectionStatusListener$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$SuggestionConnectionStatusListener$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$SuggestionConnectionStatusListener$Type$) &&
        other is $WifiManager$SuggestionConnectionStatusListener$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$SuggestionUserApprovalStatusListener`
class WifiManager$SuggestionUserApprovalStatusListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$SuggestionUserApprovalStatusListener> $type;

  @jni$_.internal
  WifiManager$SuggestionUserApprovalStatusListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$SuggestionUserApprovalStatusListener',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$SuggestionUserApprovalStatusListener?>
  nullableType =
      $WifiManager$SuggestionUserApprovalStatusListener$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$SuggestionUserApprovalStatusListener>
  type = $WifiManager$SuggestionUserApprovalStatusListener$Type$();
  static final _id_onUserApprovalStatusChange = _class.instanceMethodId(
    r'onUserApprovalStatusChange',
    r'(I)V',
  );

  static final _onUserApprovalStatusChange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void onUserApprovalStatusChange(int i)`
  void onUserApprovalStatusChange(int i) {
    _onUserApprovalStatusChange(
      reference.pointer,
      _id_onUserApprovalStatusChange as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<
    int,
    $WifiManager$SuggestionUserApprovalStatusListener
  >
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onUserApprovalStatusChange(I)V') {
        _$impls[$p]!.onUserApprovalStatusChange(
          $a![0]!
              .as(const jni$_.$JInteger$Type$(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $WifiManager$SuggestionUserApprovalStatusListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'android.net.wifi.WifiManager$SuggestionUserApprovalStatusListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onUserApprovalStatusChange$async)
          r'onUserApprovalStatusChange(I)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory WifiManager$SuggestionUserApprovalStatusListener.implement(
    $WifiManager$SuggestionUserApprovalStatusListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return WifiManager$SuggestionUserApprovalStatusListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $WifiManager$SuggestionUserApprovalStatusListener {
  factory $WifiManager$SuggestionUserApprovalStatusListener({
    required void Function(int i) onUserApprovalStatusChange,
    bool onUserApprovalStatusChange$async,
  }) = _$WifiManager$SuggestionUserApprovalStatusListener;

  void onUserApprovalStatusChange(int i);
  bool get onUserApprovalStatusChange$async => false;
}

final class _$WifiManager$SuggestionUserApprovalStatusListener
    with $WifiManager$SuggestionUserApprovalStatusListener {
  _$WifiManager$SuggestionUserApprovalStatusListener({
    required void Function(int i) onUserApprovalStatusChange,
    this.onUserApprovalStatusChange$async = false,
  }) : _onUserApprovalStatusChange = onUserApprovalStatusChange;

  final void Function(int i) _onUserApprovalStatusChange;
  final bool onUserApprovalStatusChange$async;

  void onUserApprovalStatusChange(int i) {
    return _onUserApprovalStatusChange(i);
  }
}

final class $WifiManager$SuggestionUserApprovalStatusListener$NullableType$
    extends jni$_.JType<WifiManager$SuggestionUserApprovalStatusListener?> {
  @jni$_.internal
  const $WifiManager$SuggestionUserApprovalStatusListener$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$SuggestionUserApprovalStatusListener;';

  @jni$_.internal
  @core$_.override
  WifiManager$SuggestionUserApprovalStatusListener? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : WifiManager$SuggestionUserApprovalStatusListener.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$SuggestionUserApprovalStatusListener?>
  get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$SuggestionUserApprovalStatusListener$NullableType$)
          .hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$SuggestionUserApprovalStatusListener$NullableType$) &&
        other
            is $WifiManager$SuggestionUserApprovalStatusListener$NullableType$;
  }
}

final class $WifiManager$SuggestionUserApprovalStatusListener$Type$
    extends jni$_.JType<WifiManager$SuggestionUserApprovalStatusListener> {
  @jni$_.internal
  const $WifiManager$SuggestionUserApprovalStatusListener$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$SuggestionUserApprovalStatusListener;';

  @jni$_.internal
  @core$_.override
  WifiManager$SuggestionUserApprovalStatusListener fromReference(
    jni$_.JReference reference,
  ) =>
      WifiManager$SuggestionUserApprovalStatusListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$SuggestionUserApprovalStatusListener?>
  get nullableType =>
      const $WifiManager$SuggestionUserApprovalStatusListener$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$SuggestionUserApprovalStatusListener$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$SuggestionUserApprovalStatusListener$Type$) &&
        other is $WifiManager$SuggestionUserApprovalStatusListener$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$WifiLock`
class WifiManager$WifiLock extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$WifiLock> $type;

  @jni$_.internal
  WifiManager$WifiLock.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$WifiLock',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$WifiLock?> nullableType =
      $WifiManager$WifiLock$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$WifiLock> type =
      $WifiManager$WifiLock$Type$();
  static final _id_acquire = _class.instanceMethodId(r'acquire', r'()V');

  static final _acquire =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void acquire()`
  void acquire() {
    _acquire(reference.pointer, _id_acquire as jni$_.JMethodIDPtr).check();
  }

  static final _id_isHeld = _class.instanceMethodId(r'isHeld', r'()Z');

  static final _isHeld =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isHeld()`
  bool isHeld() {
    return _isHeld(reference.pointer, _id_isHeld as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_release$1 = _class.instanceMethodId(r'release', r'()V');

  static final _release$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void release()`
  void release$1() {
    _release$1(reference.pointer, _id_release$1 as jni$_.JMethodIDPtr).check();
  }

  static final _id_setReferenceCounted = _class.instanceMethodId(
    r'setReferenceCounted',
    r'(Z)V',
  );

  static final _setReferenceCounted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReferenceCounted(boolean z)`
  void setReferenceCounted(bool z) {
    _setReferenceCounted(
      reference.pointer,
      _id_setReferenceCounted as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setWorkSource = _class.instanceMethodId(
    r'setWorkSource',
    r'(Landroid/os/WorkSource;)V',
  );

  static final _setWorkSource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setWorkSource(android.os.WorkSource workSource)`
  void setWorkSource(jni$_.JObject? workSource) {
    final _$workSource = workSource?.reference ?? jni$_.jNullReference;
    _setWorkSource(
      reference.pointer,
      _id_setWorkSource as jni$_.JMethodIDPtr,
      _$workSource.pointer,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $WifiManager$WifiLock$NullableType$
    extends jni$_.JType<WifiManager$WifiLock?> {
  @jni$_.internal
  const $WifiManager$WifiLock$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$WifiLock;';

  @jni$_.internal
  @core$_.override
  WifiManager$WifiLock? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : WifiManager$WifiLock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$WifiLock?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$WifiLock$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$WifiLock$NullableType$) &&
        other is $WifiManager$WifiLock$NullableType$;
  }
}

final class $WifiManager$WifiLock$Type$
    extends jni$_.JType<WifiManager$WifiLock> {
  @jni$_.internal
  const $WifiManager$WifiLock$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$WifiLock;';

  @jni$_.internal
  @core$_.override
  WifiManager$WifiLock fromReference(jni$_.JReference reference) =>
      WifiManager$WifiLock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$WifiLock?> get nullableType =>
      const $WifiManager$WifiLock$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$WifiLock$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$WifiLock$Type$) &&
        other is $WifiManager$WifiLock$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$WifiStateChangedListener`
class WifiManager$WifiStateChangedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$WifiStateChangedListener> $type;

  @jni$_.internal
  WifiManager$WifiStateChangedListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$WifiStateChangedListener',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$WifiStateChangedListener?> nullableType =
      $WifiManager$WifiStateChangedListener$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$WifiStateChangedListener> type =
      $WifiManager$WifiStateChangedListener$Type$();
  static final _id_onWifiStateChanged = _class.instanceMethodId(
    r'onWifiStateChanged',
    r'()V',
  );

  static final _onWifiStateChanged =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onWifiStateChanged()`
  void onWifiStateChanged() {
    _onWifiStateChanged(
      reference.pointer,
      _id_onWifiStateChanged as jni$_.JMethodIDPtr,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $WifiManager$WifiStateChangedListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onWifiStateChanged()V') {
        _$impls[$p]!.onWifiStateChanged();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $WifiManager$WifiStateChangedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'android.net.wifi.WifiManager$WifiStateChangedListener',
      $p,
      _$invokePointer,
      [if ($impl.onWifiStateChanged$async) r'onWifiStateChanged()V'],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory WifiManager$WifiStateChangedListener.implement(
    $WifiManager$WifiStateChangedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return WifiManager$WifiStateChangedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $WifiManager$WifiStateChangedListener {
  factory $WifiManager$WifiStateChangedListener({
    required void Function() onWifiStateChanged,
    bool onWifiStateChanged$async,
  }) = _$WifiManager$WifiStateChangedListener;

  void onWifiStateChanged();
  bool get onWifiStateChanged$async => false;
}

final class _$WifiManager$WifiStateChangedListener
    with $WifiManager$WifiStateChangedListener {
  _$WifiManager$WifiStateChangedListener({
    required void Function() onWifiStateChanged,
    this.onWifiStateChanged$async = false,
  }) : _onWifiStateChanged = onWifiStateChanged;

  final void Function() _onWifiStateChanged;
  final bool onWifiStateChanged$async;

  void onWifiStateChanged() {
    return _onWifiStateChanged();
  }
}

final class $WifiManager$WifiStateChangedListener$NullableType$
    extends jni$_.JType<WifiManager$WifiStateChangedListener?> {
  @jni$_.internal
  const $WifiManager$WifiStateChangedListener$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$WifiStateChangedListener;';

  @jni$_.internal
  @core$_.override
  WifiManager$WifiStateChangedListener? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : WifiManager$WifiStateChangedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$WifiStateChangedListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($WifiManager$WifiStateChangedListener$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WifiManager$WifiStateChangedListener$NullableType$) &&
        other is $WifiManager$WifiStateChangedListener$NullableType$;
  }
}

final class $WifiManager$WifiStateChangedListener$Type$
    extends jni$_.JType<WifiManager$WifiStateChangedListener> {
  @jni$_.internal
  const $WifiManager$WifiStateChangedListener$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/net/wifi/WifiManager$WifiStateChangedListener;';

  @jni$_.internal
  @core$_.override
  WifiManager$WifiStateChangedListener fromReference(
    jni$_.JReference reference,
  ) => WifiManager$WifiStateChangedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$WifiStateChangedListener?> get nullableType =>
      const $WifiManager$WifiStateChangedListener$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$WifiStateChangedListener$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$WifiStateChangedListener$Type$) &&
        other is $WifiManager$WifiStateChangedListener$Type$;
  }
}

/// from: `android.net.wifi.WifiManager$WpsCallback`
class WifiManager$WpsCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager$WpsCallback> $type;

  @jni$_.internal
  WifiManager$WpsCallback.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/net/wifi/WifiManager$WpsCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$WpsCallback?> nullableType =
      $WifiManager$WpsCallback$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager$WpsCallback> type =
      $WifiManager$WpsCallback$Type$();
  static final _id_onFailed = _class.instanceMethodId(r'onFailed', r'(I)V');

  static final _onFailed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void onFailed(int i)`
  void onFailed(int i) {
    _onFailed(reference.pointer, _id_onFailed as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_onStarted = _class.instanceMethodId(
    r'onStarted',
    r'(Ljava/lang/String;)V',
  );

  static final _onStarted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onStarted(java.lang.String string)`
  void onStarted(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onStarted(
      reference.pointer,
      _id_onStarted as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_onSucceeded = _class.instanceMethodId(
    r'onSucceeded',
    r'()V',
  );

  static final _onSucceeded =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onSucceeded()`
  void onSucceeded() {
    _onSucceeded(
      reference.pointer,
      _id_onSucceeded as jni$_.JMethodIDPtr,
    ).check();
  }
}

final class $WifiManager$WpsCallback$NullableType$
    extends jni$_.JType<WifiManager$WpsCallback?> {
  @jni$_.internal
  const $WifiManager$WpsCallback$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$WpsCallback;';

  @jni$_.internal
  @core$_.override
  WifiManager$WpsCallback? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : WifiManager$WpsCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$WpsCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$WpsCallback$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$WpsCallback$NullableType$) &&
        other is $WifiManager$WpsCallback$NullableType$;
  }
}

final class $WifiManager$WpsCallback$Type$
    extends jni$_.JType<WifiManager$WpsCallback> {
  @jni$_.internal
  const $WifiManager$WpsCallback$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager$WpsCallback;';

  @jni$_.internal
  @core$_.override
  WifiManager$WpsCallback fromReference(jni$_.JReference reference) =>
      WifiManager$WpsCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager$WpsCallback?> get nullableType =>
      const $WifiManager$WpsCallback$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$WpsCallback$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$WpsCallback$Type$) &&
        other is $WifiManager$WpsCallback$Type$;
  }
}

/// from: `android.net.wifi.WifiManager`
class WifiManager extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<WifiManager> $type;

  @jni$_.internal
  WifiManager.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/net/wifi/WifiManager');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager?> nullableType =
      $WifiManager$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<WifiManager> type = $WifiManager$Type$();
  static final _id_ACTION_PICK_WIFI_NETWORK = _class.staticFieldId(
    r'ACTION_PICK_WIFI_NETWORK',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_PICK_WIFI_NETWORK`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_PICK_WIFI_NETWORK =>
      _id_ACTION_PICK_WIFI_NETWORK.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  /// from: `static public final int ACTION_REMOVE_SUGGESTION_DISCONNECT`
  static const ACTION_REMOVE_SUGGESTION_DISCONNECT = 2;

  /// from: `static public final int ACTION_REMOVE_SUGGESTION_LINGER`
  static const ACTION_REMOVE_SUGGESTION_LINGER = 1;
  static final _id_ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE = _class.staticFieldId(
    r'ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE =>
      _id_ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION = _class
      .staticFieldId(
        r'ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION',
        r'Ljava/lang/String;',
      );

  /// from: `static public final java.lang.String ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION =>
      _id_ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_ACTION_WIFI_SCAN_AVAILABILITY_CHANGED = _class.staticFieldId(
    r'ACTION_WIFI_SCAN_AVAILABILITY_CHANGED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_WIFI_SCAN_AVAILABILITY_CHANGED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_WIFI_SCAN_AVAILABILITY_CHANGED =>
      _id_ACTION_WIFI_SCAN_AVAILABILITY_CHANGED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_CHANNEL_DATA_KEY_FREQUENCY_MHZ = _class.staticFieldId(
    r'CHANNEL_DATA_KEY_FREQUENCY_MHZ',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CHANNEL_DATA_KEY_FREQUENCY_MHZ`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CHANNEL_DATA_KEY_FREQUENCY_MHZ =>
      _id_CHANNEL_DATA_KEY_FREQUENCY_MHZ.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_CHANNEL_DATA_KEY_NUM_AP = _class.staticFieldId(
    r'CHANNEL_DATA_KEY_NUM_AP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CHANNEL_DATA_KEY_NUM_AP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CHANNEL_DATA_KEY_NUM_AP =>
      _id_CHANNEL_DATA_KEY_NUM_AP.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  /// from: `static public final int ERROR_AUTHENTICATING`
  static const ERROR_AUTHENTICATING = 1;
  static final _id_EXTRA_BSSID = _class.staticFieldId(
    r'EXTRA_BSSID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_BSSID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_BSSID =>
      _id_EXTRA_BSSID.get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_NETWORK_INFO = _class.staticFieldId(
    r'EXTRA_NETWORK_INFO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_NETWORK_INFO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_NETWORK_INFO =>
      _id_EXTRA_NETWORK_INFO.get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_NETWORK_SUGGESTION = _class.staticFieldId(
    r'EXTRA_NETWORK_SUGGESTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_NETWORK_SUGGESTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_NETWORK_SUGGESTION =>
      _id_EXTRA_NETWORK_SUGGESTION.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_EXTRA_NEW_RSSI = _class.staticFieldId(
    r'EXTRA_NEW_RSSI',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_NEW_RSSI`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_NEW_RSSI =>
      _id_EXTRA_NEW_RSSI.get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_NEW_STATE = _class.staticFieldId(
    r'EXTRA_NEW_STATE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_NEW_STATE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_NEW_STATE =>
      _id_EXTRA_NEW_STATE.get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_PREVIOUS_WIFI_STATE = _class.staticFieldId(
    r'EXTRA_PREVIOUS_WIFI_STATE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_PREVIOUS_WIFI_STATE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_PREVIOUS_WIFI_STATE =>
      _id_EXTRA_PREVIOUS_WIFI_STATE.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_EXTRA_RESULTS_UPDATED = _class.staticFieldId(
    r'EXTRA_RESULTS_UPDATED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_RESULTS_UPDATED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_RESULTS_UPDATED => _id_EXTRA_RESULTS_UPDATED
      .get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_SCAN_AVAILABLE = _class.staticFieldId(
    r'EXTRA_SCAN_AVAILABLE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_SCAN_AVAILABLE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_SCAN_AVAILABLE => _id_EXTRA_SCAN_AVAILABLE
      .get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_SUPPLICANT_CONNECTED = _class.staticFieldId(
    r'EXTRA_SUPPLICANT_CONNECTED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_SUPPLICANT_CONNECTED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_SUPPLICANT_CONNECTED =>
      _id_EXTRA_SUPPLICANT_CONNECTED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_EXTRA_SUPPLICANT_ERROR = _class.staticFieldId(
    r'EXTRA_SUPPLICANT_ERROR',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_SUPPLICANT_ERROR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_SUPPLICANT_ERROR => _id_EXTRA_SUPPLICANT_ERROR
      .get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_WIFI_INFO = _class.staticFieldId(
    r'EXTRA_WIFI_INFO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_WIFI_INFO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_WIFI_INFO =>
      _id_EXTRA_WIFI_INFO.get(_class, const jni$_.$JString$NullableType$());

  static final _id_EXTRA_WIFI_STATE = _class.staticFieldId(
    r'EXTRA_WIFI_STATE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_WIFI_STATE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_WIFI_STATE =>
      _id_EXTRA_WIFI_STATE.get(_class, const jni$_.$JString$NullableType$());

  /// from: `static public final int FLAG_SEND_DHCP_HOSTNAME_RESTRICTION_OPEN`
  static const FLAG_SEND_DHCP_HOSTNAME_RESTRICTION_OPEN = 1;

  /// from: `static public final int FLAG_SEND_DHCP_HOSTNAME_RESTRICTION_SECURE`
  static const FLAG_SEND_DHCP_HOSTNAME_RESTRICTION_SECURE = 2;
  static final _id_NETWORK_IDS_CHANGED_ACTION = _class.staticFieldId(
    r'NETWORK_IDS_CHANGED_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NETWORK_IDS_CHANGED_ACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NETWORK_IDS_CHANGED_ACTION =>
      _id_NETWORK_IDS_CHANGED_ACTION.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_NETWORK_STATE_CHANGED_ACTION = _class.staticFieldId(
    r'NETWORK_STATE_CHANGED_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NETWORK_STATE_CHANGED_ACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NETWORK_STATE_CHANGED_ACTION =>
      _id_NETWORK_STATE_CHANGED_ACTION.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  /// from: `static public final int ROAMING_MODE_AGGRESSIVE`
  static const ROAMING_MODE_AGGRESSIVE = 2;

  /// from: `static public final int ROAMING_MODE_NONE`
  static const ROAMING_MODE_NONE = 0;

  /// from: `static public final int ROAMING_MODE_NORMAL`
  static const ROAMING_MODE_NORMAL = 1;
  static final _id_RSSI_CHANGED_ACTION = _class.staticFieldId(
    r'RSSI_CHANGED_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RSSI_CHANGED_ACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RSSI_CHANGED_ACTION =>
      _id_RSSI_CHANGED_ACTION.get(_class, const jni$_.$JString$NullableType$());

  static final _id_SCAN_RESULTS_AVAILABLE_ACTION = _class.staticFieldId(
    r'SCAN_RESULTS_AVAILABLE_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SCAN_RESULTS_AVAILABLE_ACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SCAN_RESULTS_AVAILABLE_ACTION =>
      _id_SCAN_RESULTS_AVAILABLE_ACTION.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  /// from: `static public final int STATUS_LOCAL_ONLY_CONNECTION_FAILURE_ASSOCIATION`
  static const STATUS_LOCAL_ONLY_CONNECTION_FAILURE_ASSOCIATION = 1;

  /// from: `static public final int STATUS_LOCAL_ONLY_CONNECTION_FAILURE_AUTHENTICATION`
  static const STATUS_LOCAL_ONLY_CONNECTION_FAILURE_AUTHENTICATION = 2;

  /// from: `static public final int STATUS_LOCAL_ONLY_CONNECTION_FAILURE_IP_PROVISIONING`
  static const STATUS_LOCAL_ONLY_CONNECTION_FAILURE_IP_PROVISIONING = 3;

  /// from: `static public final int STATUS_LOCAL_ONLY_CONNECTION_FAILURE_NOT_FOUND`
  static const STATUS_LOCAL_ONLY_CONNECTION_FAILURE_NOT_FOUND = 4;

  /// from: `static public final int STATUS_LOCAL_ONLY_CONNECTION_FAILURE_NO_RESPONSE`
  static const STATUS_LOCAL_ONLY_CONNECTION_FAILURE_NO_RESPONSE = 5;

  /// from: `static public final int STATUS_LOCAL_ONLY_CONNECTION_FAILURE_UNKNOWN`
  static const STATUS_LOCAL_ONLY_CONNECTION_FAILURE_UNKNOWN = 0;

  /// from: `static public final int STATUS_LOCAL_ONLY_CONNECTION_FAILURE_USER_REJECT`
  static const STATUS_LOCAL_ONLY_CONNECTION_FAILURE_USER_REJECT = 6;

  /// from: `static public final int STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_DUPLICATE`
  static const STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_DUPLICATE = 3;

  /// from: `static public final int STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_EXCEEDS_MAX_PER_APP`
  static const STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_EXCEEDS_MAX_PER_APP = 4;

  /// from: `static public final int STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_INVALID`
  static const STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_INVALID = 7;

  /// from: `static public final int STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_NOT_ALLOWED`
  static const STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_NOT_ALLOWED = 6;

  /// from: `static public final int STATUS_NETWORK_SUGGESTIONS_ERROR_APP_DISALLOWED`
  static const STATUS_NETWORK_SUGGESTIONS_ERROR_APP_DISALLOWED = 2;

  /// from: `static public final int STATUS_NETWORK_SUGGESTIONS_ERROR_INTERNAL`
  static const STATUS_NETWORK_SUGGESTIONS_ERROR_INTERNAL = 1;

  /// from: `static public final int STATUS_NETWORK_SUGGESTIONS_ERROR_REMOVE_INVALID`
  static const STATUS_NETWORK_SUGGESTIONS_ERROR_REMOVE_INVALID = 5;

  /// from: `static public final int STATUS_NETWORK_SUGGESTIONS_ERROR_RESTRICTED_BY_ADMIN`
  static const STATUS_NETWORK_SUGGESTIONS_ERROR_RESTRICTED_BY_ADMIN = 8;

  /// from: `static public final int STATUS_NETWORK_SUGGESTIONS_SUCCESS`
  static const STATUS_NETWORK_SUGGESTIONS_SUCCESS = 0;

  /// from: `static public final int STATUS_SUGGESTION_APPROVAL_APPROVED_BY_CARRIER_PRIVILEGE`
  static const STATUS_SUGGESTION_APPROVAL_APPROVED_BY_CARRIER_PRIVILEGE = 4;

  /// from: `static public final int STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER`
  static const STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER = 2;

  /// from: `static public final int STATUS_SUGGESTION_APPROVAL_PENDING`
  static const STATUS_SUGGESTION_APPROVAL_PENDING = 1;

  /// from: `static public final int STATUS_SUGGESTION_APPROVAL_REJECTED_BY_USER`
  static const STATUS_SUGGESTION_APPROVAL_REJECTED_BY_USER = 3;

  /// from: `static public final int STATUS_SUGGESTION_APPROVAL_UNKNOWN`
  static const STATUS_SUGGESTION_APPROVAL_UNKNOWN = 0;

  /// from: `static public final int STATUS_SUGGESTION_CONNECTION_FAILURE_ASSOCIATION`
  static const STATUS_SUGGESTION_CONNECTION_FAILURE_ASSOCIATION = 1;

  /// from: `static public final int STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION`
  static const STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION = 2;

  /// from: `static public final int STATUS_SUGGESTION_CONNECTION_FAILURE_IP_PROVISIONING`
  static const STATUS_SUGGESTION_CONNECTION_FAILURE_IP_PROVISIONING = 3;

  /// from: `static public final int STATUS_SUGGESTION_CONNECTION_FAILURE_UNKNOWN`
  static const STATUS_SUGGESTION_CONNECTION_FAILURE_UNKNOWN = 0;
  static final _id_SUPPLICANT_CONNECTION_CHANGE_ACTION = _class.staticFieldId(
    r'SUPPLICANT_CONNECTION_CHANGE_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SUPPLICANT_CONNECTION_CHANGE_ACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SUPPLICANT_CONNECTION_CHANGE_ACTION =>
      _id_SUPPLICANT_CONNECTION_CHANGE_ACTION.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_SUPPLICANT_STATE_CHANGED_ACTION = _class.staticFieldId(
    r'SUPPLICANT_STATE_CHANGED_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SUPPLICANT_STATE_CHANGED_ACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SUPPLICANT_STATE_CHANGED_ACTION =>
      _id_SUPPLICANT_STATE_CHANGED_ACTION.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_UNKNOWN_SSID = _class.staticFieldId(
    r'UNKNOWN_SSID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String UNKNOWN_SSID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get UNKNOWN_SSID =>
      _id_UNKNOWN_SSID.get(_class, const jni$_.$JString$NullableType$());

  /// from: `static public final int WIFI_INTERFACE_TYPE_AP`
  static const WIFI_INTERFACE_TYPE_AP = 1;

  /// from: `static public final int WIFI_INTERFACE_TYPE_AWARE`
  static const WIFI_INTERFACE_TYPE_AWARE = 2;

  /// from: `static public final int WIFI_INTERFACE_TYPE_DIRECT`
  static const WIFI_INTERFACE_TYPE_DIRECT = 3;

  /// from: `static public final int WIFI_INTERFACE_TYPE_STA`
  static const WIFI_INTERFACE_TYPE_STA = 0;

  /// from: `static public final int WIFI_MODE_FULL`
  static const WIFI_MODE_FULL = 1;

  /// from: `static public final int WIFI_MODE_FULL_HIGH_PERF`
  static const WIFI_MODE_FULL_HIGH_PERF = 3;

  /// from: `static public final int WIFI_MODE_FULL_LOW_LATENCY`
  static const WIFI_MODE_FULL_LOW_LATENCY = 4;

  /// from: `static public final int WIFI_MODE_SCAN_ONLY`
  static const WIFI_MODE_SCAN_ONLY = 2;

  /// from: `static public final int WIFI_MULTI_INTERNET_MODE_DBS_AP`
  static const WIFI_MULTI_INTERNET_MODE_DBS_AP = 1;

  /// from: `static public final int WIFI_MULTI_INTERNET_MODE_DISABLED`
  static const WIFI_MULTI_INTERNET_MODE_DISABLED = 0;

  /// from: `static public final int WIFI_MULTI_INTERNET_MODE_MULTI_AP`
  static const WIFI_MULTI_INTERNET_MODE_MULTI_AP = 2;
  static final _id_WIFI_STATE_CHANGED_ACTION = _class.staticFieldId(
    r'WIFI_STATE_CHANGED_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WIFI_STATE_CHANGED_ACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WIFI_STATE_CHANGED_ACTION =>
      _id_WIFI_STATE_CHANGED_ACTION.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  /// from: `static public final int WIFI_STATE_DISABLED`
  static const WIFI_STATE_DISABLED = 1;

  /// from: `static public final int WIFI_STATE_DISABLING`
  static const WIFI_STATE_DISABLING = 0;

  /// from: `static public final int WIFI_STATE_ENABLED`
  static const WIFI_STATE_ENABLED = 3;

  /// from: `static public final int WIFI_STATE_ENABLING`
  static const WIFI_STATE_ENABLING = 2;

  /// from: `static public final int WIFI_STATE_UNKNOWN`
  static const WIFI_STATE_UNKNOWN = 4;

  /// from: `static public final int WPS_AUTH_FAILURE`
  static const WPS_AUTH_FAILURE = 6;

  /// from: `static public final int WPS_OVERLAP_ERROR`
  static const WPS_OVERLAP_ERROR = 3;

  /// from: `static public final int WPS_TIMED_OUT`
  static const WPS_TIMED_OUT = 7;

  /// from: `static public final int WPS_TKIP_ONLY_PROHIBITED`
  static const WPS_TKIP_ONLY_PROHIBITED = 5;

  /// from: `static public final int WPS_WEP_PROHIBITED`
  static const WPS_WEP_PROHIBITED = 4;
  static final _id_addLocalOnlyConnectionFailureListener = _class.instanceMethodId(
    r'addLocalOnlyConnectionFailureListener',
    r'(Ljava/util/concurrent/Executor;Landroid/net/wifi/WifiManager$LocalOnlyConnectionFailureListener;)V',
  );

  static final _addLocalOnlyConnectionFailureListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addLocalOnlyConnectionFailureListener(java.util.concurrent.Executor executor, android.net.wifi.WifiManager$LocalOnlyConnectionFailureListener localOnlyConnectionFailureListener)`
  void addLocalOnlyConnectionFailureListener(
    executor$_.Executor executor,
    WifiManager$LocalOnlyConnectionFailureListener
    localOnlyConnectionFailureListener,
  ) {
    final _$executor = executor.reference;
    final _$localOnlyConnectionFailureListener =
        localOnlyConnectionFailureListener.reference;
    _addLocalOnlyConnectionFailureListener(
      reference.pointer,
      _id_addLocalOnlyConnectionFailureListener as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$localOnlyConnectionFailureListener.pointer,
    ).check();
  }

  static final _id_addNetwork = _class.instanceMethodId(
    r'addNetwork',
    r'(Landroid/net/wifi/WifiConfiguration;)I',
  );

  static final _addNetwork =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int addNetwork(android.net.wifi.WifiConfiguration wifiConfiguration)`
  int addNetwork(wificonfiguration$_.WifiConfiguration? wifiConfiguration) {
    final _$wifiConfiguration =
        wifiConfiguration?.reference ?? jni$_.jNullReference;
    return _addNetwork(
      reference.pointer,
      _id_addNetwork as jni$_.JMethodIDPtr,
      _$wifiConfiguration.pointer,
    ).integer;
  }

  static final _id_addNetworkPrivileged = _class.instanceMethodId(
    r'addNetworkPrivileged',
    r'(Landroid/net/wifi/WifiConfiguration;)Landroid/net/wifi/WifiManager$AddNetworkResult;',
  );

  static final _addNetworkPrivileged =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.net.wifi.WifiManager$AddNetworkResult addNetworkPrivileged(android.net.wifi.WifiConfiguration wifiConfiguration)`
  /// The returned object must be released after use, by calling the [release] method.
  WifiManager$AddNetworkResult addNetworkPrivileged(
    wificonfiguration$_.WifiConfiguration wifiConfiguration,
  ) {
    final _$wifiConfiguration = wifiConfiguration.reference;
    return _addNetworkPrivileged(
      reference.pointer,
      _id_addNetworkPrivileged as jni$_.JMethodIDPtr,
      _$wifiConfiguration.pointer,
    ).object<WifiManager$AddNetworkResult>(
      const $WifiManager$AddNetworkResult$Type$(),
    );
  }

  static final _id_addNetworkSuggestions = _class.instanceMethodId(
    r'addNetworkSuggestions',
    r'(Ljava/util/List;)I',
  );

  static final _addNetworkSuggestions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int addNetworkSuggestions(java.util.List<android.net.wifi.WifiNetworkSuggestion> list)`
  int addNetworkSuggestions(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _addNetworkSuggestions(
      reference.pointer,
      _id_addNetworkSuggestions as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).integer;
  }

  static final _id_addOrUpdatePasspointConfiguration = _class.instanceMethodId(
    r'addOrUpdatePasspointConfiguration',
    r'(Landroid/net/wifi/hotspot2/PasspointConfiguration;)V',
  );

  static final _addOrUpdatePasspointConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOrUpdatePasspointConfiguration(android.net.wifi.hotspot2.PasspointConfiguration passpointConfiguration)`
  void addOrUpdatePasspointConfiguration(
    jni$_.JObject? passpointConfiguration,
  ) {
    final _$passpointConfiguration =
        passpointConfiguration?.reference ?? jni$_.jNullReference;
    _addOrUpdatePasspointConfiguration(
      reference.pointer,
      _id_addOrUpdatePasspointConfiguration as jni$_.JMethodIDPtr,
      _$passpointConfiguration.pointer,
    ).check();
  }

  static final _id_addSuggestionConnectionStatusListener = _class.instanceMethodId(
    r'addSuggestionConnectionStatusListener',
    r'(Ljava/util/concurrent/Executor;Landroid/net/wifi/WifiManager$SuggestionConnectionStatusListener;)V',
  );

  static final _addSuggestionConnectionStatusListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addSuggestionConnectionStatusListener(java.util.concurrent.Executor executor, android.net.wifi.WifiManager$SuggestionConnectionStatusListener suggestionConnectionStatusListener)`
  void addSuggestionConnectionStatusListener(
    executor$_.Executor executor,
    WifiManager$SuggestionConnectionStatusListener
    suggestionConnectionStatusListener,
  ) {
    final _$executor = executor.reference;
    final _$suggestionConnectionStatusListener =
        suggestionConnectionStatusListener.reference;
    _addSuggestionConnectionStatusListener(
      reference.pointer,
      _id_addSuggestionConnectionStatusListener as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$suggestionConnectionStatusListener.pointer,
    ).check();
  }

  static final _id_addSuggestionUserApprovalStatusListener = _class
      .instanceMethodId(
        r'addSuggestionUserApprovalStatusListener',
        r'(Ljava/util/concurrent/Executor;Landroid/net/wifi/WifiManager$SuggestionUserApprovalStatusListener;)V',
      );

  static final _addSuggestionUserApprovalStatusListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addSuggestionUserApprovalStatusListener(java.util.concurrent.Executor executor, android.net.wifi.WifiManager$SuggestionUserApprovalStatusListener suggestionUserApprovalStatusListener)`
  void addSuggestionUserApprovalStatusListener(
    executor$_.Executor executor,
    WifiManager$SuggestionUserApprovalStatusListener
    suggestionUserApprovalStatusListener,
  ) {
    final _$executor = executor.reference;
    final _$suggestionUserApprovalStatusListener =
        suggestionUserApprovalStatusListener.reference;
    _addSuggestionUserApprovalStatusListener(
      reference.pointer,
      _id_addSuggestionUserApprovalStatusListener as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$suggestionUserApprovalStatusListener.pointer,
    ).check();
  }

  static final _id_addWifiStateChangedListener = _class.instanceMethodId(
    r'addWifiStateChangedListener',
    r'(Ljava/util/concurrent/Executor;Landroid/net/wifi/WifiManager$WifiStateChangedListener;)V',
  );

  static final _addWifiStateChangedListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addWifiStateChangedListener(java.util.concurrent.Executor executor, android.net.wifi.WifiManager$WifiStateChangedListener wifiStateChangedListener)`
  void addWifiStateChangedListener(
    executor$_.Executor executor,
    WifiManager$WifiStateChangedListener wifiStateChangedListener,
  ) {
    final _$executor = executor.reference;
    final _$wifiStateChangedListener = wifiStateChangedListener.reference;
    _addWifiStateChangedListener(
      reference.pointer,
      _id_addWifiStateChangedListener as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$wifiStateChangedListener.pointer,
    ).check();
  }

  static final _id_allowAutojoinGlobal = _class.instanceMethodId(
    r'allowAutojoinGlobal',
    r'(Z)V',
  );

  static final _allowAutojoinGlobal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void allowAutojoinGlobal(boolean z)`
  void allowAutojoinGlobal(bool z) {
    _allowAutojoinGlobal(
      reference.pointer,
      _id_allowAutojoinGlobal as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_calculateSignalLevel = _class.instanceMethodId(
    r'calculateSignalLevel',
    r'(I)I',
  );

  static final _calculateSignalLevel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int calculateSignalLevel(int i)`
  int calculateSignalLevel(int i) {
    return _calculateSignalLevel(
      reference.pointer,
      _id_calculateSignalLevel as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_calculateSignalLevel$1 = _class.staticMethodId(
    r'calculateSignalLevel',
    r'(II)I',
  );

  static final _calculateSignalLevel$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public int calculateSignalLevel(int i, int i1)`
  static int calculateSignalLevel$1(int i, int i1) {
    return _calculateSignalLevel$1(
      _class.reference.pointer,
      _id_calculateSignalLevel$1 as jni$_.JMethodIDPtr,
      i,
      i1,
    ).integer;
  }

  static final _id_cancelWps = _class.instanceMethodId(
    r'cancelWps',
    r'(Landroid/net/wifi/WifiManager$WpsCallback;)V',
  );

  static final _cancelWps =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void cancelWps(android.net.wifi.WifiManager$WpsCallback wpsCallback)`
  void cancelWps(WifiManager$WpsCallback? wpsCallback) {
    final _$wpsCallback = wpsCallback?.reference ?? jni$_.jNullReference;
    _cancelWps(
      reference.pointer,
      _id_cancelWps as jni$_.JMethodIDPtr,
      _$wpsCallback.pointer,
    ).check();
  }

  static final _id_compareSignalLevel = _class.staticMethodId(
    r'compareSignalLevel',
    r'(II)I',
  );

  static final _compareSignalLevel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public int compareSignalLevel(int i, int i1)`
  static int compareSignalLevel(int i, int i1) {
    return _compareSignalLevel(
      _class.reference.pointer,
      _id_compareSignalLevel as jni$_.JMethodIDPtr,
      i,
      i1,
    ).integer;
  }

  static final _id_createMulticastLock = _class.instanceMethodId(
    r'createMulticastLock',
    r'(Ljava/lang/String;)Landroid/net/wifi/WifiManager$MulticastLock;',
  );

  static final _createMulticastLock =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.net.wifi.WifiManager$MulticastLock createMulticastLock(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  WifiManager$MulticastLock? createMulticastLock(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createMulticastLock(
      reference.pointer,
      _id_createMulticastLock as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<WifiManager$MulticastLock?>(
      const $WifiManager$MulticastLock$NullableType$(),
    );
  }

  static final _id_createWifiLock = _class.instanceMethodId(
    r'createWifiLock',
    r'(ILjava/lang/String;)Landroid/net/wifi/WifiManager$WifiLock;',
  );

  static final _createWifiLock =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.net.wifi.WifiManager$WifiLock createWifiLock(int i, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  WifiManager$WifiLock? createWifiLock(int i, jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createWifiLock(
      reference.pointer,
      _id_createWifiLock as jni$_.JMethodIDPtr,
      i,
      _$string.pointer,
    ).object<WifiManager$WifiLock?>(
      const $WifiManager$WifiLock$NullableType$(),
    );
  }

  static final _id_createWifiLock$1 = _class.instanceMethodId(
    r'createWifiLock',
    r'(Ljava/lang/String;)Landroid/net/wifi/WifiManager$WifiLock;',
  );

  static final _createWifiLock$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.net.wifi.WifiManager$WifiLock createWifiLock(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  WifiManager$WifiLock? createWifiLock$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createWifiLock$1(
      reference.pointer,
      _id_createWifiLock$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<WifiManager$WifiLock?>(
      const $WifiManager$WifiLock$NullableType$(),
    );
  }

  static final _id_disableNetwork = _class.instanceMethodId(
    r'disableNetwork',
    r'(I)Z',
  );

  static final _disableNetwork =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean disableNetwork(int i)`
  bool disableNetwork(int i) {
    return _disableNetwork(
      reference.pointer,
      _id_disableNetwork as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_disallowCurrentSuggestedNetwork = _class.instanceMethodId(
    r'disallowCurrentSuggestedNetwork',
    r'(Landroid/net/wifi/BlockingOption;)V',
  );

  static final _disallowCurrentSuggestedNetwork =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void disallowCurrentSuggestedNetwork(android.net.wifi.BlockingOption blockingOption)`
  void disallowCurrentSuggestedNetwork(jni$_.JObject blockingOption) {
    final _$blockingOption = blockingOption.reference;
    _disallowCurrentSuggestedNetwork(
      reference.pointer,
      _id_disallowCurrentSuggestedNetwork as jni$_.JMethodIDPtr,
      _$blockingOption.pointer,
    ).check();
  }

  static final _id_disconnect = _class.instanceMethodId(r'disconnect', r'()Z');

  static final _disconnect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean disconnect()`
  bool disconnect() {
    return _disconnect(
      reference.pointer,
      _id_disconnect as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_enableNetwork = _class.instanceMethodId(
    r'enableNetwork',
    r'(IZ)Z',
  );

  static final _enableNetwork =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean enableNetwork(int i, boolean z)`
  bool enableNetwork(int i, bool z) {
    return _enableNetwork(
      reference.pointer,
      _id_enableNetwork as jni$_.JMethodIDPtr,
      i,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_flushPasspointAnqpCache = _class.instanceMethodId(
    r'flushPasspointAnqpCache',
    r'()V',
  );

  static final _flushPasspointAnqpCache =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flushPasspointAnqpCache()`
  void flushPasspointAnqpCache() {
    _flushPasspointAnqpCache(
      reference.pointer,
      _id_flushPasspointAnqpCache as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_getAllowedChannels = _class.instanceMethodId(
    r'getAllowedChannels',
    r'(II)Ljava/util/List;',
  );

  static final _getAllowedChannels =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public java.util.List<android.net.wifi.WifiAvailableChannel> getAllowedChannels(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getAllowedChannels(int i, int i1) {
    return _getAllowedChannels(
      reference.pointer,
      _id_getAllowedChannels as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getCallerConfiguredNetworks = _class.instanceMethodId(
    r'getCallerConfiguredNetworks',
    r'()Ljava/util/List;',
  );

  static final _getCallerConfiguredNetworks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.net.wifi.WifiConfiguration> getCallerConfiguredNetworks()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<wificonfiguration$_.WifiConfiguration?>
  getCallerConfiguredNetworks() {
    return _getCallerConfiguredNetworks(
      reference.pointer,
      _id_getCallerConfiguredNetworks as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<wificonfiguration$_.WifiConfiguration?>>(
      const jni$_.$JList$Type$<wificonfiguration$_.WifiConfiguration?>(
        wificonfiguration$_.$WifiConfiguration$NullableType$(),
      ),
    );
  }

  static final _id_getChannelData = _class.instanceMethodId(
    r'getChannelData',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
  );

  static final _getChannelData =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getChannelData(java.util.concurrent.Executor executor, java.util.function.Consumer<java.util.List<android.os.Bundle>> consumer)`
  void getChannelData(executor$_.Executor executor, jni$_.JObject consumer) {
    final _$executor = executor.reference;
    final _$consumer = consumer.reference;
    _getChannelData(
      reference.pointer,
      _id_getChannelData as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$consumer.pointer,
    ).check();
  }

  static final _id_getConfiguredNetworks = _class.instanceMethodId(
    r'getConfiguredNetworks',
    r'()Ljava/util/List;',
  );

  static final _getConfiguredNetworks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.net.wifi.WifiConfiguration> getConfiguredNetworks()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<wificonfiguration$_.WifiConfiguration?>? getConfiguredNetworks() {
    return _getConfiguredNetworks(
      reference.pointer,
      _id_getConfiguredNetworks as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<wificonfiguration$_.WifiConfiguration?>?>(
      const jni$_.$JList$NullableType$<wificonfiguration$_.WifiConfiguration?>(
        wificonfiguration$_.$WifiConfiguration$NullableType$(),
      ),
    );
  }

  static final _id_getConnectionInfo = _class.instanceMethodId(
    r'getConnectionInfo',
    r'()Landroid/net/wifi/WifiInfo;',
  );

  static final _getConnectionInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.wifi.WifiInfo getConnectionInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  wifiinfo$_.WifiInfo? getConnectionInfo() {
    return _getConnectionInfo(
      reference.pointer,
      _id_getConnectionInfo as jni$_.JMethodIDPtr,
    ).object<wifiinfo$_.WifiInfo?>(const wifiinfo$_.$WifiInfo$NullableType$());
  }

  static final _id_getDhcpInfo = _class.instanceMethodId(
    r'getDhcpInfo',
    r'()Landroid/net/DhcpInfo;',
  );

  static final _getDhcpInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.DhcpInfo getDhcpInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  dhcpinfo$_.DhcpInfo? getDhcpInfo() {
    return _getDhcpInfo(
      reference.pointer,
      _id_getDhcpInfo as jni$_.JMethodIDPtr,
    ).object<dhcpinfo$_.DhcpInfo?>(const dhcpinfo$_.$DhcpInfo$NullableType$());
  }

  static final _id_getMaxNumberOfChannelsPerNetworkSpecifierRequest = _class
      .instanceMethodId(
        r'getMaxNumberOfChannelsPerNetworkSpecifierRequest',
        r'()I',
      );

  static final _getMaxNumberOfChannelsPerNetworkSpecifierRequest =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMaxNumberOfChannelsPerNetworkSpecifierRequest()`
  int getMaxNumberOfChannelsPerNetworkSpecifierRequest() {
    return _getMaxNumberOfChannelsPerNetworkSpecifierRequest(
      reference.pointer,
      _id_getMaxNumberOfChannelsPerNetworkSpecifierRequest
          as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMaxNumberOfNetworkSuggestionsPerApp = _class
      .instanceMethodId(r'getMaxNumberOfNetworkSuggestionsPerApp', r'()I');

  static final _getMaxNumberOfNetworkSuggestionsPerApp =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMaxNumberOfNetworkSuggestionsPerApp()`
  int getMaxNumberOfNetworkSuggestionsPerApp() {
    return _getMaxNumberOfNetworkSuggestionsPerApp(
      reference.pointer,
      _id_getMaxNumberOfNetworkSuggestionsPerApp as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMaxSignalLevel = _class.instanceMethodId(
    r'getMaxSignalLevel',
    r'()I',
  );

  static final _getMaxSignalLevel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMaxSignalLevel()`
  int getMaxSignalLevel() {
    return _getMaxSignalLevel(
      reference.pointer,
      _id_getMaxSignalLevel as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMaxSupportedConcurrentTdlsSessions = _class
      .instanceMethodId(
        r'getMaxSupportedConcurrentTdlsSessions',
        r'(Ljava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
      );

  static final _getMaxSupportedConcurrentTdlsSessions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getMaxSupportedConcurrentTdlsSessions(java.util.concurrent.Executor executor, java.util.function.Consumer<java.lang.Integer> consumer)`
  void getMaxSupportedConcurrentTdlsSessions(
    executor$_.Executor executor,
    jni$_.JObject consumer,
  ) {
    final _$executor = executor.reference;
    final _$consumer = consumer.reference;
    _getMaxSupportedConcurrentTdlsSessions(
      reference.pointer,
      _id_getMaxSupportedConcurrentTdlsSessions as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$consumer.pointer,
    ).check();
  }

  static final _id_getNetworkSuggestions = _class.instanceMethodId(
    r'getNetworkSuggestions',
    r'()Ljava/util/List;',
  );

  static final _getNetworkSuggestions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.net.wifi.WifiNetworkSuggestion> getNetworkSuggestions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getNetworkSuggestions() {
    return _getNetworkSuggestions(
      reference.pointer,
      _id_getNetworkSuggestions as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getNumberOfEnabledTdlsSessions = _class.instanceMethodId(
    r'getNumberOfEnabledTdlsSessions',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
  );

  static final _getNumberOfEnabledTdlsSessions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getNumberOfEnabledTdlsSessions(java.util.concurrent.Executor executor, java.util.function.Consumer<java.lang.Integer> consumer)`
  void getNumberOfEnabledTdlsSessions(
    executor$_.Executor executor,
    jni$_.JObject consumer,
  ) {
    final _$executor = executor.reference;
    final _$consumer = consumer.reference;
    _getNumberOfEnabledTdlsSessions(
      reference.pointer,
      _id_getNumberOfEnabledTdlsSessions as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$consumer.pointer,
    ).check();
  }

  static final _id_getPasspointConfigurations = _class.instanceMethodId(
    r'getPasspointConfigurations',
    r'()Ljava/util/List;',
  );

  static final _getPasspointConfigurations =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.net.wifi.hotspot2.PasspointConfiguration> getPasspointConfigurations()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getPasspointConfigurations() {
    return _getPasspointConfigurations(
      reference.pointer,
      _id_getPasspointConfigurations as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getPerSsidRoamingModes = _class.instanceMethodId(
    r'getPerSsidRoamingModes',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
  );

  static final _getPerSsidRoamingModes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getPerSsidRoamingModes(java.util.concurrent.Executor executor, java.util.function.Consumer<java.util.Map<java.lang.String, java.lang.Integer>> consumer)`
  void getPerSsidRoamingModes(
    executor$_.Executor executor,
    jni$_.JObject consumer,
  ) {
    final _$executor = executor.reference;
    final _$consumer = consumer.reference;
    _getPerSsidRoamingModes(
      reference.pointer,
      _id_getPerSsidRoamingModes as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$consumer.pointer,
    ).check();
  }

  static final _id_getScanResults = _class.instanceMethodId(
    r'getScanResults',
    r'()Ljava/util/List;',
  );

  static final _getScanResults =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.net.wifi.ScanResult> getScanResults()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<scanresult$_.ScanResult?>? getScanResults() {
    return _getScanResults(
      reference.pointer,
      _id_getScanResults as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<scanresult$_.ScanResult?>?>(
      const jni$_.$JList$NullableType$<scanresult$_.ScanResult?>(
        scanresult$_.$ScanResult$NullableType$(),
      ),
    );
  }

  static final _id_getStaConcurrencyForMultiInternetMode = _class
      .instanceMethodId(r'getStaConcurrencyForMultiInternetMode', r'()I');

  static final _getStaConcurrencyForMultiInternetMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getStaConcurrencyForMultiInternetMode()`
  int getStaConcurrencyForMultiInternetMode() {
    return _getStaConcurrencyForMultiInternetMode(
      reference.pointer,
      _id_getStaConcurrencyForMultiInternetMode as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getUsableChannels = _class.instanceMethodId(
    r'getUsableChannels',
    r'(II)Ljava/util/List;',
  );

  static final _getUsableChannels =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public java.util.List<android.net.wifi.WifiAvailableChannel> getUsableChannels(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getUsableChannels(int i, int i1) {
    return _getUsableChannels(
      reference.pointer,
      _id_getUsableChannels as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getWifiState = _class.instanceMethodId(
    r'getWifiState',
    r'()I',
  );

  static final _getWifiState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getWifiState()`
  int getWifiState() {
    return _getWifiState(
      reference.pointer,
      _id_getWifiState as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_is24GHzBandSupported = _class.instanceMethodId(
    r'is24GHzBandSupported',
    r'()Z',
  );

  static final _is24GHzBandSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean is24GHzBandSupported()`
  bool is24GHzBandSupported() {
    return _is24GHzBandSupported(
      reference.pointer,
      _id_is24GHzBandSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_is5GHzBandSupported = _class.instanceMethodId(
    r'is5GHzBandSupported',
    r'()Z',
  );

  static final _is5GHzBandSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean is5GHzBandSupported()`
  bool is5GHzBandSupported() {
    return _is5GHzBandSupported(
      reference.pointer,
      _id_is5GHzBandSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_is60GHzBandSupported = _class.instanceMethodId(
    r'is60GHzBandSupported',
    r'()Z',
  );

  static final _is60GHzBandSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean is60GHzBandSupported()`
  bool is60GHzBandSupported() {
    return _is60GHzBandSupported(
      reference.pointer,
      _id_is60GHzBandSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_is6GHzBandSupported = _class.instanceMethodId(
    r'is6GHzBandSupported',
    r'()Z',
  );

  static final _is6GHzBandSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean is6GHzBandSupported()`
  bool is6GHzBandSupported() {
    return _is6GHzBandSupported(
      reference.pointer,
      _id_is6GHzBandSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isAggressiveRoamingModeSupported = _class.instanceMethodId(
    r'isAggressiveRoamingModeSupported',
    r'()Z',
  );

  static final _isAggressiveRoamingModeSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAggressiveRoamingModeSupported()`
  bool isAggressiveRoamingModeSupported() {
    return _isAggressiveRoamingModeSupported(
      reference.pointer,
      _id_isAggressiveRoamingModeSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isAutoWakeupEnabled = _class.instanceMethodId(
    r'isAutoWakeupEnabled',
    r'()Z',
  );

  static final _isAutoWakeupEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAutoWakeupEnabled()`
  bool isAutoWakeupEnabled() {
    return _isAutoWakeupEnabled(
      reference.pointer,
      _id_isAutoWakeupEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isBridgedApConcurrencySupported = _class.instanceMethodId(
    r'isBridgedApConcurrencySupported',
    r'()Z',
  );

  static final _isBridgedApConcurrencySupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBridgedApConcurrencySupported()`
  bool isBridgedApConcurrencySupported() {
    return _isBridgedApConcurrencySupported(
      reference.pointer,
      _id_isBridgedApConcurrencySupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isCarrierNetworkOffloadEnabled = _class.instanceMethodId(
    r'isCarrierNetworkOffloadEnabled',
    r'(IZ)Z',
  );

  static final _isCarrierNetworkOffloadEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean isCarrierNetworkOffloadEnabled(int i, boolean z)`
  bool isCarrierNetworkOffloadEnabled(int i, bool z) {
    return _isCarrierNetworkOffloadEnabled(
      reference.pointer,
      _id_isCarrierNetworkOffloadEnabled as jni$_.JMethodIDPtr,
      i,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_isD2dSupportedWhenInfraStaDisabled = _class.instanceMethodId(
    r'isD2dSupportedWhenInfraStaDisabled',
    r'()Z',
  );

  static final _isD2dSupportedWhenInfraStaDisabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isD2dSupportedWhenInfraStaDisabled()`
  bool isD2dSupportedWhenInfraStaDisabled() {
    return _isD2dSupportedWhenInfraStaDisabled(
      reference.pointer,
      _id_isD2dSupportedWhenInfraStaDisabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isDecoratedIdentitySupported = _class.instanceMethodId(
    r'isDecoratedIdentitySupported',
    r'()Z',
  );

  static final _isDecoratedIdentitySupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDecoratedIdentitySupported()`
  bool isDecoratedIdentitySupported() {
    return _isDecoratedIdentitySupported(
      reference.pointer,
      _id_isDecoratedIdentitySupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isDeviceToApRttSupported = _class.instanceMethodId(
    r'isDeviceToApRttSupported',
    r'()Z',
  );

  static final _isDeviceToApRttSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDeviceToApRttSupported()`
  bool isDeviceToApRttSupported() {
    return _isDeviceToApRttSupported(
      reference.pointer,
      _id_isDeviceToApRttSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isDualBandSimultaneousSupported = _class.instanceMethodId(
    r'isDualBandSimultaneousSupported',
    r'()Z',
  );

  static final _isDualBandSimultaneousSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDualBandSimultaneousSupported()`
  bool isDualBandSimultaneousSupported() {
    return _isDualBandSimultaneousSupported(
      reference.pointer,
      _id_isDualBandSimultaneousSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isEasyConnectDppAkmSupported = _class.instanceMethodId(
    r'isEasyConnectDppAkmSupported',
    r'()Z',
  );

  static final _isEasyConnectDppAkmSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isEasyConnectDppAkmSupported()`
  bool isEasyConnectDppAkmSupported() {
    return _isEasyConnectDppAkmSupported(
      reference.pointer,
      _id_isEasyConnectDppAkmSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isEasyConnectEnrolleeResponderModeSupported = _class
      .instanceMethodId(r'isEasyConnectEnrolleeResponderModeSupported', r'()Z');

  static final _isEasyConnectEnrolleeResponderModeSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isEasyConnectEnrolleeResponderModeSupported()`
  bool isEasyConnectEnrolleeResponderModeSupported() {
    return _isEasyConnectEnrolleeResponderModeSupported(
      reference.pointer,
      _id_isEasyConnectEnrolleeResponderModeSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isEasyConnectSupported = _class.instanceMethodId(
    r'isEasyConnectSupported',
    r'()Z',
  );

  static final _isEasyConnectSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isEasyConnectSupported()`
  bool isEasyConnectSupported() {
    return _isEasyConnectSupported(
      reference.pointer,
      _id_isEasyConnectSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isEnhancedOpenSupported = _class.instanceMethodId(
    r'isEnhancedOpenSupported',
    r'()Z',
  );

  static final _isEnhancedOpenSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isEnhancedOpenSupported()`
  bool isEnhancedOpenSupported() {
    return _isEnhancedOpenSupported(
      reference.pointer,
      _id_isEnhancedOpenSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isEnhancedPowerReportingSupported = _class.instanceMethodId(
    r'isEnhancedPowerReportingSupported',
    r'()Z',
  );

  static final _isEnhancedPowerReportingSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isEnhancedPowerReportingSupported()`
  bool isEnhancedPowerReportingSupported() {
    return _isEnhancedPowerReportingSupported(
      reference.pointer,
      _id_isEnhancedPowerReportingSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isMakeBeforeBreakWifiSwitchingSupported = _class
      .instanceMethodId(r'isMakeBeforeBreakWifiSwitchingSupported', r'()Z');

  static final _isMakeBeforeBreakWifiSwitchingSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMakeBeforeBreakWifiSwitchingSupported()`
  bool isMakeBeforeBreakWifiSwitchingSupported() {
    return _isMakeBeforeBreakWifiSwitchingSupported(
      reference.pointer,
      _id_isMakeBeforeBreakWifiSwitchingSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isP2pSupported = _class.instanceMethodId(
    r'isP2pSupported',
    r'()Z',
  );

  static final _isP2pSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isP2pSupported()`
  bool isP2pSupported() {
    return _isP2pSupported(
      reference.pointer,
      _id_isP2pSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isPasspointTermsAndConditionsSupported = _class
      .instanceMethodId(r'isPasspointTermsAndConditionsSupported', r'()Z');

  static final _isPasspointTermsAndConditionsSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPasspointTermsAndConditionsSupported()`
  bool isPasspointTermsAndConditionsSupported() {
    return _isPasspointTermsAndConditionsSupported(
      reference.pointer,
      _id_isPasspointTermsAndConditionsSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isPreferredNetworkOffloadSupported = _class.instanceMethodId(
    r'isPreferredNetworkOffloadSupported',
    r'()Z',
  );

  static final _isPreferredNetworkOffloadSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPreferredNetworkOffloadSupported()`
  bool isPreferredNetworkOffloadSupported() {
    return _isPreferredNetworkOffloadSupported(
      reference.pointer,
      _id_isPreferredNetworkOffloadSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isScanAlwaysAvailable = _class.instanceMethodId(
    r'isScanAlwaysAvailable',
    r'()Z',
  );

  static final _isScanAlwaysAvailable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isScanAlwaysAvailable()`
  bool isScanAlwaysAvailable() {
    return _isScanAlwaysAvailable(
      reference.pointer,
      _id_isScanAlwaysAvailable as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isScanThrottleEnabled = _class.instanceMethodId(
    r'isScanThrottleEnabled',
    r'()Z',
  );

  static final _isScanThrottleEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isScanThrottleEnabled()`
  bool isScanThrottleEnabled() {
    return _isScanThrottleEnabled(
      reference.pointer,
      _id_isScanThrottleEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isStaApConcurrencySupported = _class.instanceMethodId(
    r'isStaApConcurrencySupported',
    r'()Z',
  );

  static final _isStaApConcurrencySupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isStaApConcurrencySupported()`
  bool isStaApConcurrencySupported() {
    return _isStaApConcurrencySupported(
      reference.pointer,
      _id_isStaApConcurrencySupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isStaBridgedApConcurrencySupported = _class.instanceMethodId(
    r'isStaBridgedApConcurrencySupported',
    r'()Z',
  );

  static final _isStaBridgedApConcurrencySupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isStaBridgedApConcurrencySupported()`
  bool isStaBridgedApConcurrencySupported() {
    return _isStaBridgedApConcurrencySupported(
      reference.pointer,
      _id_isStaBridgedApConcurrencySupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isStaConcurrencyForLocalOnlyConnectionsSupported = _class
      .instanceMethodId(
        r'isStaConcurrencyForLocalOnlyConnectionsSupported',
        r'()Z',
      );

  static final _isStaConcurrencyForLocalOnlyConnectionsSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isStaConcurrencyForLocalOnlyConnectionsSupported()`
  bool isStaConcurrencyForLocalOnlyConnectionsSupported() {
    return _isStaConcurrencyForLocalOnlyConnectionsSupported(
      reference.pointer,
      _id_isStaConcurrencyForLocalOnlyConnectionsSupported
          as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isStaConcurrencyForMultiInternetSupported = _class
      .instanceMethodId(r'isStaConcurrencyForMultiInternetSupported', r'()Z');

  static final _isStaConcurrencyForMultiInternetSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isStaConcurrencyForMultiInternetSupported()`
  bool isStaConcurrencyForMultiInternetSupported() {
    return _isStaConcurrencyForMultiInternetSupported(
      reference.pointer,
      _id_isStaConcurrencyForMultiInternetSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isTdlsOperationCurrentlyAvailable = _class.instanceMethodId(
    r'isTdlsOperationCurrentlyAvailable',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
  );

  static final _isTdlsOperationCurrentlyAvailable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void isTdlsOperationCurrentlyAvailable(java.util.concurrent.Executor executor, java.util.function.Consumer<java.lang.Boolean> consumer)`
  void isTdlsOperationCurrentlyAvailable(
    executor$_.Executor executor,
    jni$_.JObject consumer,
  ) {
    final _$executor = executor.reference;
    final _$consumer = consumer.reference;
    _isTdlsOperationCurrentlyAvailable(
      reference.pointer,
      _id_isTdlsOperationCurrentlyAvailable as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$consumer.pointer,
    ).check();
  }

  static final _id_isTdlsSupported = _class.instanceMethodId(
    r'isTdlsSupported',
    r'()Z',
  );

  static final _isTdlsSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isTdlsSupported()`
  bool isTdlsSupported() {
    return _isTdlsSupported(
      reference.pointer,
      _id_isTdlsSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isTidToLinkMappingNegotiationSupported = _class
      .instanceMethodId(r'isTidToLinkMappingNegotiationSupported', r'()Z');

  static final _isTidToLinkMappingNegotiationSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isTidToLinkMappingNegotiationSupported()`
  bool isTidToLinkMappingNegotiationSupported() {
    return _isTidToLinkMappingNegotiationSupported(
      reference.pointer,
      _id_isTidToLinkMappingNegotiationSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isTlsMinimumVersionSupported = _class.instanceMethodId(
    r'isTlsMinimumVersionSupported',
    r'()Z',
  );

  static final _isTlsMinimumVersionSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isTlsMinimumVersionSupported()`
  bool isTlsMinimumVersionSupported() {
    return _isTlsMinimumVersionSupported(
      reference.pointer,
      _id_isTlsMinimumVersionSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isTlsV13Supported = _class.instanceMethodId(
    r'isTlsV13Supported',
    r'()Z',
  );

  static final _isTlsV13Supported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isTlsV13Supported()`
  bool isTlsV13Supported() {
    return _isTlsV13Supported(
      reference.pointer,
      _id_isTlsV13Supported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isTrustOnFirstUseSupported = _class.instanceMethodId(
    r'isTrustOnFirstUseSupported',
    r'()Z',
  );

  static final _isTrustOnFirstUseSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isTrustOnFirstUseSupported()`
  bool isTrustOnFirstUseSupported() {
    return _isTrustOnFirstUseSupported(
      reference.pointer,
      _id_isTrustOnFirstUseSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWapiSupported = _class.instanceMethodId(
    r'isWapiSupported',
    r'()Z',
  );

  static final _isWapiSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWapiSupported()`
  bool isWapiSupported() {
    return _isWapiSupported(
      reference.pointer,
      _id_isWapiSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWepSupported = _class.instanceMethodId(
    r'isWepSupported',
    r'()Z',
  );

  static final _isWepSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWepSupported()`
  bool isWepSupported() {
    return _isWepSupported(
      reference.pointer,
      _id_isWepSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWifiDisplayR2Supported = _class.instanceMethodId(
    r'isWifiDisplayR2Supported',
    r'()Z',
  );

  static final _isWifiDisplayR2Supported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWifiDisplayR2Supported()`
  bool isWifiDisplayR2Supported() {
    return _isWifiDisplayR2Supported(
      reference.pointer,
      _id_isWifiDisplayR2Supported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWifiEnabled = _class.instanceMethodId(
    r'isWifiEnabled',
    r'()Z',
  );

  static final _isWifiEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWifiEnabled()`
  bool isWifiEnabled() {
    return _isWifiEnabled(
      reference.pointer,
      _id_isWifiEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWifiPasspointEnabled = _class.instanceMethodId(
    r'isWifiPasspointEnabled',
    r'()Z',
  );

  static final _isWifiPasspointEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWifiPasspointEnabled()`
  bool isWifiPasspointEnabled() {
    return _isWifiPasspointEnabled(
      reference.pointer,
      _id_isWifiPasspointEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWifiStandardSupported = _class.instanceMethodId(
    r'isWifiStandardSupported',
    r'(I)Z',
  );

  static final _isWifiStandardSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean isWifiStandardSupported(int i)`
  bool isWifiStandardSupported(int i) {
    return _isWifiStandardSupported(
      reference.pointer,
      _id_isWifiStandardSupported as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_isWpa3SaeH2eSupported = _class.instanceMethodId(
    r'isWpa3SaeH2eSupported',
    r'()Z',
  );

  static final _isWpa3SaeH2eSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWpa3SaeH2eSupported()`
  bool isWpa3SaeH2eSupported() {
    return _isWpa3SaeH2eSupported(
      reference.pointer,
      _id_isWpa3SaeH2eSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWpa3SaePublicKeySupported = _class.instanceMethodId(
    r'isWpa3SaePublicKeySupported',
    r'()Z',
  );

  static final _isWpa3SaePublicKeySupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWpa3SaePublicKeySupported()`
  bool isWpa3SaePublicKeySupported() {
    return _isWpa3SaePublicKeySupported(
      reference.pointer,
      _id_isWpa3SaePublicKeySupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWpa3SaeSupported = _class.instanceMethodId(
    r'isWpa3SaeSupported',
    r'()Z',
  );

  static final _isWpa3SaeSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWpa3SaeSupported()`
  bool isWpa3SaeSupported() {
    return _isWpa3SaeSupported(
      reference.pointer,
      _id_isWpa3SaeSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWpa3SuiteBSupported = _class.instanceMethodId(
    r'isWpa3SuiteBSupported',
    r'()Z',
  );

  static final _isWpa3SuiteBSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWpa3SuiteBSupported()`
  bool isWpa3SuiteBSupported() {
    return _isWpa3SuiteBSupported(
      reference.pointer,
      _id_isWpa3SuiteBSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWpaPersonalSupported = _class.instanceMethodId(
    r'isWpaPersonalSupported',
    r'()Z',
  );

  static final _isWpaPersonalSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isWpaPersonalSupported()`
  bool isWpaPersonalSupported() {
    return _isWpaPersonalSupported(
      reference.pointer,
      _id_isWpaPersonalSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_pingSupplicant = _class.instanceMethodId(
    r'pingSupplicant',
    r'()Z',
  );

  static final _pingSupplicant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean pingSupplicant()`
  bool pingSupplicant() {
    return _pingSupplicant(
      reference.pointer,
      _id_pingSupplicant as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_queryAutojoinGlobal = _class.instanceMethodId(
    r'queryAutojoinGlobal',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
  );

  static final _queryAutojoinGlobal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void queryAutojoinGlobal(java.util.concurrent.Executor executor, java.util.function.Consumer<java.lang.Boolean> consumer)`
  void queryAutojoinGlobal(
    executor$_.Executor executor,
    jni$_.JObject consumer,
  ) {
    final _$executor = executor.reference;
    final _$consumer = consumer.reference;
    _queryAutojoinGlobal(
      reference.pointer,
      _id_queryAutojoinGlobal as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$consumer.pointer,
    ).check();
  }

  static final _id_querySendDhcpHostnameRestriction = _class.instanceMethodId(
    r'querySendDhcpHostnameRestriction',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/IntConsumer;)V',
  );

  static final _querySendDhcpHostnameRestriction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void querySendDhcpHostnameRestriction(java.util.concurrent.Executor executor, java.util.function.IntConsumer intConsumer)`
  void querySendDhcpHostnameRestriction(
    executor$_.Executor executor,
    jni$_.JObject intConsumer,
  ) {
    final _$executor = executor.reference;
    final _$intConsumer = intConsumer.reference;
    _querySendDhcpHostnameRestriction(
      reference.pointer,
      _id_querySendDhcpHostnameRestriction as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$intConsumer.pointer,
    ).check();
  }

  static final _id_reassociate = _class.instanceMethodId(
    r'reassociate',
    r'()Z',
  );

  static final _reassociate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean reassociate()`
  bool reassociate() {
    return _reassociate(
      reference.pointer,
      _id_reassociate as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_reconnect = _class.instanceMethodId(r'reconnect', r'()Z');

  static final _reconnect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean reconnect()`
  bool reconnect() {
    return _reconnect(
      reference.pointer,
      _id_reconnect as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_registerScanResultsCallback = _class.instanceMethodId(
    r'registerScanResultsCallback',
    r'(Ljava/util/concurrent/Executor;Landroid/net/wifi/WifiManager$ScanResultsCallback;)V',
  );

  static final _registerScanResultsCallback =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void registerScanResultsCallback(java.util.concurrent.Executor executor, android.net.wifi.WifiManager$ScanResultsCallback scanResultsCallback)`
  void registerScanResultsCallback(
    executor$_.Executor executor,
    WifiManager$ScanResultsCallback scanResultsCallback,
  ) {
    final _$executor = executor.reference;
    final _$scanResultsCallback = scanResultsCallback.reference;
    _registerScanResultsCallback(
      reference.pointer,
      _id_registerScanResultsCallback as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$scanResultsCallback.pointer,
    ).check();
  }

  static final _id_registerSubsystemRestartTrackingCallback = _class
      .instanceMethodId(
        r'registerSubsystemRestartTrackingCallback',
        r'(Ljava/util/concurrent/Executor;Landroid/net/wifi/WifiManager$SubsystemRestartTrackingCallback;)V',
      );

  static final _registerSubsystemRestartTrackingCallback =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void registerSubsystemRestartTrackingCallback(java.util.concurrent.Executor executor, android.net.wifi.WifiManager$SubsystemRestartTrackingCallback subsystemRestartTrackingCallback)`
  void registerSubsystemRestartTrackingCallback(
    executor$_.Executor executor,
    WifiManager$SubsystemRestartTrackingCallback
    subsystemRestartTrackingCallback,
  ) {
    final _$executor = executor.reference;
    final _$subsystemRestartTrackingCallback =
        subsystemRestartTrackingCallback.reference;
    _registerSubsystemRestartTrackingCallback(
      reference.pointer,
      _id_registerSubsystemRestartTrackingCallback as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$subsystemRestartTrackingCallback.pointer,
    ).check();
  }

  static final _id_removeLocalOnlyConnectionFailureListener = _class
      .instanceMethodId(
        r'removeLocalOnlyConnectionFailureListener',
        r'(Landroid/net/wifi/WifiManager$LocalOnlyConnectionFailureListener;)V',
      );

  static final _removeLocalOnlyConnectionFailureListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeLocalOnlyConnectionFailureListener(android.net.wifi.WifiManager$LocalOnlyConnectionFailureListener localOnlyConnectionFailureListener)`
  void removeLocalOnlyConnectionFailureListener(
    WifiManager$LocalOnlyConnectionFailureListener
    localOnlyConnectionFailureListener,
  ) {
    final _$localOnlyConnectionFailureListener =
        localOnlyConnectionFailureListener.reference;
    _removeLocalOnlyConnectionFailureListener(
      reference.pointer,
      _id_removeLocalOnlyConnectionFailureListener as jni$_.JMethodIDPtr,
      _$localOnlyConnectionFailureListener.pointer,
    ).check();
  }

  static final _id_removeNetwork = _class.instanceMethodId(
    r'removeNetwork',
    r'(I)Z',
  );

  static final _removeNetwork =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean removeNetwork(int i)`
  bool removeNetwork(int i) {
    return _removeNetwork(
      reference.pointer,
      _id_removeNetwork as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_removeNetworkSuggestions = _class.instanceMethodId(
    r'removeNetworkSuggestions',
    r'(Ljava/util/List;)I',
  );

  static final _removeNetworkSuggestions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int removeNetworkSuggestions(java.util.List<android.net.wifi.WifiNetworkSuggestion> list)`
  int removeNetworkSuggestions(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _removeNetworkSuggestions(
      reference.pointer,
      _id_removeNetworkSuggestions as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).integer;
  }

  static final _id_removeNetworkSuggestions$1 = _class.instanceMethodId(
    r'removeNetworkSuggestions',
    r'(Ljava/util/List;I)I',
  );

  static final _removeNetworkSuggestions$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public int removeNetworkSuggestions(java.util.List<android.net.wifi.WifiNetworkSuggestion> list, int i)`
  int removeNetworkSuggestions$1(jni$_.JList<jni$_.JObject?> list, int i) {
    final _$list = list.reference;
    return _removeNetworkSuggestions$1(
      reference.pointer,
      _id_removeNetworkSuggestions$1 as jni$_.JMethodIDPtr,
      _$list.pointer,
      i,
    ).integer;
  }

  static final _id_removeNonCallerConfiguredNetworks = _class.instanceMethodId(
    r'removeNonCallerConfiguredNetworks',
    r'()Z',
  );

  static final _removeNonCallerConfiguredNetworks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean removeNonCallerConfiguredNetworks()`
  bool removeNonCallerConfiguredNetworks() {
    return _removeNonCallerConfiguredNetworks(
      reference.pointer,
      _id_removeNonCallerConfiguredNetworks as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_removePasspointConfiguration = _class.instanceMethodId(
    r'removePasspointConfiguration',
    r'(Ljava/lang/String;)V',
  );

  static final _removePasspointConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removePasspointConfiguration(java.lang.String string)`
  void removePasspointConfiguration(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removePasspointConfiguration(
      reference.pointer,
      _id_removePasspointConfiguration as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_removePerSsidRoamingMode = _class.instanceMethodId(
    r'removePerSsidRoamingMode',
    r'(Landroid/net/wifi/WifiSsid;)V',
  );

  static final _removePerSsidRoamingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removePerSsidRoamingMode(android.net.wifi.WifiSsid wifiSsid)`
  void removePerSsidRoamingMode(jni$_.JObject wifiSsid) {
    final _$wifiSsid = wifiSsid.reference;
    _removePerSsidRoamingMode(
      reference.pointer,
      _id_removePerSsidRoamingMode as jni$_.JMethodIDPtr,
      _$wifiSsid.pointer,
    ).check();
  }

  static final _id_removeSuggestionConnectionStatusListener = _class
      .instanceMethodId(
        r'removeSuggestionConnectionStatusListener',
        r'(Landroid/net/wifi/WifiManager$SuggestionConnectionStatusListener;)V',
      );

  static final _removeSuggestionConnectionStatusListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeSuggestionConnectionStatusListener(android.net.wifi.WifiManager$SuggestionConnectionStatusListener suggestionConnectionStatusListener)`
  void removeSuggestionConnectionStatusListener(
    WifiManager$SuggestionConnectionStatusListener
    suggestionConnectionStatusListener,
  ) {
    final _$suggestionConnectionStatusListener =
        suggestionConnectionStatusListener.reference;
    _removeSuggestionConnectionStatusListener(
      reference.pointer,
      _id_removeSuggestionConnectionStatusListener as jni$_.JMethodIDPtr,
      _$suggestionConnectionStatusListener.pointer,
    ).check();
  }

  static final _id_removeSuggestionUserApprovalStatusListener = _class
      .instanceMethodId(
        r'removeSuggestionUserApprovalStatusListener',
        r'(Landroid/net/wifi/WifiManager$SuggestionUserApprovalStatusListener;)V',
      );

  static final _removeSuggestionUserApprovalStatusListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeSuggestionUserApprovalStatusListener(android.net.wifi.WifiManager$SuggestionUserApprovalStatusListener suggestionUserApprovalStatusListener)`
  void removeSuggestionUserApprovalStatusListener(
    WifiManager$SuggestionUserApprovalStatusListener
    suggestionUserApprovalStatusListener,
  ) {
    final _$suggestionUserApprovalStatusListener =
        suggestionUserApprovalStatusListener.reference;
    _removeSuggestionUserApprovalStatusListener(
      reference.pointer,
      _id_removeSuggestionUserApprovalStatusListener as jni$_.JMethodIDPtr,
      _$suggestionUserApprovalStatusListener.pointer,
    ).check();
  }

  static final _id_removeWifiStateChangedListener = _class.instanceMethodId(
    r'removeWifiStateChangedListener',
    r'(Landroid/net/wifi/WifiManager$WifiStateChangedListener;)V',
  );

  static final _removeWifiStateChangedListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeWifiStateChangedListener(android.net.wifi.WifiManager$WifiStateChangedListener wifiStateChangedListener)`
  void removeWifiStateChangedListener(
    WifiManager$WifiStateChangedListener wifiStateChangedListener,
  ) {
    final _$wifiStateChangedListener = wifiStateChangedListener.reference;
    _removeWifiStateChangedListener(
      reference.pointer,
      _id_removeWifiStateChangedListener as jni$_.JMethodIDPtr,
      _$wifiStateChangedListener.pointer,
    ).check();
  }

  static final _id_reportCreateInterfaceImpact = _class.instanceMethodId(
    r'reportCreateInterfaceImpact',
    r'(IZLjava/util/concurrent/Executor;Ljava/util/function/BiConsumer;)V',
  );

  static final _reportCreateInterfaceImpact =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void reportCreateInterfaceImpact(int i, boolean z, java.util.concurrent.Executor executor, java.util.function.BiConsumer<java.lang.Boolean, java.util.Set<android.net.wifi.WifiManager$InterfaceCreationImpact>> biConsumer)`
  void reportCreateInterfaceImpact(
    int i,
    bool z,
    executor$_.Executor executor,
    jni$_.JObject biConsumer,
  ) {
    final _$executor = executor.reference;
    final _$biConsumer = biConsumer.reference;
    _reportCreateInterfaceImpact(
      reference.pointer,
      _id_reportCreateInterfaceImpact as jni$_.JMethodIDPtr,
      i,
      z ? 1 : 0,
      _$executor.pointer,
      _$biConsumer.pointer,
    ).check();
  }

  static final _id_saveConfiguration = _class.instanceMethodId(
    r'saveConfiguration',
    r'()Z',
  );

  static final _saveConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean saveConfiguration()`
  bool saveConfiguration() {
    return _saveConfiguration(
      reference.pointer,
      _id_saveConfiguration as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setPerSsidRoamingMode = _class.instanceMethodId(
    r'setPerSsidRoamingMode',
    r'(Landroid/net/wifi/WifiSsid;I)V',
  );

  static final _setPerSsidRoamingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void setPerSsidRoamingMode(android.net.wifi.WifiSsid wifiSsid, int i)`
  void setPerSsidRoamingMode(jni$_.JObject wifiSsid, int i) {
    final _$wifiSsid = wifiSsid.reference;
    _setPerSsidRoamingMode(
      reference.pointer,
      _id_setPerSsidRoamingMode as jni$_.JMethodIDPtr,
      _$wifiSsid.pointer,
      i,
    ).check();
  }

  static final _id_setSendDhcpHostnameRestriction = _class.instanceMethodId(
    r'setSendDhcpHostnameRestriction',
    r'(I)V',
  );

  static final _setSendDhcpHostnameRestriction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSendDhcpHostnameRestriction(int i)`
  void setSendDhcpHostnameRestriction(int i) {
    _setSendDhcpHostnameRestriction(
      reference.pointer,
      _id_setSendDhcpHostnameRestriction as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setTdlsEnabled = _class.instanceMethodId(
    r'setTdlsEnabled',
    r'(Ljava/net/InetAddress;Z)V',
  );

  static final _setTdlsEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void setTdlsEnabled(java.net.InetAddress inetAddress, boolean z)`
  void setTdlsEnabled(inetaddress$_.InetAddress? inetAddress, bool z) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    _setTdlsEnabled(
      reference.pointer,
      _id_setTdlsEnabled as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setTdlsEnabled$1 = _class.instanceMethodId(
    r'setTdlsEnabled',
    r'(Ljava/net/InetAddress;ZLjava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
  );

  static final _setTdlsEnabled$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTdlsEnabled(java.net.InetAddress inetAddress, boolean z, java.util.concurrent.Executor executor, java.util.function.Consumer<java.lang.Boolean> consumer)`
  void setTdlsEnabled$1(
    inetaddress$_.InetAddress inetAddress,
    bool z,
    executor$_.Executor executor,
    jni$_.JObject consumer,
  ) {
    final _$inetAddress = inetAddress.reference;
    final _$executor = executor.reference;
    final _$consumer = consumer.reference;
    _setTdlsEnabled$1(
      reference.pointer,
      _id_setTdlsEnabled$1 as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
      z ? 1 : 0,
      _$executor.pointer,
      _$consumer.pointer,
    ).check();
  }

  static final _id_setTdlsEnabledWithMacAddress = _class.instanceMethodId(
    r'setTdlsEnabledWithMacAddress',
    r'(Ljava/lang/String;Z)V',
  );

  static final _setTdlsEnabledWithMacAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void setTdlsEnabledWithMacAddress(java.lang.String string, boolean z)`
  void setTdlsEnabledWithMacAddress(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTdlsEnabledWithMacAddress(
      reference.pointer,
      _id_setTdlsEnabledWithMacAddress as jni$_.JMethodIDPtr,
      _$string.pointer,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setTdlsEnabledWithMacAddress$1 = _class.instanceMethodId(
    r'setTdlsEnabledWithMacAddress',
    r'(Ljava/lang/String;ZLjava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
  );

  static final _setTdlsEnabledWithMacAddress$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTdlsEnabledWithMacAddress(java.lang.String string, boolean z, java.util.concurrent.Executor executor, java.util.function.Consumer<java.lang.Boolean> consumer)`
  void setTdlsEnabledWithMacAddress$1(
    jni$_.JString string,
    bool z,
    executor$_.Executor executor,
    jni$_.JObject consumer,
  ) {
    final _$string = string.reference;
    final _$executor = executor.reference;
    final _$consumer = consumer.reference;
    _setTdlsEnabledWithMacAddress$1(
      reference.pointer,
      _id_setTdlsEnabledWithMacAddress$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      z ? 1 : 0,
      _$executor.pointer,
      _$consumer.pointer,
    ).check();
  }

  static final _id_setWifiEnabled = _class.instanceMethodId(
    r'setWifiEnabled',
    r'(Z)Z',
  );

  static final _setWifiEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setWifiEnabled(boolean z)`
  bool setWifiEnabled(bool z) {
    return _setWifiEnabled(
      reference.pointer,
      _id_setWifiEnabled as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_startLocalOnlyHotspot = _class.instanceMethodId(
    r'startLocalOnlyHotspot',
    r'(Landroid/net/wifi/WifiManager$LocalOnlyHotspotCallback;Landroid/os/Handler;)V',
  );

  static final _startLocalOnlyHotspot =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void startLocalOnlyHotspot(android.net.wifi.WifiManager$LocalOnlyHotspotCallback localOnlyHotspotCallback, android.os.Handler handler)`
  void startLocalOnlyHotspot(
    WifiManager$LocalOnlyHotspotCallback? localOnlyHotspotCallback,
    handler$_.Handler? handler,
  ) {
    final _$localOnlyHotspotCallback =
        localOnlyHotspotCallback?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    _startLocalOnlyHotspot(
      reference.pointer,
      _id_startLocalOnlyHotspot as jni$_.JMethodIDPtr,
      _$localOnlyHotspotCallback.pointer,
      _$handler.pointer,
    ).check();
  }

  static final _id_startLocalOnlyHotspotWithConfiguration = _class.instanceMethodId(
    r'startLocalOnlyHotspotWithConfiguration',
    r'(Landroid/net/wifi/SoftApConfiguration;Ljava/util/concurrent/Executor;Landroid/net/wifi/WifiManager$LocalOnlyHotspotCallback;)V',
  );

  static final _startLocalOnlyHotspotWithConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void startLocalOnlyHotspotWithConfiguration(android.net.wifi.SoftApConfiguration softApConfiguration, java.util.concurrent.Executor executor, android.net.wifi.WifiManager$LocalOnlyHotspotCallback localOnlyHotspotCallback)`
  void startLocalOnlyHotspotWithConfiguration(
    jni$_.JObject softApConfiguration,
    executor$_.Executor executor,
    WifiManager$LocalOnlyHotspotCallback localOnlyHotspotCallback,
  ) {
    final _$softApConfiguration = softApConfiguration.reference;
    final _$executor = executor.reference;
    final _$localOnlyHotspotCallback = localOnlyHotspotCallback.reference;
    _startLocalOnlyHotspotWithConfiguration(
      reference.pointer,
      _id_startLocalOnlyHotspotWithConfiguration as jni$_.JMethodIDPtr,
      _$softApConfiguration.pointer,
      _$executor.pointer,
      _$localOnlyHotspotCallback.pointer,
    ).check();
  }

  static final _id_startScan = _class.instanceMethodId(r'startScan', r'()Z');

  static final _startScan =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean startScan()`
  bool startScan() {
    return _startScan(
      reference.pointer,
      _id_startScan as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_startWps = _class.instanceMethodId(
    r'startWps',
    r'(Landroid/net/wifi/WpsInfo;Landroid/net/wifi/WifiManager$WpsCallback;)V',
  );

  static final _startWps =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void startWps(android.net.wifi.WpsInfo wpsInfo, android.net.wifi.WifiManager$WpsCallback wpsCallback)`
  void startWps(jni$_.JObject? wpsInfo, WifiManager$WpsCallback? wpsCallback) {
    final _$wpsInfo = wpsInfo?.reference ?? jni$_.jNullReference;
    final _$wpsCallback = wpsCallback?.reference ?? jni$_.jNullReference;
    _startWps(
      reference.pointer,
      _id_startWps as jni$_.JMethodIDPtr,
      _$wpsInfo.pointer,
      _$wpsCallback.pointer,
    ).check();
  }

  static final _id_unregisterScanResultsCallback = _class.instanceMethodId(
    r'unregisterScanResultsCallback',
    r'(Landroid/net/wifi/WifiManager$ScanResultsCallback;)V',
  );

  static final _unregisterScanResultsCallback =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void unregisterScanResultsCallback(android.net.wifi.WifiManager$ScanResultsCallback scanResultsCallback)`
  void unregisterScanResultsCallback(
    WifiManager$ScanResultsCallback scanResultsCallback,
  ) {
    final _$scanResultsCallback = scanResultsCallback.reference;
    _unregisterScanResultsCallback(
      reference.pointer,
      _id_unregisterScanResultsCallback as jni$_.JMethodIDPtr,
      _$scanResultsCallback.pointer,
    ).check();
  }

  static final _id_unregisterSubsystemRestartTrackingCallback = _class
      .instanceMethodId(
        r'unregisterSubsystemRestartTrackingCallback',
        r'(Landroid/net/wifi/WifiManager$SubsystemRestartTrackingCallback;)V',
      );

  static final _unregisterSubsystemRestartTrackingCallback =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void unregisterSubsystemRestartTrackingCallback(android.net.wifi.WifiManager$SubsystemRestartTrackingCallback subsystemRestartTrackingCallback)`
  void unregisterSubsystemRestartTrackingCallback(
    WifiManager$SubsystemRestartTrackingCallback
    subsystemRestartTrackingCallback,
  ) {
    final _$subsystemRestartTrackingCallback =
        subsystemRestartTrackingCallback.reference;
    _unregisterSubsystemRestartTrackingCallback(
      reference.pointer,
      _id_unregisterSubsystemRestartTrackingCallback as jni$_.JMethodIDPtr,
      _$subsystemRestartTrackingCallback.pointer,
    ).check();
  }

  static final _id_updateNetwork = _class.instanceMethodId(
    r'updateNetwork',
    r'(Landroid/net/wifi/WifiConfiguration;)I',
  );

  static final _updateNetwork =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int updateNetwork(android.net.wifi.WifiConfiguration wifiConfiguration)`
  int updateNetwork(wificonfiguration$_.WifiConfiguration? wifiConfiguration) {
    final _$wifiConfiguration =
        wifiConfiguration?.reference ?? jni$_.jNullReference;
    return _updateNetwork(
      reference.pointer,
      _id_updateNetwork as jni$_.JMethodIDPtr,
      _$wifiConfiguration.pointer,
    ).integer;
  }

  static final _id_validateSoftApConfiguration = _class.instanceMethodId(
    r'validateSoftApConfiguration',
    r'(Landroid/net/wifi/SoftApConfiguration;)Z',
  );

  static final _validateSoftApConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean validateSoftApConfiguration(android.net.wifi.SoftApConfiguration softApConfiguration)`
  bool validateSoftApConfiguration(jni$_.JObject softApConfiguration) {
    final _$softApConfiguration = softApConfiguration.reference;
    return _validateSoftApConfiguration(
      reference.pointer,
      _id_validateSoftApConfiguration as jni$_.JMethodIDPtr,
      _$softApConfiguration.pointer,
    ).boolean;
  }
}

final class $WifiManager$NullableType$ extends jni$_.JType<WifiManager?> {
  @jni$_.internal
  const $WifiManager$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager;';

  @jni$_.internal
  @core$_.override
  WifiManager? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : WifiManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$NullableType$) &&
        other is $WifiManager$NullableType$;
  }
}

final class $WifiManager$Type$ extends jni$_.JType<WifiManager> {
  @jni$_.internal
  const $WifiManager$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/net/wifi/WifiManager;';

  @jni$_.internal
  @core$_.override
  WifiManager fromReference(jni$_.JReference reference) =>
      WifiManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<WifiManager?> get nullableType =>
      const $WifiManager$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($WifiManager$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WifiManager$Type$) &&
        other is $WifiManager$Type$;
  }
}
