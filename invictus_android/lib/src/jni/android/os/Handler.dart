// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'Looper.dart' as looper$_;

/// from: `android.os.Handler$Callback`
class Handler$Callback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Handler$Callback> $type;

  @jni$_.internal
  Handler$Callback.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Handler$Callback');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Handler$Callback?> nullableType =
      $Handler$Callback$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Handler$Callback> type = $Handler$Callback$Type$();
  static final _id_handleMessage = _class.instanceMethodId(
    r'handleMessage',
    r'(Landroid/os/Message;)Z',
  );

  static final _handleMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean handleMessage(android.os.Message message)`
  bool handleMessage(jni$_.JObject message) {
    final _$message = message.reference;
    return _handleMessage(
      reference.pointer,
      _id_handleMessage as jni$_.JMethodIDPtr,
      _$message.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Handler$Callback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'handleMessage(Landroid/os/Message;)Z') {
        final $r = _$impls[$p]!.handleMessage(
          $a![0]!.as(const jni$_.$JObject$Type$(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Handler$Callback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'android.os.Handler$Callback', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Handler$Callback.implement($Handler$Callback $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Handler$Callback.fromReference($i.implementReference());
  }
}

abstract base mixin class $Handler$Callback {
  factory $Handler$Callback({
    required bool Function(jni$_.JObject message) handleMessage,
  }) = _$Handler$Callback;

  bool handleMessage(jni$_.JObject message);
}

final class _$Handler$Callback with $Handler$Callback {
  _$Handler$Callback({
    required bool Function(jni$_.JObject message) handleMessage,
  }) : _handleMessage = handleMessage;

  final bool Function(jni$_.JObject message) _handleMessage;

  bool handleMessage(jni$_.JObject message) {
    return _handleMessage(message);
  }
}

final class $Handler$Callback$NullableType$
    extends jni$_.JType<Handler$Callback?> {
  @jni$_.internal
  const $Handler$Callback$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Handler$Callback;';

  @jni$_.internal
  @core$_.override
  Handler$Callback? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Handler$Callback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Handler$Callback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Handler$Callback$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Handler$Callback$NullableType$) &&
        other is $Handler$Callback$NullableType$;
  }
}

final class $Handler$Callback$Type$ extends jni$_.JType<Handler$Callback> {
  @jni$_.internal
  const $Handler$Callback$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Handler$Callback;';

  @jni$_.internal
  @core$_.override
  Handler$Callback fromReference(jni$_.JReference reference) =>
      Handler$Callback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Handler$Callback?> get nullableType =>
      const $Handler$Callback$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Handler$Callback$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Handler$Callback$Type$) &&
        other is $Handler$Callback$Type$;
  }
}

/// from: `android.os.Handler`
class Handler extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Handler> $type;

  @jni$_.internal
  Handler.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Handler');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Handler?> nullableType = $Handler$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Handler> type = $Handler$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Handler() {
    return Handler.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Landroid/os/Handler$Callback;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(android.os.Handler$Callback callback)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Handler.new$1(Handler$Callback? callback) {
    final _$callback = callback?.reference ?? jni$_.jNullReference;
    return Handler.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$callback.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Landroid/os/Looper;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(android.os.Looper looper)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Handler.new$2(looper$_.Looper looper) {
    final _$looper = looper.reference;
    return Handler.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$looper.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Landroid/os/Looper;Landroid/os/Handler$Callback;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(android.os.Looper looper, android.os.Handler$Callback callback)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Handler.new$3(looper$_.Looper looper, Handler$Callback? callback) {
    final _$looper = looper.reference;
    final _$callback = callback?.reference ?? jni$_.jNullReference;
    return Handler.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$looper.pointer,
        _$callback.pointer,
      ).reference,
    );
  }

  static final _id_createAsync = _class.staticMethodId(
    r'createAsync',
    r'(Landroid/os/Looper;)Landroid/os/Handler;',
  );

  static final _createAsync =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.os.Handler createAsync(android.os.Looper looper)`
  /// The returned object must be released after use, by calling the [release] method.
  static Handler createAsync(looper$_.Looper looper) {
    final _$looper = looper.reference;
    return _createAsync(
      _class.reference.pointer,
      _id_createAsync as jni$_.JMethodIDPtr,
      _$looper.pointer,
    ).object<Handler>(const $Handler$Type$());
  }

  static final _id_createAsync$1 = _class.staticMethodId(
    r'createAsync',
    r'(Landroid/os/Looper;Landroid/os/Handler$Callback;)Landroid/os/Handler;',
  );

  static final _createAsync$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.os.Handler createAsync(android.os.Looper looper, android.os.Handler$Callback callback)`
  /// The returned object must be released after use, by calling the [release] method.
  static Handler createAsync$1(
    looper$_.Looper looper,
    Handler$Callback callback,
  ) {
    final _$looper = looper.reference;
    final _$callback = callback.reference;
    return _createAsync$1(
      _class.reference.pointer,
      _id_createAsync$1 as jni$_.JMethodIDPtr,
      _$looper.pointer,
      _$callback.pointer,
    ).object<Handler>(const $Handler$Type$());
  }

  static final _id_dispatchMessage = _class.instanceMethodId(
    r'dispatchMessage',
    r'(Landroid/os/Message;)V',
  );

  static final _dispatchMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void dispatchMessage(android.os.Message message)`
  void dispatchMessage(jni$_.JObject message) {
    final _$message = message.reference;
    _dispatchMessage(
      reference.pointer,
      _id_dispatchMessage as jni$_.JMethodIDPtr,
      _$message.pointer,
    ).check();
  }

  static final _id_dump = _class.instanceMethodId(
    r'dump',
    r'(Landroid/util/Printer;Ljava/lang/String;)V',
  );

  static final _dump =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void dump(android.util.Printer printer, java.lang.String string)`
  void dump(jni$_.JObject printer, jni$_.JString string) {
    final _$printer = printer.reference;
    final _$string = string.reference;
    _dump(
      reference.pointer,
      _id_dump as jni$_.JMethodIDPtr,
      _$printer.pointer,
      _$string.pointer,
    ).check();
  }

  static final _id_getLooper = _class.instanceMethodId(
    r'getLooper',
    r'()Landroid/os/Looper;',
  );

  static final _getLooper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final android.os.Looper getLooper()`
  /// The returned object must be released after use, by calling the [release] method.
  looper$_.Looper getLooper() {
    return _getLooper(
      reference.pointer,
      _id_getLooper as jni$_.JMethodIDPtr,
    ).object<looper$_.Looper>(const looper$_.$Looper$Type$());
  }

  static final _id_getMessageName = _class.instanceMethodId(
    r'getMessageName',
    r'(Landroid/os/Message;)Ljava/lang/String;',
  );

  static final _getMessageName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getMessageName(android.os.Message message)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getMessageName(jni$_.JObject message) {
    final _$message = message.reference;
    return _getMessageName(
      reference.pointer,
      _id_getMessageName as jni$_.JMethodIDPtr,
      _$message.pointer,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_handleMessage = _class.instanceMethodId(
    r'handleMessage',
    r'(Landroid/os/Message;)V',
  );

  static final _handleMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void handleMessage(android.os.Message message)`
  void handleMessage(jni$_.JObject message) {
    final _$message = message.reference;
    _handleMessage(
      reference.pointer,
      _id_handleMessage as jni$_.JMethodIDPtr,
      _$message.pointer,
    ).check();
  }

  static final _id_hasCallbacks = _class.instanceMethodId(
    r'hasCallbacks',
    r'(Ljava/lang/Runnable;)Z',
  );

  static final _hasCallbacks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean hasCallbacks(java.lang.Runnable runnable)`
  bool hasCallbacks(jni$_.JObject runnable) {
    final _$runnable = runnable.reference;
    return _hasCallbacks(
      reference.pointer,
      _id_hasCallbacks as jni$_.JMethodIDPtr,
      _$runnable.pointer,
    ).boolean;
  }

  static final _id_hasMessages = _class.instanceMethodId(
    r'hasMessages',
    r'(I)Z',
  );

  static final _hasMessages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final boolean hasMessages(int i)`
  bool hasMessages(int i) {
    return _hasMessages(
      reference.pointer,
      _id_hasMessages as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_hasMessages$1 = _class.instanceMethodId(
    r'hasMessages',
    r'(ILjava/lang/Object;)Z',
  );

  static final _hasMessages$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean hasMessages(int i, java.lang.Object object)`
  bool hasMessages$1(int i, jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _hasMessages$1(
      reference.pointer,
      _id_hasMessages$1 as jni$_.JMethodIDPtr,
      i,
      _$object.pointer,
    ).boolean;
  }

  static final _id_obtainMessage = _class.instanceMethodId(
    r'obtainMessage',
    r'()Landroid/os/Message;',
  );

  static final _obtainMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final android.os.Message obtainMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject obtainMessage() {
    return _obtainMessage(
      reference.pointer,
      _id_obtainMessage as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_obtainMessage$1 = _class.instanceMethodId(
    r'obtainMessage',
    r'(I)Landroid/os/Message;',
  );

  static final _obtainMessage$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final android.os.Message obtainMessage(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject obtainMessage$1(int i) {
    return _obtainMessage$1(
      reference.pointer,
      _id_obtainMessage$1 as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_obtainMessage$2 = _class.instanceMethodId(
    r'obtainMessage',
    r'(III)Landroid/os/Message;',
  );

  static final _obtainMessage$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public final android.os.Message obtainMessage(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject obtainMessage$2(int i, int i1, int i2) {
    return _obtainMessage$2(
      reference.pointer,
      _id_obtainMessage$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_obtainMessage$3 = _class.instanceMethodId(
    r'obtainMessage',
    r'(IIILjava/lang/Object;)Landroid/os/Message;',
  );

  static final _obtainMessage$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final android.os.Message obtainMessage(int i, int i1, int i2, java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject obtainMessage$3(int i, int i1, int i2, jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _obtainMessage$3(
      reference.pointer,
      _id_obtainMessage$3 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      _$object.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_obtainMessage$4 = _class.instanceMethodId(
    r'obtainMessage',
    r'(ILjava/lang/Object;)Landroid/os/Message;',
  );

  static final _obtainMessage$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final android.os.Message obtainMessage(int i, java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject obtainMessage$4(int i, jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _obtainMessage$4(
      reference.pointer,
      _id_obtainMessage$4 as jni$_.JMethodIDPtr,
      i,
      _$object.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_post = _class.instanceMethodId(
    r'post',
    r'(Ljava/lang/Runnable;)Z',
  );

  static final _post =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean post(java.lang.Runnable runnable)`
  bool post(jni$_.JObject runnable) {
    final _$runnable = runnable.reference;
    return _post(
      reference.pointer,
      _id_post as jni$_.JMethodIDPtr,
      _$runnable.pointer,
    ).boolean;
  }

  static final _id_postAtFrontOfQueue = _class.instanceMethodId(
    r'postAtFrontOfQueue',
    r'(Ljava/lang/Runnable;)Z',
  );

  static final _postAtFrontOfQueue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean postAtFrontOfQueue(java.lang.Runnable runnable)`
  bool postAtFrontOfQueue(jni$_.JObject runnable) {
    final _$runnable = runnable.reference;
    return _postAtFrontOfQueue(
      reference.pointer,
      _id_postAtFrontOfQueue as jni$_.JMethodIDPtr,
      _$runnable.pointer,
    ).boolean;
  }

  static final _id_postAtTime = _class.instanceMethodId(
    r'postAtTime',
    r'(Ljava/lang/Runnable;Ljava/lang/Object;J)Z',
  );

  static final _postAtTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int64,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public final boolean postAtTime(java.lang.Runnable runnable, java.lang.Object object, long j)`
  bool postAtTime(jni$_.JObject runnable, jni$_.JObject? object, int j) {
    final _$runnable = runnable.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _postAtTime(
      reference.pointer,
      _id_postAtTime as jni$_.JMethodIDPtr,
      _$runnable.pointer,
      _$object.pointer,
      j,
    ).boolean;
  }

  static final _id_postAtTime$1 = _class.instanceMethodId(
    r'postAtTime',
    r'(Ljava/lang/Runnable;J)Z',
  );

  static final _postAtTime$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public final boolean postAtTime(java.lang.Runnable runnable, long j)`
  bool postAtTime$1(jni$_.JObject runnable, int j) {
    final _$runnable = runnable.reference;
    return _postAtTime$1(
      reference.pointer,
      _id_postAtTime$1 as jni$_.JMethodIDPtr,
      _$runnable.pointer,
      j,
    ).boolean;
  }

  static final _id_postDelayed = _class.instanceMethodId(
    r'postDelayed',
    r'(Ljava/lang/Runnable;Ljava/lang/Object;J)Z',
  );

  static final _postDelayed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int64,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public final boolean postDelayed(java.lang.Runnable runnable, java.lang.Object object, long j)`
  bool postDelayed(jni$_.JObject runnable, jni$_.JObject? object, int j) {
    final _$runnable = runnable.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _postDelayed(
      reference.pointer,
      _id_postDelayed as jni$_.JMethodIDPtr,
      _$runnable.pointer,
      _$object.pointer,
      j,
    ).boolean;
  }

  static final _id_postDelayed$1 = _class.instanceMethodId(
    r'postDelayed',
    r'(Ljava/lang/Runnable;J)Z',
  );

  static final _postDelayed$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public final boolean postDelayed(java.lang.Runnable runnable, long j)`
  bool postDelayed$1(jni$_.JObject runnable, int j) {
    final _$runnable = runnable.reference;
    return _postDelayed$1(
      reference.pointer,
      _id_postDelayed$1 as jni$_.JMethodIDPtr,
      _$runnable.pointer,
      j,
    ).boolean;
  }

  static final _id_removeCallbacks = _class.instanceMethodId(
    r'removeCallbacks',
    r'(Ljava/lang/Runnable;)V',
  );

  static final _removeCallbacks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void removeCallbacks(java.lang.Runnable runnable)`
  void removeCallbacks(jni$_.JObject runnable) {
    final _$runnable = runnable.reference;
    _removeCallbacks(
      reference.pointer,
      _id_removeCallbacks as jni$_.JMethodIDPtr,
      _$runnable.pointer,
    ).check();
  }

  static final _id_removeCallbacks$1 = _class.instanceMethodId(
    r'removeCallbacks',
    r'(Ljava/lang/Runnable;Ljava/lang/Object;)V',
  );

  static final _removeCallbacks$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void removeCallbacks(java.lang.Runnable runnable, java.lang.Object object)`
  void removeCallbacks$1(jni$_.JObject runnable, jni$_.JObject? object) {
    final _$runnable = runnable.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _removeCallbacks$1(
      reference.pointer,
      _id_removeCallbacks$1 as jni$_.JMethodIDPtr,
      _$runnable.pointer,
      _$object.pointer,
    ).check();
  }

  static final _id_removeCallbacksAndMessages = _class.instanceMethodId(
    r'removeCallbacksAndMessages',
    r'(Ljava/lang/Object;)V',
  );

  static final _removeCallbacksAndMessages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void removeCallbacksAndMessages(java.lang.Object object)`
  void removeCallbacksAndMessages(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _removeCallbacksAndMessages(
      reference.pointer,
      _id_removeCallbacksAndMessages as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_removeMessages = _class.instanceMethodId(
    r'removeMessages',
    r'(I)V',
  );

  static final _removeMessages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void removeMessages(int i)`
  void removeMessages(int i) {
    _removeMessages(
      reference.pointer,
      _id_removeMessages as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_removeMessages$1 = _class.instanceMethodId(
    r'removeMessages',
    r'(ILjava/lang/Object;)V',
  );

  static final _removeMessages$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void removeMessages(int i, java.lang.Object object)`
  void removeMessages$1(int i, jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _removeMessages$1(
      reference.pointer,
      _id_removeMessages$1 as jni$_.JMethodIDPtr,
      i,
      _$object.pointer,
    ).check();
  }

  static final _id_sendEmptyMessage = _class.instanceMethodId(
    r'sendEmptyMessage',
    r'(I)Z',
  );

  static final _sendEmptyMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final boolean sendEmptyMessage(int i)`
  bool sendEmptyMessage(int i) {
    return _sendEmptyMessage(
      reference.pointer,
      _id_sendEmptyMessage as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_sendEmptyMessageAtTime = _class.instanceMethodId(
    r'sendEmptyMessageAtTime',
    r'(IJ)Z',
  );

  static final _sendEmptyMessageAtTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public final boolean sendEmptyMessageAtTime(int i, long j)`
  bool sendEmptyMessageAtTime(int i, int j) {
    return _sendEmptyMessageAtTime(
      reference.pointer,
      _id_sendEmptyMessageAtTime as jni$_.JMethodIDPtr,
      i,
      j,
    ).boolean;
  }

  static final _id_sendEmptyMessageDelayed = _class.instanceMethodId(
    r'sendEmptyMessageDelayed',
    r'(IJ)Z',
  );

  static final _sendEmptyMessageDelayed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public final boolean sendEmptyMessageDelayed(int i, long j)`
  bool sendEmptyMessageDelayed(int i, int j) {
    return _sendEmptyMessageDelayed(
      reference.pointer,
      _id_sendEmptyMessageDelayed as jni$_.JMethodIDPtr,
      i,
      j,
    ).boolean;
  }

  static final _id_sendMessage = _class.instanceMethodId(
    r'sendMessage',
    r'(Landroid/os/Message;)Z',
  );

  static final _sendMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean sendMessage(android.os.Message message)`
  bool sendMessage(jni$_.JObject message) {
    final _$message = message.reference;
    return _sendMessage(
      reference.pointer,
      _id_sendMessage as jni$_.JMethodIDPtr,
      _$message.pointer,
    ).boolean;
  }

  static final _id_sendMessageAtFrontOfQueue = _class.instanceMethodId(
    r'sendMessageAtFrontOfQueue',
    r'(Landroid/os/Message;)Z',
  );

  static final _sendMessageAtFrontOfQueue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean sendMessageAtFrontOfQueue(android.os.Message message)`
  bool sendMessageAtFrontOfQueue(jni$_.JObject message) {
    final _$message = message.reference;
    return _sendMessageAtFrontOfQueue(
      reference.pointer,
      _id_sendMessageAtFrontOfQueue as jni$_.JMethodIDPtr,
      _$message.pointer,
    ).boolean;
  }

  static final _id_sendMessageAtTime = _class.instanceMethodId(
    r'sendMessageAtTime',
    r'(Landroid/os/Message;J)Z',
  );

  static final _sendMessageAtTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public boolean sendMessageAtTime(android.os.Message message, long j)`
  bool sendMessageAtTime(jni$_.JObject message, int j) {
    final _$message = message.reference;
    return _sendMessageAtTime(
      reference.pointer,
      _id_sendMessageAtTime as jni$_.JMethodIDPtr,
      _$message.pointer,
      j,
    ).boolean;
  }

  static final _id_sendMessageDelayed = _class.instanceMethodId(
    r'sendMessageDelayed',
    r'(Landroid/os/Message;J)Z',
  );

  static final _sendMessageDelayed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public final boolean sendMessageDelayed(android.os.Message message, long j)`
  bool sendMessageDelayed(jni$_.JObject message, int j) {
    final _$message = message.reference;
    return _sendMessageDelayed(
      reference.pointer,
      _id_sendMessageDelayed as jni$_.JMethodIDPtr,
      _$message.pointer,
      j,
    ).boolean;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $Handler$NullableType$ extends jni$_.JType<Handler?> {
  @jni$_.internal
  const $Handler$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Handler;';

  @jni$_.internal
  @core$_.override
  Handler? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Handler.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Handler?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Handler$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Handler$NullableType$) &&
        other is $Handler$NullableType$;
  }
}

final class $Handler$Type$ extends jni$_.JType<Handler> {
  @jni$_.internal
  const $Handler$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Handler;';

  @jni$_.internal
  @core$_.override
  Handler fromReference(jni$_.JReference reference) =>
      Handler.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Handler?> get nullableType => const $Handler$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Handler$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Handler$Type$) && other is $Handler$Type$;
  }
}
