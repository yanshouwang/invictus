// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../java/util/concurrent/Executor.dart' as executor$_;

/// from: `android.os.PowerManager$OnThermalHeadroomChangedListener`
class PowerManager$OnThermalHeadroomChangedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<PowerManager$OnThermalHeadroomChangedListener> $type;

  @jni$_.internal
  PowerManager$OnThermalHeadroomChangedListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/os/PowerManager$OnThermalHeadroomChangedListener',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager$OnThermalHeadroomChangedListener?>
  nullableType = $PowerManager$OnThermalHeadroomChangedListener$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager$OnThermalHeadroomChangedListener> type =
      $PowerManager$OnThermalHeadroomChangedListener$Type$();
  static final _id_onThermalHeadroomChanged = _class.instanceMethodId(
    r'onThermalHeadroomChanged',
    r'(FFILjava/util/Map;)V',
  );

  static final _onThermalHeadroomChanged =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Double,
                    jni$_.Double,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              double,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onThermalHeadroomChanged(float f, float f1, int i, java.util.Map<java.lang.Integer, java.lang.Float> map)`
  void onThermalHeadroomChanged(
    double f,
    double f1,
    int i,
    jni$_.JMap<jni$_.JInteger?, jni$_.JFloat?> map,
  ) {
    final _$map = map.reference;
    _onThermalHeadroomChanged(
      reference.pointer,
      _id_onThermalHeadroomChanged as jni$_.JMethodIDPtr,
      f,
      f1,
      i,
      _$map.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $PowerManager$OnThermalHeadroomChangedListener>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onThermalHeadroomChanged(FFILjava/util/Map;)V') {
        _$impls[$p]!.onThermalHeadroomChanged(
          $a![0]!
              .as(const jni$_.$JFloat$Type$(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
          $a![1]!
              .as(const jni$_.$JFloat$Type$(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.$JInteger$Type$(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![3]!.as(
            const jni$_.$JMap$Type$<jni$_.JInteger?, jni$_.JFloat?>(
              jni$_.$JInteger$NullableType$(),
              jni$_.$JFloat$NullableType$(),
            ),
            releaseOriginal: true,
          ),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $PowerManager$OnThermalHeadroomChangedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'android.os.PowerManager$OnThermalHeadroomChangedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onThermalHeadroomChanged$async)
          r'onThermalHeadroomChanged(FFILjava/util/Map;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory PowerManager$OnThermalHeadroomChangedListener.implement(
    $PowerManager$OnThermalHeadroomChangedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return PowerManager$OnThermalHeadroomChangedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $PowerManager$OnThermalHeadroomChangedListener {
  factory $PowerManager$OnThermalHeadroomChangedListener({
    required void Function(
      double f,
      double f1,
      int i,
      jni$_.JMap<jni$_.JInteger?, jni$_.JFloat?> map,
    )
    onThermalHeadroomChanged,
    bool onThermalHeadroomChanged$async,
  }) = _$PowerManager$OnThermalHeadroomChangedListener;

  void onThermalHeadroomChanged(
    double f,
    double f1,
    int i,
    jni$_.JMap<jni$_.JInteger?, jni$_.JFloat?> map,
  );
  bool get onThermalHeadroomChanged$async => false;
}

final class _$PowerManager$OnThermalHeadroomChangedListener
    with $PowerManager$OnThermalHeadroomChangedListener {
  _$PowerManager$OnThermalHeadroomChangedListener({
    required void Function(
      double f,
      double f1,
      int i,
      jni$_.JMap<jni$_.JInteger?, jni$_.JFloat?> map,
    )
    onThermalHeadroomChanged,
    this.onThermalHeadroomChanged$async = false,
  }) : _onThermalHeadroomChanged = onThermalHeadroomChanged;

  final void Function(
    double f,
    double f1,
    int i,
    jni$_.JMap<jni$_.JInteger?, jni$_.JFloat?> map,
  )
  _onThermalHeadroomChanged;
  final bool onThermalHeadroomChanged$async;

  void onThermalHeadroomChanged(
    double f,
    double f1,
    int i,
    jni$_.JMap<jni$_.JInteger?, jni$_.JFloat?> map,
  ) {
    return _onThermalHeadroomChanged(f, f1, i, map);
  }
}

final class $PowerManager$OnThermalHeadroomChangedListener$NullableType$
    extends jni$_.JType<PowerManager$OnThermalHeadroomChangedListener?> {
  @jni$_.internal
  const $PowerManager$OnThermalHeadroomChangedListener$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/os/PowerManager$OnThermalHeadroomChangedListener;';

  @jni$_.internal
  @core$_.override
  PowerManager$OnThermalHeadroomChangedListener? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : PowerManager$OnThermalHeadroomChangedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager$OnThermalHeadroomChangedListener?>
  get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($PowerManager$OnThermalHeadroomChangedListener$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PowerManager$OnThermalHeadroomChangedListener$NullableType$) &&
        other is $PowerManager$OnThermalHeadroomChangedListener$NullableType$;
  }
}

final class $PowerManager$OnThermalHeadroomChangedListener$Type$
    extends jni$_.JType<PowerManager$OnThermalHeadroomChangedListener> {
  @jni$_.internal
  const $PowerManager$OnThermalHeadroomChangedListener$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/os/PowerManager$OnThermalHeadroomChangedListener;';

  @jni$_.internal
  @core$_.override
  PowerManager$OnThermalHeadroomChangedListener fromReference(
    jni$_.JReference reference,
  ) => PowerManager$OnThermalHeadroomChangedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager$OnThermalHeadroomChangedListener?>
  get nullableType =>
      const $PowerManager$OnThermalHeadroomChangedListener$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($PowerManager$OnThermalHeadroomChangedListener$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PowerManager$OnThermalHeadroomChangedListener$Type$) &&
        other is $PowerManager$OnThermalHeadroomChangedListener$Type$;
  }
}

/// from: `android.os.PowerManager$OnThermalStatusChangedListener`
class PowerManager$OnThermalStatusChangedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<PowerManager$OnThermalStatusChangedListener> $type;

  @jni$_.internal
  PowerManager$OnThermalStatusChangedListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/os/PowerManager$OnThermalStatusChangedListener',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager$OnThermalStatusChangedListener?>
  nullableType = $PowerManager$OnThermalStatusChangedListener$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager$OnThermalStatusChangedListener> type =
      $PowerManager$OnThermalStatusChangedListener$Type$();
  static final _id_onThermalStatusChanged = _class.instanceMethodId(
    r'onThermalStatusChanged',
    r'(I)V',
  );

  static final _onThermalStatusChanged =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void onThermalStatusChanged(int i)`
  void onThermalStatusChanged(int i) {
    _onThermalStatusChanged(
      reference.pointer,
      _id_onThermalStatusChanged as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $PowerManager$OnThermalStatusChangedListener>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onThermalStatusChanged(I)V') {
        _$impls[$p]!.onThermalStatusChanged(
          $a![0]!
              .as(const jni$_.$JInteger$Type$(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $PowerManager$OnThermalStatusChangedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'android.os.PowerManager$OnThermalStatusChangedListener',
      $p,
      _$invokePointer,
      [if ($impl.onThermalStatusChanged$async) r'onThermalStatusChanged(I)V'],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory PowerManager$OnThermalStatusChangedListener.implement(
    $PowerManager$OnThermalStatusChangedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return PowerManager$OnThermalStatusChangedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $PowerManager$OnThermalStatusChangedListener {
  factory $PowerManager$OnThermalStatusChangedListener({
    required void Function(int i) onThermalStatusChanged,
    bool onThermalStatusChanged$async,
  }) = _$PowerManager$OnThermalStatusChangedListener;

  void onThermalStatusChanged(int i);
  bool get onThermalStatusChanged$async => false;
}

final class _$PowerManager$OnThermalStatusChangedListener
    with $PowerManager$OnThermalStatusChangedListener {
  _$PowerManager$OnThermalStatusChangedListener({
    required void Function(int i) onThermalStatusChanged,
    this.onThermalStatusChanged$async = false,
  }) : _onThermalStatusChanged = onThermalStatusChanged;

  final void Function(int i) _onThermalStatusChanged;
  final bool onThermalStatusChanged$async;

  void onThermalStatusChanged(int i) {
    return _onThermalStatusChanged(i);
  }
}

final class $PowerManager$OnThermalStatusChangedListener$NullableType$
    extends jni$_.JType<PowerManager$OnThermalStatusChangedListener?> {
  @jni$_.internal
  const $PowerManager$OnThermalStatusChangedListener$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/os/PowerManager$OnThermalStatusChangedListener;';

  @jni$_.internal
  @core$_.override
  PowerManager$OnThermalStatusChangedListener? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : PowerManager$OnThermalStatusChangedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager$OnThermalStatusChangedListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($PowerManager$OnThermalStatusChangedListener$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PowerManager$OnThermalStatusChangedListener$NullableType$) &&
        other is $PowerManager$OnThermalStatusChangedListener$NullableType$;
  }
}

final class $PowerManager$OnThermalStatusChangedListener$Type$
    extends jni$_.JType<PowerManager$OnThermalStatusChangedListener> {
  @jni$_.internal
  const $PowerManager$OnThermalStatusChangedListener$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/os/PowerManager$OnThermalStatusChangedListener;';

  @jni$_.internal
  @core$_.override
  PowerManager$OnThermalStatusChangedListener fromReference(
    jni$_.JReference reference,
  ) => PowerManager$OnThermalStatusChangedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager$OnThermalStatusChangedListener?> get nullableType =>
      const $PowerManager$OnThermalStatusChangedListener$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($PowerManager$OnThermalStatusChangedListener$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PowerManager$OnThermalStatusChangedListener$Type$) &&
        other is $PowerManager$OnThermalStatusChangedListener$Type$;
  }
}

/// from: `android.os.PowerManager$WakeLock`
class PowerManager$WakeLock extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<PowerManager$WakeLock> $type;

  @jni$_.internal
  PowerManager$WakeLock.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/os/PowerManager$WakeLock',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager$WakeLock?> nullableType =
      $PowerManager$WakeLock$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager$WakeLock> type =
      $PowerManager$WakeLock$Type$();
  static final _id_acquire = _class.instanceMethodId(r'acquire', r'()V');

  static final _acquire =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void acquire()`
  void acquire() {
    _acquire(reference.pointer, _id_acquire as jni$_.JMethodIDPtr).check();
  }

  static final _id_acquire$1 = _class.instanceMethodId(r'acquire', r'(J)V');

  static final _acquire$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void acquire(long j)`
  void acquire$1(int j) {
    _acquire$1(
      reference.pointer,
      _id_acquire$1 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_isHeld = _class.instanceMethodId(r'isHeld', r'()Z');

  static final _isHeld =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isHeld()`
  bool isHeld() {
    return _isHeld(reference.pointer, _id_isHeld as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_release$1 = _class.instanceMethodId(r'release', r'()V');

  static final _release$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void release()`
  void release$1() {
    _release$1(reference.pointer, _id_release$1 as jni$_.JMethodIDPtr).check();
  }

  static final _id_release$2 = _class.instanceMethodId(r'release', r'(I)V');

  static final _release$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void release(int i)`
  void release$2(int i) {
    _release$2(
      reference.pointer,
      _id_release$2 as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setReferenceCounted = _class.instanceMethodId(
    r'setReferenceCounted',
    r'(Z)V',
  );

  static final _setReferenceCounted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReferenceCounted(boolean z)`
  void setReferenceCounted(bool z) {
    _setReferenceCounted(
      reference.pointer,
      _id_setReferenceCounted as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setStateListener = _class.instanceMethodId(
    r'setStateListener',
    r'(Ljava/util/concurrent/Executor;Landroid/os/PowerManager$WakeLockStateListener;)V',
  );

  static final _setStateListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStateListener(java.util.concurrent.Executor executor, android.os.PowerManager$WakeLockStateListener wakeLockStateListener)`
  void setStateListener(
    executor$_.Executor executor,
    PowerManager$WakeLockStateListener? wakeLockStateListener,
  ) {
    final _$executor = executor.reference;
    final _$wakeLockStateListener =
        wakeLockStateListener?.reference ?? jni$_.jNullReference;
    _setStateListener(
      reference.pointer,
      _id_setStateListener as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$wakeLockStateListener.pointer,
    ).check();
  }

  static final _id_setWorkSource = _class.instanceMethodId(
    r'setWorkSource',
    r'(Landroid/os/WorkSource;)V',
  );

  static final _setWorkSource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setWorkSource(android.os.WorkSource workSource)`
  void setWorkSource(jni$_.JObject? workSource) {
    final _$workSource = workSource?.reference ?? jni$_.jNullReference;
    _setWorkSource(
      reference.pointer,
      _id_setWorkSource as jni$_.JMethodIDPtr,
      _$workSource.pointer,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $PowerManager$WakeLock$NullableType$
    extends jni$_.JType<PowerManager$WakeLock?> {
  @jni$_.internal
  const $PowerManager$WakeLock$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/PowerManager$WakeLock;';

  @jni$_.internal
  @core$_.override
  PowerManager$WakeLock? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PowerManager$WakeLock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager$WakeLock?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PowerManager$WakeLock$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PowerManager$WakeLock$NullableType$) &&
        other is $PowerManager$WakeLock$NullableType$;
  }
}

final class $PowerManager$WakeLock$Type$
    extends jni$_.JType<PowerManager$WakeLock> {
  @jni$_.internal
  const $PowerManager$WakeLock$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/PowerManager$WakeLock;';

  @jni$_.internal
  @core$_.override
  PowerManager$WakeLock fromReference(jni$_.JReference reference) =>
      PowerManager$WakeLock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager$WakeLock?> get nullableType =>
      const $PowerManager$WakeLock$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PowerManager$WakeLock$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PowerManager$WakeLock$Type$) &&
        other is $PowerManager$WakeLock$Type$;
  }
}

/// from: `android.os.PowerManager$WakeLockStateListener`
class PowerManager$WakeLockStateListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<PowerManager$WakeLockStateListener> $type;

  @jni$_.internal
  PowerManager$WakeLockStateListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/os/PowerManager$WakeLockStateListener',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager$WakeLockStateListener?> nullableType =
      $PowerManager$WakeLockStateListener$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager$WakeLockStateListener> type =
      $PowerManager$WakeLockStateListener$Type$();
  static final _id_onStateChanged = _class.instanceMethodId(
    r'onStateChanged',
    r'(Z)V',
  );

  static final _onStateChanged =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void onStateChanged(boolean z)`
  void onStateChanged(bool z) {
    _onStateChanged(
      reference.pointer,
      _id_onStateChanged as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $PowerManager$WakeLockStateListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onStateChanged(Z)V') {
        _$impls[$p]!.onStateChanged(
          $a![0]!
              .as(const jni$_.$JBoolean$Type$(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $PowerManager$WakeLockStateListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'android.os.PowerManager$WakeLockStateListener',
      $p,
      _$invokePointer,
      [if ($impl.onStateChanged$async) r'onStateChanged(Z)V'],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory PowerManager$WakeLockStateListener.implement(
    $PowerManager$WakeLockStateListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return PowerManager$WakeLockStateListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $PowerManager$WakeLockStateListener {
  factory $PowerManager$WakeLockStateListener({
    required void Function(bool z) onStateChanged,
    bool onStateChanged$async,
  }) = _$PowerManager$WakeLockStateListener;

  void onStateChanged(bool z);
  bool get onStateChanged$async => false;
}

final class _$PowerManager$WakeLockStateListener
    with $PowerManager$WakeLockStateListener {
  _$PowerManager$WakeLockStateListener({
    required void Function(bool z) onStateChanged,
    this.onStateChanged$async = false,
  }) : _onStateChanged = onStateChanged;

  final void Function(bool z) _onStateChanged;
  final bool onStateChanged$async;

  void onStateChanged(bool z) {
    return _onStateChanged(z);
  }
}

final class $PowerManager$WakeLockStateListener$NullableType$
    extends jni$_.JType<PowerManager$WakeLockStateListener?> {
  @jni$_.internal
  const $PowerManager$WakeLockStateListener$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/PowerManager$WakeLockStateListener;';

  @jni$_.internal
  @core$_.override
  PowerManager$WakeLockStateListener? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : PowerManager$WakeLockStateListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager$WakeLockStateListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($PowerManager$WakeLockStateListener$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PowerManager$WakeLockStateListener$NullableType$) &&
        other is $PowerManager$WakeLockStateListener$NullableType$;
  }
}

final class $PowerManager$WakeLockStateListener$Type$
    extends jni$_.JType<PowerManager$WakeLockStateListener> {
  @jni$_.internal
  const $PowerManager$WakeLockStateListener$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/PowerManager$WakeLockStateListener;';

  @jni$_.internal
  @core$_.override
  PowerManager$WakeLockStateListener fromReference(
    jni$_.JReference reference,
  ) => PowerManager$WakeLockStateListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager$WakeLockStateListener?> get nullableType =>
      const $PowerManager$WakeLockStateListener$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PowerManager$WakeLockStateListener$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PowerManager$WakeLockStateListener$Type$) &&
        other is $PowerManager$WakeLockStateListener$Type$;
  }
}

/// from: `android.os.PowerManager`
class PowerManager extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<PowerManager> $type;

  @jni$_.internal
  PowerManager.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/PowerManager');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager?> nullableType =
      $PowerManager$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PowerManager> type = $PowerManager$Type$();

  /// from: `static public final int ACQUIRE_CAUSES_WAKEUP`
  static const ACQUIRE_CAUSES_WAKEUP = 268435456;
  static final _id_ACTION_DEVICE_IDLE_MODE_CHANGED = _class.staticFieldId(
    r'ACTION_DEVICE_IDLE_MODE_CHANGED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_DEVICE_IDLE_MODE_CHANGED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_DEVICE_IDLE_MODE_CHANGED =>
      _id_ACTION_DEVICE_IDLE_MODE_CHANGED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED = _class.staticFieldId(
    r'ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED =>
      _id_ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_ACTION_LOW_POWER_STANDBY_ENABLED_CHANGED = _class
      .staticFieldId(
        r'ACTION_LOW_POWER_STANDBY_ENABLED_CHANGED',
        r'Ljava/lang/String;',
      );

  /// from: `static public final java.lang.String ACTION_LOW_POWER_STANDBY_ENABLED_CHANGED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_LOW_POWER_STANDBY_ENABLED_CHANGED =>
      _id_ACTION_LOW_POWER_STANDBY_ENABLED_CHANGED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_ACTION_LOW_POWER_STANDBY_POLICY_CHANGED = _class
      .staticFieldId(
        r'ACTION_LOW_POWER_STANDBY_POLICY_CHANGED',
        r'Ljava/lang/String;',
      );

  /// from: `static public final java.lang.String ACTION_LOW_POWER_STANDBY_POLICY_CHANGED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_LOW_POWER_STANDBY_POLICY_CHANGED =>
      _id_ACTION_LOW_POWER_STANDBY_POLICY_CHANGED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_ACTION_POWER_SAVE_MODE_CHANGED = _class.staticFieldId(
    r'ACTION_POWER_SAVE_MODE_CHANGED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTION_POWER_SAVE_MODE_CHANGED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTION_POWER_SAVE_MODE_CHANGED =>
      _id_ACTION_POWER_SAVE_MODE_CHANGED.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  static final _id_FEATURE_WAKE_ON_LAN_IN_LOW_POWER_STANDBY = _class
      .staticFieldId(
        r'FEATURE_WAKE_ON_LAN_IN_LOW_POWER_STANDBY',
        r'Ljava/lang/String;',
      );

  /// from: `static public final java.lang.String FEATURE_WAKE_ON_LAN_IN_LOW_POWER_STANDBY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FEATURE_WAKE_ON_LAN_IN_LOW_POWER_STANDBY =>
      _id_FEATURE_WAKE_ON_LAN_IN_LOW_POWER_STANDBY.get(
        _class,
        const jni$_.$JString$NullableType$(),
      );

  /// from: `static public final int FULL_WAKE_LOCK`
  static const FULL_WAKE_LOCK = 26;

  /// from: `static public final int LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF`
  static const LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF = 2;

  /// from: `static public final int LOCATION_MODE_FOREGROUND_ONLY`
  static const LOCATION_MODE_FOREGROUND_ONLY = 3;

  /// from: `static public final int LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF`
  static const LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF = 1;

  /// from: `static public final int LOCATION_MODE_NO_CHANGE`
  static const LOCATION_MODE_NO_CHANGE = 0;

  /// from: `static public final int LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF`
  static const LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF = 4;

  /// from: `static public final int LOW_POWER_STANDBY_ALLOWED_REASON_ONGOING_CALL`
  static const LOW_POWER_STANDBY_ALLOWED_REASON_ONGOING_CALL = 4;

  /// from: `static public final int LOW_POWER_STANDBY_ALLOWED_REASON_TEMP_POWER_SAVE_ALLOWLIST`
  static const LOW_POWER_STANDBY_ALLOWED_REASON_TEMP_POWER_SAVE_ALLOWLIST = 2;

  /// from: `static public final int LOW_POWER_STANDBY_ALLOWED_REASON_VOICE_INTERACTION`
  static const LOW_POWER_STANDBY_ALLOWED_REASON_VOICE_INTERACTION = 1;

  /// from: `static public final int ON_AFTER_RELEASE`
  static const ON_AFTER_RELEASE = 536870912;

  /// from: `static public final int PARTIAL_WAKE_LOCK`
  static const PARTIAL_WAKE_LOCK = 1;

  /// from: `static public final int PROXIMITY_SCREEN_OFF_WAKE_LOCK`
  static const PROXIMITY_SCREEN_OFF_WAKE_LOCK = 32;

  /// from: `static public final int RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY`
  static const RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY = 1;

  /// from: `static public final int SCREEN_BRIGHT_WAKE_LOCK`
  static const SCREEN_BRIGHT_WAKE_LOCK = 10;

  /// from: `static public final int SCREEN_DIM_WAKE_LOCK`
  static const SCREEN_DIM_WAKE_LOCK = 6;

  /// from: `static public final int THERMAL_STATUS_CRITICAL`
  static const THERMAL_STATUS_CRITICAL = 4;

  /// from: `static public final int THERMAL_STATUS_EMERGENCY`
  static const THERMAL_STATUS_EMERGENCY = 5;

  /// from: `static public final int THERMAL_STATUS_LIGHT`
  static const THERMAL_STATUS_LIGHT = 1;

  /// from: `static public final int THERMAL_STATUS_MODERATE`
  static const THERMAL_STATUS_MODERATE = 2;

  /// from: `static public final int THERMAL_STATUS_NONE`
  static const THERMAL_STATUS_NONE = 0;

  /// from: `static public final int THERMAL_STATUS_SEVERE`
  static const THERMAL_STATUS_SEVERE = 3;

  /// from: `static public final int THERMAL_STATUS_SHUTDOWN`
  static const THERMAL_STATUS_SHUTDOWN = 6;
  static final _id_addThermalHeadroomListener = _class.instanceMethodId(
    r'addThermalHeadroomListener',
    r'(Landroid/os/PowerManager$OnThermalHeadroomChangedListener;)V',
  );

  static final _addThermalHeadroomListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addThermalHeadroomListener(android.os.PowerManager$OnThermalHeadroomChangedListener onThermalHeadroomChangedListener)`
  void addThermalHeadroomListener(
    PowerManager$OnThermalHeadroomChangedListener
    onThermalHeadroomChangedListener,
  ) {
    final _$onThermalHeadroomChangedListener =
        onThermalHeadroomChangedListener.reference;
    _addThermalHeadroomListener(
      reference.pointer,
      _id_addThermalHeadroomListener as jni$_.JMethodIDPtr,
      _$onThermalHeadroomChangedListener.pointer,
    ).check();
  }

  static final _id_addThermalHeadroomListener$1 = _class.instanceMethodId(
    r'addThermalHeadroomListener',
    r'(Ljava/util/concurrent/Executor;Landroid/os/PowerManager$OnThermalHeadroomChangedListener;)V',
  );

  static final _addThermalHeadroomListener$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addThermalHeadroomListener(java.util.concurrent.Executor executor, android.os.PowerManager$OnThermalHeadroomChangedListener onThermalHeadroomChangedListener)`
  void addThermalHeadroomListener$1(
    executor$_.Executor executor,
    PowerManager$OnThermalHeadroomChangedListener
    onThermalHeadroomChangedListener,
  ) {
    final _$executor = executor.reference;
    final _$onThermalHeadroomChangedListener =
        onThermalHeadroomChangedListener.reference;
    _addThermalHeadroomListener$1(
      reference.pointer,
      _id_addThermalHeadroomListener$1 as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$onThermalHeadroomChangedListener.pointer,
    ).check();
  }

  static final _id_addThermalStatusListener = _class.instanceMethodId(
    r'addThermalStatusListener',
    r'(Landroid/os/PowerManager$OnThermalStatusChangedListener;)V',
  );

  static final _addThermalStatusListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addThermalStatusListener(android.os.PowerManager$OnThermalStatusChangedListener onThermalStatusChangedListener)`
  void addThermalStatusListener(
    PowerManager$OnThermalStatusChangedListener onThermalStatusChangedListener,
  ) {
    final _$onThermalStatusChangedListener =
        onThermalStatusChangedListener.reference;
    _addThermalStatusListener(
      reference.pointer,
      _id_addThermalStatusListener as jni$_.JMethodIDPtr,
      _$onThermalStatusChangedListener.pointer,
    ).check();
  }

  static final _id_addThermalStatusListener$1 = _class.instanceMethodId(
    r'addThermalStatusListener',
    r'(Ljava/util/concurrent/Executor;Landroid/os/PowerManager$OnThermalStatusChangedListener;)V',
  );

  static final _addThermalStatusListener$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addThermalStatusListener(java.util.concurrent.Executor executor, android.os.PowerManager$OnThermalStatusChangedListener onThermalStatusChangedListener)`
  void addThermalStatusListener$1(
    executor$_.Executor executor,
    PowerManager$OnThermalStatusChangedListener onThermalStatusChangedListener,
  ) {
    final _$executor = executor.reference;
    final _$onThermalStatusChangedListener =
        onThermalStatusChangedListener.reference;
    _addThermalStatusListener$1(
      reference.pointer,
      _id_addThermalStatusListener$1 as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$onThermalStatusChangedListener.pointer,
    ).check();
  }

  static final _id_getBatteryDischargePrediction = _class.instanceMethodId(
    r'getBatteryDischargePrediction',
    r'()Ljava/time/Duration;',
  );

  static final _getBatteryDischargePrediction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Duration getBatteryDischargePrediction()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getBatteryDischargePrediction() {
    return _getBatteryDischargePrediction(
      reference.pointer,
      _id_getBatteryDischargePrediction as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getCurrentThermalStatus = _class.instanceMethodId(
    r'getCurrentThermalStatus',
    r'()I',
  );

  static final _getCurrentThermalStatus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getCurrentThermalStatus()`
  int getCurrentThermalStatus() {
    return _getCurrentThermalStatus(
      reference.pointer,
      _id_getCurrentThermalStatus as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getLocationPowerSaveMode = _class.instanceMethodId(
    r'getLocationPowerSaveMode',
    r'()I',
  );

  static final _getLocationPowerSaveMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLocationPowerSaveMode()`
  int getLocationPowerSaveMode() {
    return _getLocationPowerSaveMode(
      reference.pointer,
      _id_getLocationPowerSaveMode as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getThermalHeadroom = _class.instanceMethodId(
    r'getThermalHeadroom',
    r'(I)F',
  );

  static final _getThermalHeadroom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public float getThermalHeadroom(int i)`
  double getThermalHeadroom(int i) {
    return _getThermalHeadroom(
      reference.pointer,
      _id_getThermalHeadroom as jni$_.JMethodIDPtr,
      i,
    ).float;
  }

  static final _id_getThermalHeadroomThresholds = _class.instanceMethodId(
    r'getThermalHeadroomThresholds',
    r'()Ljava/util/Map;',
  );

  static final _getThermalHeadroomThresholds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Map<java.lang.Integer, java.lang.Float> getThermalHeadroomThresholds()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JInteger?, jni$_.JFloat?> getThermalHeadroomThresholds() {
    return _getThermalHeadroomThresholds(
      reference.pointer,
      _id_getThermalHeadroomThresholds as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JInteger?, jni$_.JFloat?>>(
      const jni$_.$JMap$Type$<jni$_.JInteger?, jni$_.JFloat?>(
        jni$_.$JInteger$NullableType$(),
        jni$_.$JFloat$NullableType$(),
      ),
    );
  }

  static final _id_isAllowedInLowPowerStandby = _class.instanceMethodId(
    r'isAllowedInLowPowerStandby',
    r'(I)Z',
  );

  static final _isAllowedInLowPowerStandby =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean isAllowedInLowPowerStandby(int i)`
  bool isAllowedInLowPowerStandby(int i) {
    return _isAllowedInLowPowerStandby(
      reference.pointer,
      _id_isAllowedInLowPowerStandby as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_isAllowedInLowPowerStandby$1 = _class.instanceMethodId(
    r'isAllowedInLowPowerStandby',
    r'(Ljava/lang/String;)Z',
  );

  static final _isAllowedInLowPowerStandby$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAllowedInLowPowerStandby(java.lang.String string)`
  bool isAllowedInLowPowerStandby$1(jni$_.JString string) {
    final _$string = string.reference;
    return _isAllowedInLowPowerStandby$1(
      reference.pointer,
      _id_isAllowedInLowPowerStandby$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_isBatteryDischargePredictionPersonalized = _class
      .instanceMethodId(r'isBatteryDischargePredictionPersonalized', r'()Z');

  static final _isBatteryDischargePredictionPersonalized =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBatteryDischargePredictionPersonalized()`
  bool isBatteryDischargePredictionPersonalized() {
    return _isBatteryDischargePredictionPersonalized(
      reference.pointer,
      _id_isBatteryDischargePredictionPersonalized as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isDeviceIdleMode = _class.instanceMethodId(
    r'isDeviceIdleMode',
    r'()Z',
  );

  static final _isDeviceIdleMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDeviceIdleMode()`
  bool isDeviceIdleMode() {
    return _isDeviceIdleMode(
      reference.pointer,
      _id_isDeviceIdleMode as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isDeviceLightIdleMode = _class.instanceMethodId(
    r'isDeviceLightIdleMode',
    r'()Z',
  );

  static final _isDeviceLightIdleMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDeviceLightIdleMode()`
  bool isDeviceLightIdleMode() {
    return _isDeviceLightIdleMode(
      reference.pointer,
      _id_isDeviceLightIdleMode as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isExemptFromLowPowerStandby = _class.instanceMethodId(
    r'isExemptFromLowPowerStandby',
    r'()Z',
  );

  static final _isExemptFromLowPowerStandby =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isExemptFromLowPowerStandby()`
  bool isExemptFromLowPowerStandby() {
    return _isExemptFromLowPowerStandby(
      reference.pointer,
      _id_isExemptFromLowPowerStandby as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isIgnoringBatteryOptimizations = _class.instanceMethodId(
    r'isIgnoringBatteryOptimizations',
    r'(Ljava/lang/String;)Z',
  );

  static final _isIgnoringBatteryOptimizations =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isIgnoringBatteryOptimizations(java.lang.String string)`
  bool isIgnoringBatteryOptimizations(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _isIgnoringBatteryOptimizations(
      reference.pointer,
      _id_isIgnoringBatteryOptimizations as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_isInteractive = _class.instanceMethodId(
    r'isInteractive',
    r'()Z',
  );

  static final _isInteractive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isInteractive()`
  bool isInteractive() {
    return _isInteractive(
      reference.pointer,
      _id_isInteractive as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isLowPowerStandbyEnabled = _class.instanceMethodId(
    r'isLowPowerStandbyEnabled',
    r'()Z',
  );

  static final _isLowPowerStandbyEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLowPowerStandbyEnabled()`
  bool isLowPowerStandbyEnabled() {
    return _isLowPowerStandbyEnabled(
      reference.pointer,
      _id_isLowPowerStandbyEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isPowerSaveMode = _class.instanceMethodId(
    r'isPowerSaveMode',
    r'()Z',
  );

  static final _isPowerSaveMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPowerSaveMode()`
  bool isPowerSaveMode() {
    return _isPowerSaveMode(
      reference.pointer,
      _id_isPowerSaveMode as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isRebootingUserspaceSupported = _class.instanceMethodId(
    r'isRebootingUserspaceSupported',
    r'()Z',
  );

  static final _isRebootingUserspaceSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isRebootingUserspaceSupported()`
  bool isRebootingUserspaceSupported() {
    return _isRebootingUserspaceSupported(
      reference.pointer,
      _id_isRebootingUserspaceSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isScreenOn = _class.instanceMethodId(r'isScreenOn', r'()Z');

  static final _isScreenOn =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isScreenOn()`
  bool isScreenOn() {
    return _isScreenOn(
      reference.pointer,
      _id_isScreenOn as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isSustainedPerformanceModeSupported = _class
      .instanceMethodId(r'isSustainedPerformanceModeSupported', r'()Z');

  static final _isSustainedPerformanceModeSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isSustainedPerformanceModeSupported()`
  bool isSustainedPerformanceModeSupported() {
    return _isSustainedPerformanceModeSupported(
      reference.pointer,
      _id_isSustainedPerformanceModeSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isWakeLockLevelSupported = _class.instanceMethodId(
    r'isWakeLockLevelSupported',
    r'(I)Z',
  );

  static final _isWakeLockLevelSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean isWakeLockLevelSupported(int i)`
  bool isWakeLockLevelSupported(int i) {
    return _isWakeLockLevelSupported(
      reference.pointer,
      _id_isWakeLockLevelSupported as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_newWakeLock = _class.instanceMethodId(
    r'newWakeLock',
    r'(ILjava/lang/String;)Landroid/os/PowerManager$WakeLock;',
  );

  static final _newWakeLock =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.os.PowerManager$WakeLock newWakeLock(int i, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  PowerManager$WakeLock? newWakeLock(int i, jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _newWakeLock(
      reference.pointer,
      _id_newWakeLock as jni$_.JMethodIDPtr,
      i,
      _$string.pointer,
    ).object<PowerManager$WakeLock?>(
      const $PowerManager$WakeLock$NullableType$(),
    );
  }

  static final _id_reboot = _class.instanceMethodId(
    r'reboot',
    r'(Ljava/lang/String;)V',
  );

  static final _reboot =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void reboot(java.lang.String string)`
  void reboot(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _reboot(
      reference.pointer,
      _id_reboot as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_removeThermalHeadroomListener = _class.instanceMethodId(
    r'removeThermalHeadroomListener',
    r'(Landroid/os/PowerManager$OnThermalHeadroomChangedListener;)V',
  );

  static final _removeThermalHeadroomListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeThermalHeadroomListener(android.os.PowerManager$OnThermalHeadroomChangedListener onThermalHeadroomChangedListener)`
  void removeThermalHeadroomListener(
    PowerManager$OnThermalHeadroomChangedListener
    onThermalHeadroomChangedListener,
  ) {
    final _$onThermalHeadroomChangedListener =
        onThermalHeadroomChangedListener.reference;
    _removeThermalHeadroomListener(
      reference.pointer,
      _id_removeThermalHeadroomListener as jni$_.JMethodIDPtr,
      _$onThermalHeadroomChangedListener.pointer,
    ).check();
  }

  static final _id_removeThermalStatusListener = _class.instanceMethodId(
    r'removeThermalStatusListener',
    r'(Landroid/os/PowerManager$OnThermalStatusChangedListener;)V',
  );

  static final _removeThermalStatusListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeThermalStatusListener(android.os.PowerManager$OnThermalStatusChangedListener onThermalStatusChangedListener)`
  void removeThermalStatusListener(
    PowerManager$OnThermalStatusChangedListener onThermalStatusChangedListener,
  ) {
    final _$onThermalStatusChangedListener =
        onThermalStatusChangedListener.reference;
    _removeThermalStatusListener(
      reference.pointer,
      _id_removeThermalStatusListener as jni$_.JMethodIDPtr,
      _$onThermalStatusChangedListener.pointer,
    ).check();
  }
}

final class $PowerManager$NullableType$ extends jni$_.JType<PowerManager?> {
  @jni$_.internal
  const $PowerManager$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/PowerManager;';

  @jni$_.internal
  @core$_.override
  PowerManager? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PowerManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PowerManager$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PowerManager$NullableType$) &&
        other is $PowerManager$NullableType$;
  }
}

final class $PowerManager$Type$ extends jni$_.JType<PowerManager> {
  @jni$_.internal
  const $PowerManager$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/PowerManager;';

  @jni$_.internal
  @core$_.override
  PowerManager fromReference(jni$_.JReference reference) =>
      PowerManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PowerManager?> get nullableType =>
      const $PowerManager$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PowerManager$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PowerManager$Type$) &&
        other is $PowerManager$Type$;
  }
}
