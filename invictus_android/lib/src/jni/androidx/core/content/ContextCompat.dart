// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../../android/content/BroadcastReceiver.dart' as broadcastreceiver$_;

import '../../../android/content/Context.dart' as context$_;

import '../../../android/content/Intent.dart' as intent$_;

import '../../../android/content/IntentFilter.dart' as intentfilter$_;

import '../../../android/os/Handler.dart' as handler$_;

import '../../../java/util/concurrent/Executor.dart' as executor$_;

/// from: `androidx.core.content.ContextCompat$RegisterReceiverFlags`
class ContextCompat$RegisterReceiverFlags extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ContextCompat$RegisterReceiverFlags> $type;

  @jni$_.internal
  ContextCompat$RegisterReceiverFlags.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/core/content/ContextCompat$RegisterReceiverFlags',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ContextCompat$RegisterReceiverFlags?> nullableType =
      $ContextCompat$RegisterReceiverFlags$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ContextCompat$RegisterReceiverFlags> type =
      $ContextCompat$RegisterReceiverFlags$Type$();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ContextCompat$RegisterReceiverFlags> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ContextCompat$RegisterReceiverFlags $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.core.content.ContextCompat$RegisterReceiverFlags',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ContextCompat$RegisterReceiverFlags.implement(
    $ContextCompat$RegisterReceiverFlags $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ContextCompat$RegisterReceiverFlags.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ContextCompat$RegisterReceiverFlags {
  factory $ContextCompat$RegisterReceiverFlags() =
      _$ContextCompat$RegisterReceiverFlags;
}

final class _$ContextCompat$RegisterReceiverFlags
    with $ContextCompat$RegisterReceiverFlags {
  _$ContextCompat$RegisterReceiverFlags();
}

final class $ContextCompat$RegisterReceiverFlags$NullableType$
    extends jni$_.JType<ContextCompat$RegisterReceiverFlags?> {
  @jni$_.internal
  const $ContextCompat$RegisterReceiverFlags$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/core/content/ContextCompat$RegisterReceiverFlags;';

  @jni$_.internal
  @core$_.override
  ContextCompat$RegisterReceiverFlags? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : ContextCompat$RegisterReceiverFlags.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ContextCompat$RegisterReceiverFlags?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ContextCompat$RegisterReceiverFlags$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ContextCompat$RegisterReceiverFlags$NullableType$) &&
        other is $ContextCompat$RegisterReceiverFlags$NullableType$;
  }
}

final class $ContextCompat$RegisterReceiverFlags$Type$
    extends jni$_.JType<ContextCompat$RegisterReceiverFlags> {
  @jni$_.internal
  const $ContextCompat$RegisterReceiverFlags$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/core/content/ContextCompat$RegisterReceiverFlags;';

  @jni$_.internal
  @core$_.override
  ContextCompat$RegisterReceiverFlags fromReference(
    jni$_.JReference reference,
  ) => ContextCompat$RegisterReceiverFlags.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ContextCompat$RegisterReceiverFlags?> get nullableType =>
      const $ContextCompat$RegisterReceiverFlags$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContextCompat$RegisterReceiverFlags$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContextCompat$RegisterReceiverFlags$Type$) &&
        other is $ContextCompat$RegisterReceiverFlags$Type$;
  }
}

/// from: `androidx.core.content.ContextCompat`
class ContextCompat extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ContextCompat> $type;

  @jni$_.internal
  ContextCompat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/core/content/ContextCompat',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ContextCompat?> nullableType =
      $ContextCompat$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ContextCompat> type = $ContextCompat$Type$();

  /// from: `static public final int RECEIVER_VISIBLE_TO_INSTANT_APPS`
  static const RECEIVER_VISIBLE_TO_INSTANT_APPS = 1;

  /// from: `static public final int RECEIVER_EXPORTED`
  static const RECEIVER_EXPORTED = 2;

  /// from: `static public final int RECEIVER_NOT_EXPORTED`
  static const RECEIVER_NOT_EXPORTED = 4;
  static final _id_startActivities = _class.staticMethodId(
    r'startActivities',
    r'(Landroid/content/Context;[Landroid/content/Intent;)Z',
  );

  static final _startActivities =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public boolean startActivities(android.content.Context context, android.content.Intent[] intents)`
  static bool startActivities(
    context$_.Context context,
    jni$_.JArray<intent$_.Intent?> intents,
  ) {
    final _$context = context.reference;
    final _$intents = intents.reference;
    return _startActivities(
      _class.reference.pointer,
      _id_startActivities as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$intents.pointer,
    ).boolean;
  }

  static final _id_startActivities$1 = _class.staticMethodId(
    r'startActivities',
    r'(Landroid/content/Context;[Landroid/content/Intent;Landroid/os/Bundle;)Z',
  );

  static final _startActivities$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public boolean startActivities(android.content.Context context, android.content.Intent[] intents, android.os.Bundle bundle)`
  static bool startActivities$1(
    context$_.Context context,
    jni$_.JArray<intent$_.Intent?> intents,
    jni$_.JObject? bundle,
  ) {
    final _$context = context.reference;
    final _$intents = intents.reference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _startActivities$1(
      _class.reference.pointer,
      _id_startActivities$1 as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$intents.pointer,
      _$bundle.pointer,
    ).boolean;
  }

  static final _id_startActivity = _class.staticMethodId(
    r'startActivity',
    r'(Landroid/content/Context;Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivity =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void startActivity(android.content.Context context, android.content.Intent intent, android.os.Bundle bundle)`
  static void startActivity(
    context$_.Context context,
    intent$_.Intent intent,
    jni$_.JObject? bundle,
  ) {
    final _$context = context.reference;
    final _$intent = intent.reference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _startActivity(
      _class.reference.pointer,
      _id_startActivity as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$intent.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_getDataDir = _class.staticMethodId(
    r'getDataDir',
    r'(Landroid/content/Context;)Ljava/io/File;',
  );

  static final _getDataDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File getDataDir(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getDataDir(context$_.Context context) {
    final _$context = context.reference;
    return _getDataDir(
      _class.reference.pointer,
      _id_getDataDir as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getObbDirs = _class.staticMethodId(
    r'getObbDirs',
    r'(Landroid/content/Context;)[Ljava/io/File;',
  );

  static final _getObbDirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File[] getObbDirs(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?> getObbDirs(context$_.Context context) {
    final _$context = context.reference;
    return _getObbDirs(
      _class.reference.pointer,
      _id_getObbDirs as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<jni$_.JArray<jni$_.JObject?>>(
      const jni$_.$JArray$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getExternalFilesDirs = _class.staticMethodId(
    r'getExternalFilesDirs',
    r'(Landroid/content/Context;Ljava/lang/String;)[Ljava/io/File;',
  );

  static final _getExternalFilesDirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File[] getExternalFilesDirs(android.content.Context context, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?> getExternalFilesDirs(
    context$_.Context context,
    jni$_.JString? string,
  ) {
    final _$context = context.reference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getExternalFilesDirs(
      _class.reference.pointer,
      _id_getExternalFilesDirs as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).object<jni$_.JArray<jni$_.JObject?>>(
      const jni$_.$JArray$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getExternalCacheDirs = _class.staticMethodId(
    r'getExternalCacheDirs',
    r'(Landroid/content/Context;)[Ljava/io/File;',
  );

  static final _getExternalCacheDirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File[] getExternalCacheDirs(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?> getExternalCacheDirs(
    context$_.Context context,
  ) {
    final _$context = context.reference;
    return _getExternalCacheDirs(
      _class.reference.pointer,
      _id_getExternalCacheDirs as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<jni$_.JArray<jni$_.JObject?>>(
      const jni$_.$JArray$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getDrawable = _class.staticMethodId(
    r'getDrawable',
    r'(Landroid/content/Context;I)Landroid/graphics/drawable/Drawable;',
  );

  static final _getDrawable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public android.graphics.drawable.Drawable getDrawable(android.content.Context context, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getDrawable(context$_.Context context, int i) {
    final _$context = context.reference;
    return _getDrawable(
      _class.reference.pointer,
      _id_getDrawable as jni$_.JMethodIDPtr,
      _$context.pointer,
      i,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getColorStateList = _class.staticMethodId(
    r'getColorStateList',
    r'(Landroid/content/Context;I)Landroid/content/res/ColorStateList;',
  );

  static final _getColorStateList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public android.content.res.ColorStateList getColorStateList(android.content.Context context, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getColorStateList(context$_.Context context, int i) {
    final _$context = context.reference;
    return _getColorStateList(
      _class.reference.pointer,
      _id_getColorStateList as jni$_.JMethodIDPtr,
      _$context.pointer,
      i,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getColor = _class.staticMethodId(
    r'getColor',
    r'(Landroid/content/Context;I)I',
  );

  static final _getColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public int getColor(android.content.Context context, int i)`
  static int getColor(context$_.Context context, int i) {
    final _$context = context.reference;
    return _getColor(
      _class.reference.pointer,
      _id_getColor as jni$_.JMethodIDPtr,
      _$context.pointer,
      i,
    ).integer;
  }

  static final _id_checkSelfPermission = _class.staticMethodId(
    r'checkSelfPermission',
    r'(Landroid/content/Context;Ljava/lang/String;)I',
  );

  static final _checkSelfPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public int checkSelfPermission(android.content.Context context, java.lang.String string)`
  static int checkSelfPermission(
    context$_.Context context,
    jni$_.JString string,
  ) {
    final _$context = context.reference;
    final _$string = string.reference;
    return _checkSelfPermission(
      _class.reference.pointer,
      _id_checkSelfPermission as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).integer;
  }

  static final _id_getNoBackupFilesDir = _class.staticMethodId(
    r'getNoBackupFilesDir',
    r'(Landroid/content/Context;)Ljava/io/File;',
  );

  static final _getNoBackupFilesDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File getNoBackupFilesDir(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getNoBackupFilesDir(context$_.Context context) {
    final _$context = context.reference;
    return _getNoBackupFilesDir(
      _class.reference.pointer,
      _id_getNoBackupFilesDir as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getCodeCacheDir = _class.staticMethodId(
    r'getCodeCacheDir',
    r'(Landroid/content/Context;)Ljava/io/File;',
  );

  static final _getCodeCacheDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File getCodeCacheDir(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getCodeCacheDir(context$_.Context context) {
    final _$context = context.reference;
    return _getCodeCacheDir(
      _class.reference.pointer,
      _id_getCodeCacheDir as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_createDeviceProtectedStorageContext = _class.staticMethodId(
    r'createDeviceProtectedStorageContext',
    r'(Landroid/content/Context;)Landroid/content/Context;',
  );

  static final _createDeviceProtectedStorageContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.content.Context createDeviceProtectedStorageContext(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static context$_.Context? createDeviceProtectedStorageContext(
    context$_.Context context,
  ) {
    final _$context = context.reference;
    return _createDeviceProtectedStorageContext(
      _class.reference.pointer,
      _id_createDeviceProtectedStorageContext as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<context$_.Context?>(const context$_.$Context$NullableType$());
  }

  static final _id_isDeviceProtectedStorage = _class.staticMethodId(
    r'isDeviceProtectedStorage',
    r'(Landroid/content/Context;)Z',
  );

  static final _isDeviceProtectedStorage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public boolean isDeviceProtectedStorage(android.content.Context context)`
  static bool isDeviceProtectedStorage(context$_.Context context) {
    final _$context = context.reference;
    return _isDeviceProtectedStorage(
      _class.reference.pointer,
      _id_isDeviceProtectedStorage as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).boolean;
  }

  static final _id_getMainExecutor = _class.staticMethodId(
    r'getMainExecutor',
    r'(Landroid/content/Context;)Ljava/util/concurrent/Executor;',
  );

  static final _getMainExecutor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.concurrent.Executor getMainExecutor(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static executor$_.Executor getMainExecutor(context$_.Context context) {
    final _$context = context.reference;
    return _getMainExecutor(
      _class.reference.pointer,
      _id_getMainExecutor as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<executor$_.Executor>(const executor$_.$Executor$Type$());
  }

  static final _id_startForegroundService = _class.staticMethodId(
    r'startForegroundService',
    r'(Landroid/content/Context;Landroid/content/Intent;)V',
  );

  static final _startForegroundService =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void startForegroundService(android.content.Context context, android.content.Intent intent)`
  static void startForegroundService(
    context$_.Context context,
    intent$_.Intent intent,
  ) {
    final _$context = context.reference;
    final _$intent = intent.reference;
    _startForegroundService(
      _class.reference.pointer,
      _id_startForegroundService as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$intent.pointer,
    ).check();
  }

  static final _id_getDisplayOrDefault = _class.staticMethodId(
    r'getDisplayOrDefault',
    r'(Landroid/content/Context;)Landroid/view/Display;',
  );

  static final _getDisplayOrDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.view.Display getDisplayOrDefault(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getDisplayOrDefault(context$_.Context context) {
    final _$context = context.reference;
    return _getDisplayOrDefault(
      _class.reference.pointer,
      _id_getDisplayOrDefault as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_getSystemService = _class.staticMethodId(
    r'getSystemService',
    r'(Landroid/content/Context;Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getSystemService =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public T getSystemService(android.content.Context context, java.lang.Class<T> class)`
  /// The returned object must be released after use, by calling the [release] method.
  static $T? getSystemService<$T extends jni$_.JObject?>(
    context$_.Context context,
    jni$_.JObject class$, {
    required jni$_.JType<$T> T,
  }) {
    final _$context = context.reference;
    final _$class$ = class$.reference;
    return _getSystemService(
      _class.reference.pointer,
      _id_getSystemService as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$class$.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_registerReceiver = _class.staticMethodId(
    r'registerReceiver',
    r'(Landroid/content/Context;Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;I)Landroid/content/Intent;',
  );

  static final _registerReceiver =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public android.content.Intent registerReceiver(android.content.Context context, android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static intent$_.Intent? registerReceiver(
    context$_.Context context,
    broadcastreceiver$_.BroadcastReceiver? broadcastReceiver,
    intentfilter$_.IntentFilter intentFilter,
    int i,
  ) {
    final _$context = context.reference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter.reference;
    return _registerReceiver(
      _class.reference.pointer,
      _id_registerReceiver as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$broadcastReceiver.pointer,
      _$intentFilter.pointer,
      i,
    ).object<intent$_.Intent?>(const intent$_.$Intent$NullableType$());
  }

  static final _id_registerReceiver$1 = _class.staticMethodId(
    r'registerReceiver',
    r'(Landroid/content/Context;Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;I)Landroid/content/Intent;',
  );

  static final _registerReceiver$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public android.content.Intent registerReceiver(android.content.Context context, android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, java.lang.String string, android.os.Handler handler, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static intent$_.Intent? registerReceiver$1(
    context$_.Context context,
    broadcastreceiver$_.BroadcastReceiver? broadcastReceiver,
    intentfilter$_.IntentFilter intentFilter,
    jni$_.JString? string,
    handler$_.Handler? handler,
    int i,
  ) {
    final _$context = context.reference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter.reference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    return _registerReceiver$1(
      _class.reference.pointer,
      _id_registerReceiver$1 as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$broadcastReceiver.pointer,
      _$intentFilter.pointer,
      _$string.pointer,
      _$handler.pointer,
      i,
    ).object<intent$_.Intent?>(const intent$_.$Intent$NullableType$());
  }

  static final _id_getSystemServiceName = _class.staticMethodId(
    r'getSystemServiceName',
    r'(Landroid/content/Context;Ljava/lang/Class;)Ljava/lang/String;',
  );

  static final _getSystemServiceName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String getSystemServiceName(android.content.Context context, java.lang.Class<?> class)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getSystemServiceName(
    context$_.Context context,
    jni$_.JObject class$,
  ) {
    final _$context = context.reference;
    final _$class$ = class$.reference;
    return _getSystemServiceName(
      _class.reference.pointer,
      _id_getSystemServiceName as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$class$.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getString = _class.staticMethodId(
    r'getString',
    r'(Landroid/content/Context;I)Ljava/lang/String;',
  );

  static final _getString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.lang.String getString(android.content.Context context, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString getString(context$_.Context context, int i) {
    final _$context = context.reference;
    return _getString(
      _class.reference.pointer,
      _id_getString as jni$_.JMethodIDPtr,
      _$context.pointer,
      i,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getContextForLanguage = _class.staticMethodId(
    r'getContextForLanguage',
    r'(Landroid/content/Context;)Landroid/content/Context;',
  );

  static final _getContextForLanguage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.content.Context getContextForLanguage(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static context$_.Context getContextForLanguage(context$_.Context context) {
    final _$context = context.reference;
    return _getContextForLanguage(
      _class.reference.pointer,
      _id_getContextForLanguage as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<context$_.Context>(const context$_.$Context$Type$());
  }

  static final _id_getAttributionTag = _class.staticMethodId(
    r'getAttributionTag',
    r'(Landroid/content/Context;)Ljava/lang/String;',
  );

  static final _getAttributionTag =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String getAttributionTag(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getAttributionTag(context$_.Context context) {
    final _$context = context.reference;
    return _getAttributionTag(
      _class.reference.pointer,
      _id_getAttributionTag as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_createAttributionContext = _class.staticMethodId(
    r'createAttributionContext',
    r'(Landroid/content/Context;Ljava/lang/String;)Landroid/content/Context;',
  );

  static final _createAttributionContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.content.Context createAttributionContext(android.content.Context context, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static context$_.Context createAttributionContext(
    context$_.Context context,
    jni$_.JString? string,
  ) {
    final _$context = context.reference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createAttributionContext(
      _class.reference.pointer,
      _id_createAttributionContext as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).object<context$_.Context>(const context$_.$Context$Type$());
  }
}

final class $ContextCompat$NullableType$ extends jni$_.JType<ContextCompat?> {
  @jni$_.internal
  const $ContextCompat$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/core/content/ContextCompat;';

  @jni$_.internal
  @core$_.override
  ContextCompat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ContextCompat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ContextCompat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContextCompat$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContextCompat$NullableType$) &&
        other is $ContextCompat$NullableType$;
  }
}

final class $ContextCompat$Type$ extends jni$_.JType<ContextCompat> {
  @jni$_.internal
  const $ContextCompat$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/core/content/ContextCompat;';

  @jni$_.internal
  @core$_.override
  ContextCompat fromReference(jni$_.JReference reference) =>
      ContextCompat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ContextCompat?> get nullableType =>
      const $ContextCompat$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContextCompat$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContextCompat$Type$) &&
        other is $ContextCompat$Type$;
  }
}
