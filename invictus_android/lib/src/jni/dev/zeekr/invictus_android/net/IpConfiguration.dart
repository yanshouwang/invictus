// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'StaticIpConfiguration.dart' as staticipconfiguration$_;

/// from: `dev.zeekr.invictus_android.net.IpConfiguration$Builder$Companion`
class IpConfiguration$Builder$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpConfiguration$Builder$Companion> $type;

  @jni$_.internal
  IpConfiguration$Builder$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/invictus_android/net/IpConfiguration$Builder$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$Builder$Companion?> nullableType =
      $IpConfiguration$Builder$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$Builder$Companion> type =
      $IpConfiguration$Builder$Companion$Type$();
  static final _id_getClazz = _class.instanceMethodId(
    r'getClazz',
    r'()Ljava/lang/Class;',
  );

  static final _getClazz =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Class<?> getClazz()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getClazz() {
    return _getClazz(
      reference.pointer,
      _id_getClazz as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IpConfiguration$Builder$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return IpConfiguration$Builder$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $IpConfiguration$Builder$Companion$NullableType$
    extends jni$_.JType<IpConfiguration$Builder$Companion?> {
  @jni$_.internal
  const $IpConfiguration$Builder$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$Builder$Companion;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$Builder$Companion? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : IpConfiguration$Builder$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$Builder$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($IpConfiguration$Builder$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($IpConfiguration$Builder$Companion$NullableType$) &&
        other is $IpConfiguration$Builder$Companion$NullableType$;
  }
}

final class $IpConfiguration$Builder$Companion$Type$
    extends jni$_.JType<IpConfiguration$Builder$Companion> {
  @jni$_.internal
  const $IpConfiguration$Builder$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$Builder$Companion;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$Builder$Companion fromReference(jni$_.JReference reference) =>
      IpConfiguration$Builder$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$Builder$Companion?> get nullableType =>
      const $IpConfiguration$Builder$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$Builder$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpConfiguration$Builder$Companion$Type$) &&
        other is $IpConfiguration$Builder$Companion$Type$;
  }
}

/// from: `dev.zeekr.invictus_android.net.IpConfiguration$Builder`
class IpConfiguration$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpConfiguration$Builder> $type;

  @jni$_.internal
  IpConfiguration$Builder.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/invictus_android/net/IpConfiguration$Builder',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$Builder?> nullableType =
      $IpConfiguration$Builder$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$Builder> type =
      $IpConfiguration$Builder$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Ldev/zeekr/invictus_android/net/IpConfiguration$Builder$Companion;',
  );

  /// from: `static public final dev.zeekr.invictus_android.net.IpConfiguration$Builder$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static IpConfiguration$Builder$Companion get Companion => _id_Companion.get(
    _class,
    const $IpConfiguration$Builder$Companion$Type$(),
  );

  static final _id_getObj = _class.instanceMethodId(
    r'getObj',
    r'()Ljava/lang/Object;',
  );

  static final _getObj =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getObj()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getObj() {
    return _getObj(
      reference.pointer,
      _id_getObj as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_new$ = _class.constructorId(r'(Ljava/lang/Object;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IpConfiguration$Builder(jni$_.JObject object) {
    final _$object = object.reference;
    return IpConfiguration$Builder.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$object.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'()V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory IpConfiguration$Builder.new$1() {
    return IpConfiguration$Builder.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_setStaticIpConfiguration = _class.instanceMethodId(
    r'setStaticIpConfiguration',
    r'(Ldev/zeekr/invictus_android/net/StaticIpConfiguration;)Ldev/zeekr/invictus_android/net/IpConfiguration$Builder;',
  );

  static final _setStaticIpConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun setStaticIpConfiguration(config: dev.zeekr.invictus_android.net.StaticIpConfiguration?): dev.zeekr.invictus_android.net.IpConfiguration.Builder`
  /// The returned object must be released after use, by calling the [release] method.
  IpConfiguration$Builder setStaticIpConfiguration(
    staticipconfiguration$_.StaticIpConfiguration? staticIpConfiguration,
  ) {
    final _$staticIpConfiguration =
        staticIpConfiguration?.reference ?? jni$_.jNullReference;
    return _setStaticIpConfiguration(
      reference.pointer,
      _id_setStaticIpConfiguration as jni$_.JMethodIDPtr,
      _$staticIpConfiguration.pointer,
    ).object<IpConfiguration$Builder>(const $IpConfiguration$Builder$Type$());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Ldev/zeekr/invictus_android/net/IpConfiguration;',
  );

  static final _build =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun build(): dev.zeekr.invictus_android.net.IpConfiguration`
  /// The returned object must be released after use, by calling the [release] method.
  IpConfiguration build() {
    return _build(
      reference.pointer,
      _id_build as jni$_.JMethodIDPtr,
    ).object<IpConfiguration>(const $IpConfiguration$Type$());
  }
}

final class $IpConfiguration$Builder$NullableType$
    extends jni$_.JType<IpConfiguration$Builder?> {
  @jni$_.internal
  const $IpConfiguration$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$Builder;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : IpConfiguration$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$Builder$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpConfiguration$Builder$NullableType$) &&
        other is $IpConfiguration$Builder$NullableType$;
  }
}

final class $IpConfiguration$Builder$Type$
    extends jni$_.JType<IpConfiguration$Builder> {
  @jni$_.internal
  const $IpConfiguration$Builder$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$Builder;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$Builder fromReference(jni$_.JReference reference) =>
      IpConfiguration$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$Builder?> get nullableType =>
      const $IpConfiguration$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$Builder$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpConfiguration$Builder$Type$) &&
        other is $IpConfiguration$Builder$Type$;
  }
}

/// from: `dev.zeekr.invictus_android.net.IpConfiguration$Companion`
class IpConfiguration$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpConfiguration$Companion> $type;

  @jni$_.internal
  IpConfiguration$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/invictus_android/net/IpConfiguration$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$Companion?> nullableType =
      $IpConfiguration$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$Companion> type =
      $IpConfiguration$Companion$Type$();
  static final _id_getClazz = _class.instanceMethodId(
    r'getClazz',
    r'()Ljava/lang/Class;',
  );

  static final _getClazz =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Class<?> getClazz()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getClazz() {
    return _getClazz(
      reference.pointer,
      _id_getClazz as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IpConfiguration$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return IpConfiguration$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $IpConfiguration$Companion$NullableType$
    extends jni$_.JType<IpConfiguration$Companion?> {
  @jni$_.internal
  const $IpConfiguration$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$Companion;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : IpConfiguration$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpConfiguration$Companion$NullableType$) &&
        other is $IpConfiguration$Companion$NullableType$;
  }
}

final class $IpConfiguration$Companion$Type$
    extends jni$_.JType<IpConfiguration$Companion> {
  @jni$_.internal
  const $IpConfiguration$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$Companion;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$Companion fromReference(jni$_.JReference reference) =>
      IpConfiguration$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$Companion?> get nullableType =>
      const $IpConfiguration$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpConfiguration$Companion$Type$) &&
        other is $IpConfiguration$Companion$Type$;
  }
}

/// from: `dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment$Companion`
class IpConfiguration$IpAssignment$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpConfiguration$IpAssignment$Companion> $type;

  @jni$_.internal
  IpConfiguration$IpAssignment$Companion.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/invictus_android/net/IpConfiguration$IpAssignment$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$IpAssignment$Companion?>
  nullableType = $IpConfiguration$IpAssignment$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$IpAssignment$Companion> type =
      $IpConfiguration$IpAssignment$Companion$Type$();
  static final _id_getClazz = _class.instanceMethodId(
    r'getClazz',
    r'()Ljava/lang/Class;',
  );

  static final _getClazz =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Class<?> getClazz()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getClazz() {
    return _getClazz(
      reference.pointer,
      _id_getClazz as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_of = _class.instanceMethodId(
    r'of',
    r'(Ljava/lang/Object;)Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun of(obj: kotlin.Any): dev.zeekr.invictus_android.net.IpConfiguration.IpAssignment`
  /// The returned object must be released after use, by calling the [release] method.
  IpConfiguration$IpAssignment of(jni$_.JObject object) {
    final _$object = object.reference;
    return _of(
      reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<IpConfiguration$IpAssignment>(
      const $IpConfiguration$IpAssignment$Type$(),
    );
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IpConfiguration$IpAssignment$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return IpConfiguration$IpAssignment$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $IpConfiguration$IpAssignment$Companion$NullableType$
    extends jni$_.JType<IpConfiguration$IpAssignment$Companion?> {
  @jni$_.internal
  const $IpConfiguration$IpAssignment$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment$Companion;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$IpAssignment$Companion? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : IpConfiguration$IpAssignment$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$IpAssignment$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($IpConfiguration$IpAssignment$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($IpConfiguration$IpAssignment$Companion$NullableType$) &&
        other is $IpConfiguration$IpAssignment$Companion$NullableType$;
  }
}

final class $IpConfiguration$IpAssignment$Companion$Type$
    extends jni$_.JType<IpConfiguration$IpAssignment$Companion> {
  @jni$_.internal
  const $IpConfiguration$IpAssignment$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment$Companion;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$IpAssignment$Companion fromReference(
    jni$_.JReference reference,
  ) => IpConfiguration$IpAssignment$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$IpAssignment$Companion?> get nullableType =>
      const $IpConfiguration$IpAssignment$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$IpAssignment$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($IpConfiguration$IpAssignment$Companion$Type$) &&
        other is $IpConfiguration$IpAssignment$Companion$Type$;
  }
}

/// from: `dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment`
class IpConfiguration$IpAssignment extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpConfiguration$IpAssignment> $type;

  @jni$_.internal
  IpConfiguration$IpAssignment.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/invictus_android/net/IpConfiguration$IpAssignment',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$IpAssignment?> nullableType =
      $IpConfiguration$IpAssignment$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration$IpAssignment> type =
      $IpConfiguration$IpAssignment$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment$Companion;',
  );

  /// from: `static public final dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static IpConfiguration$IpAssignment$Companion get Companion => _id_Companion
      .get(_class, const $IpConfiguration$IpAssignment$Companion$Type$());

  static final _id_STATIC = _class.staticFieldId(
    r'STATIC',
    r'Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;',
  );

  /// from: `static public final dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment STATIC`
  /// The returned object must be released after use, by calling the [release] method.
  static IpConfiguration$IpAssignment get STATIC =>
      _id_STATIC.get(_class, const $IpConfiguration$IpAssignment$Type$());

  static final _id_DHCP = _class.staticFieldId(
    r'DHCP',
    r'Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;',
  );

  /// from: `static public final dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment DHCP`
  /// The returned object must be released after use, by calling the [release] method.
  static IpConfiguration$IpAssignment get DHCP =>
      _id_DHCP.get(_class, const $IpConfiguration$IpAssignment$Type$());

  static final _id_UNASSIGNED = _class.staticFieldId(
    r'UNASSIGNED',
    r'Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;',
  );

  /// from: `static public final dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment UNASSIGNED`
  /// The returned object must be released after use, by calling the [release] method.
  static IpConfiguration$IpAssignment get UNASSIGNED =>
      _id_UNASSIGNED.get(_class, const $IpConfiguration$IpAssignment$Type$());

  static final _id_getObj = _class.instanceMethodId(
    r'getObj',
    r'()Ljava/lang/Object;',
  );

  static final _getObj =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getObj()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getObj() {
    return _getObj(
      reference.pointer,
      _id_getObj as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<IpConfiguration$IpAssignment?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<IpConfiguration$IpAssignment?>?>(
      const jni$_.$JArray$NullableType$<IpConfiguration$IpAssignment?>(
        $IpConfiguration$IpAssignment$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static IpConfiguration$IpAssignment? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<IpConfiguration$IpAssignment?>(
      const $IpConfiguration$IpAssignment$NullableType$(),
    );
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public kotlin.enums.EnumEntries<dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
      _class.reference.pointer,
      _id_getEntries as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }
}

final class $IpConfiguration$IpAssignment$NullableType$
    extends jni$_.JType<IpConfiguration$IpAssignment?> {
  @jni$_.internal
  const $IpConfiguration$IpAssignment$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$IpAssignment? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : IpConfiguration$IpAssignment.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$IpAssignment?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$IpAssignment$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpConfiguration$IpAssignment$NullableType$) &&
        other is $IpConfiguration$IpAssignment$NullableType$;
  }
}

final class $IpConfiguration$IpAssignment$Type$
    extends jni$_.JType<IpConfiguration$IpAssignment> {
  @jni$_.internal
  const $IpConfiguration$IpAssignment$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;';

  @jni$_.internal
  @core$_.override
  IpConfiguration$IpAssignment fromReference(jni$_.JReference reference) =>
      IpConfiguration$IpAssignment.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration$IpAssignment?> get nullableType =>
      const $IpConfiguration$IpAssignment$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$IpAssignment$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpConfiguration$IpAssignment$Type$) &&
        other is $IpConfiguration$IpAssignment$Type$;
  }
}

/// from: `dev.zeekr.invictus_android.net.IpConfiguration`
class IpConfiguration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<IpConfiguration> $type;

  @jni$_.internal
  IpConfiguration.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/zeekr/invictus_android/net/IpConfiguration',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration?> nullableType =
      $IpConfiguration$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<IpConfiguration> type = $IpConfiguration$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Ldev/zeekr/invictus_android/net/IpConfiguration$Companion;',
  );

  /// from: `static public final dev.zeekr.invictus_android.net.IpConfiguration$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static IpConfiguration$Companion get Companion =>
      _id_Companion.get(_class, const $IpConfiguration$Companion$Type$());

  static final _id_getObj = _class.instanceMethodId(
    r'getObj',
    r'()Ljava/lang/Object;',
  );

  static final _getObj =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getObj()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getObj() {
    return _getObj(
      reference.pointer,
      _id_getObj as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_new$ = _class.constructorId(r'(Ljava/lang/Object;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IpConfiguration(jni$_.JObject object) {
    final _$object = object.reference;
    return IpConfiguration.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$object.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'()V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory IpConfiguration.new$1() {
    return IpConfiguration.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ldev/zeekr/invictus_android/net/IpConfiguration;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(dev.zeekr.invictus_android.net.IpConfiguration ipConfiguration)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IpConfiguration.new$2(IpConfiguration ipConfiguration) {
    final _$ipConfiguration = ipConfiguration.reference;
    return IpConfiguration.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$ipConfiguration.pointer,
      ).reference,
    );
  }

  static final _id_getIpAssignment = _class.instanceMethodId(
    r'getIpAssignment',
    r'()Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;',
  );

  static final _getIpAssignment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment getIpAssignment()`
  /// The returned object must be released after use, by calling the [release] method.
  IpConfiguration$IpAssignment getIpAssignment() {
    return _getIpAssignment(
      reference.pointer,
      _id_getIpAssignment as jni$_.JMethodIDPtr,
    ).object<IpConfiguration$IpAssignment>(
      const $IpConfiguration$IpAssignment$Type$(),
    );
  }

  static final _id_setIpAssignment = _class.instanceMethodId(
    r'setIpAssignment',
    r'(Ldev/zeekr/invictus_android/net/IpConfiguration$IpAssignment;)V',
  );

  static final _setIpAssignment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void setIpAssignment(dev.zeekr.invictus_android.net.IpConfiguration$IpAssignment ipAssignment)`
  void setIpAssignment(IpConfiguration$IpAssignment ipAssignment) {
    final _$ipAssignment = ipAssignment.reference;
    _setIpAssignment(
      reference.pointer,
      _id_setIpAssignment as jni$_.JMethodIDPtr,
      _$ipAssignment.pointer,
    ).check();
  }

  static final _id_getStaticIpConfiguration = _class.instanceMethodId(
    r'getStaticIpConfiguration',
    r'()Ldev/zeekr/invictus_android/net/StaticIpConfiguration;',
  );

  static final _getStaticIpConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final dev.zeekr.invictus_android.net.StaticIpConfiguration getStaticIpConfiguration()`
  /// The returned object must be released after use, by calling the [release] method.
  staticipconfiguration$_.StaticIpConfiguration? getStaticIpConfiguration() {
    return _getStaticIpConfiguration(
      reference.pointer,
      _id_getStaticIpConfiguration as jni$_.JMethodIDPtr,
    ).object<staticipconfiguration$_.StaticIpConfiguration?>(
      const staticipconfiguration$_.$StaticIpConfiguration$NullableType$(),
    );
  }

  static final _id_setStaticIpConfiguration = _class.instanceMethodId(
    r'setStaticIpConfiguration',
    r'(Ldev/zeekr/invictus_android/net/StaticIpConfiguration;)V',
  );

  static final _setStaticIpConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void setStaticIpConfiguration(dev.zeekr.invictus_android.net.StaticIpConfiguration staticIpConfiguration)`
  void setStaticIpConfiguration(
    staticipconfiguration$_.StaticIpConfiguration? staticIpConfiguration,
  ) {
    final _$staticIpConfiguration =
        staticIpConfiguration?.reference ?? jni$_.jNullReference;
    _setStaticIpConfiguration(
      reference.pointer,
      _id_setStaticIpConfiguration as jni$_.JMethodIDPtr,
      _$staticIpConfiguration.pointer,
    ).check();
  }
}

final class $IpConfiguration$NullableType$
    extends jni$_.JType<IpConfiguration?> {
  @jni$_.internal
  const $IpConfiguration$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ldev/zeekr/invictus_android/net/IpConfiguration;';

  @jni$_.internal
  @core$_.override
  IpConfiguration? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : IpConfiguration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpConfiguration$NullableType$) &&
        other is $IpConfiguration$NullableType$;
  }
}

final class $IpConfiguration$Type$ extends jni$_.JType<IpConfiguration> {
  @jni$_.internal
  const $IpConfiguration$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ldev/zeekr/invictus_android/net/IpConfiguration;';

  @jni$_.internal
  @core$_.override
  IpConfiguration fromReference(jni$_.JReference reference) =>
      IpConfiguration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<IpConfiguration?> get nullableType =>
      const $IpConfiguration$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IpConfiguration$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IpConfiguration$Type$) &&
        other is $IpConfiguration$Type$;
  }
}
