// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'InetAddress.dart' as inetaddress$_;

/// from: `java.net.DatagramSocket`
class DatagramSocket extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<DatagramSocket> $type;

  @jni$_.internal
  DatagramSocket.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/DatagramSocket');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DatagramSocket?> nullableType =
      $DatagramSocket$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DatagramSocket> type = $DatagramSocket$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramSocket() {
    return DatagramSocket.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramSocket.new$1(int i) {
    return DatagramSocket.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(ILjava/net/InetAddress;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(int i, java.net.InetAddress inetAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramSocket.new$2(int i, inetaddress$_.InetAddress? inetAddress) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return DatagramSocket.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        i,
        _$inetAddress.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/net/SocketAddress;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.SocketAddress socketAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramSocket.new$3(jni$_.JObject? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    return DatagramSocket.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$socketAddress.pointer,
      ).reference,
    );
  }

  static final _id_bind = _class.instanceMethodId(
    r'bind',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _bind =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void bind(java.net.SocketAddress socketAddress)`
  void bind(jni$_.JObject? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _bind(
      reference.pointer,
      _id_bind as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/net/InetAddress;I)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void connect(java.net.InetAddress inetAddress, int i)`
  void connect(inetaddress$_.InetAddress? inetAddress, int i) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
      i,
    ).check();
  }

  static final _id_connect$1 = _class.instanceMethodId(
    r'connect',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _connect$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.net.SocketAddress socketAddress)`
  void connect$1(jni$_.JObject? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _connect$1(
      reference.pointer,
      _id_connect$1 as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_disconnect = _class.instanceMethodId(r'disconnect', r'()V');

  static final _disconnect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void disconnect()`
  void disconnect() {
    _disconnect(
      reference.pointer,
      _id_disconnect as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_getBroadcast = _class.instanceMethodId(
    r'getBroadcast',
    r'()Z',
  );

  static final _getBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getBroadcast()`
  bool getBroadcast() {
    return _getBroadcast(
      reference.pointer,
      _id_getBroadcast as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/DatagramChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.channels.DatagramChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() {
    return _getChannel(
      reference.pointer,
      _id_getChannel as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getInetAddress = _class.instanceMethodId(
    r'getInetAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getInetAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getInetAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  inetaddress$_.InetAddress? getInetAddress() {
    return _getInetAddress(
      reference.pointer,
      _id_getInetAddress as jni$_.JMethodIDPtr,
    ).object<inetaddress$_.InetAddress?>(
      const inetaddress$_.$InetAddress$NullableType$(),
    );
  }

  static final _id_getLocalAddress = _class.instanceMethodId(
    r'getLocalAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getLocalAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  inetaddress$_.InetAddress? getLocalAddress() {
    return _getLocalAddress(
      reference.pointer,
      _id_getLocalAddress as jni$_.JMethodIDPtr,
    ).object<inetaddress$_.InetAddress?>(
      const inetaddress$_.$InetAddress$NullableType$(),
    );
  }

  static final _id_getLocalPort = _class.instanceMethodId(
    r'getLocalPort',
    r'()I',
  );

  static final _getLocalPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLocalPort()`
  int getLocalPort() {
    return _getLocalPort(
      reference.pointer,
      _id_getLocalPort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getLocalSocketAddress = _class.instanceMethodId(
    r'getLocalSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getLocalSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getLocalSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLocalSocketAddress() {
    return _getLocalSocketAddress(
      reference.pointer,
      _id_getLocalSocketAddress as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getOption = _class.instanceMethodId(
    r'getOption',
    r'(Ljava/net/SocketOption;)Ljava/lang/Object;',
  );

  static final _getOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T getOption(java.net.SocketOption<T> socketOption)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getOption<$T extends jni$_.JObject?>(
    jni$_.JObject? socketOption, {
    required jni$_.JType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    return _getOption(
      reference.pointer,
      _id_getOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_getPort = _class.instanceMethodId(r'getPort', r'()I');

  static final _getPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPort()`
  int getPort() {
    return _getPort(
      reference.pointer,
      _id_getPort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getReceiveBufferSize = _class.instanceMethodId(
    r'getReceiveBufferSize',
    r'()I',
  );

  static final _getReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getReceiveBufferSize()`
  int getReceiveBufferSize() {
    return _getReceiveBufferSize(
      reference.pointer,
      _id_getReceiveBufferSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getRemoteSocketAddress = _class.instanceMethodId(
    r'getRemoteSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getRemoteSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getRemoteSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRemoteSocketAddress() {
    return _getRemoteSocketAddress(
      reference.pointer,
      _id_getRemoteSocketAddress as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getReuseAddress = _class.instanceMethodId(
    r'getReuseAddress',
    r'()Z',
  );

  static final _getReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getReuseAddress()`
  bool getReuseAddress() {
    return _getReuseAddress(
      reference.pointer,
      _id_getReuseAddress as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getSendBufferSize = _class.instanceMethodId(
    r'getSendBufferSize',
    r'()I',
  );

  static final _getSendBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSendBufferSize()`
  int getSendBufferSize() {
    return _getSendBufferSize(
      reference.pointer,
      _id_getSendBufferSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getSoTimeout = _class.instanceMethodId(
    r'getSoTimeout',
    r'()I',
  );

  static final _getSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSoTimeout()`
  int getSoTimeout() {
    return _getSoTimeout(
      reference.pointer,
      _id_getSoTimeout as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getTrafficClass = _class.instanceMethodId(
    r'getTrafficClass',
    r'()I',
  );

  static final _getTrafficClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getTrafficClass()`
  int getTrafficClass() {
    return _getTrafficClass(
      reference.pointer,
      _id_getTrafficClass as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isBound = _class.instanceMethodId(r'isBound', r'()Z');

  static final _isBound =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBound()`
  bool isBound() {
    return _isBound(
      reference.pointer,
      _id_isBound as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isClosed = _class.instanceMethodId(r'isClosed', r'()Z');

  static final _isClosed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isClosed()`
  bool isClosed() {
    return _isClosed(
      reference.pointer,
      _id_isClosed as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isConnected = _class.instanceMethodId(
    r'isConnected',
    r'()Z',
  );

  static final _isConnected =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isConnected()`
  bool isConnected() {
    return _isConnected(
      reference.pointer,
      _id_isConnected as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_receive = _class.instanceMethodId(
    r'receive',
    r'(Ljava/net/DatagramPacket;)V',
  );

  static final _receive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void receive(java.net.DatagramPacket datagramPacket)`
  void receive(jni$_.JObject? datagramPacket) {
    final _$datagramPacket = datagramPacket?.reference ?? jni$_.jNullReference;
    _receive(
      reference.pointer,
      _id_receive as jni$_.JMethodIDPtr,
      _$datagramPacket.pointer,
    ).check();
  }

  static final _id_send = _class.instanceMethodId(
    r'send',
    r'(Ljava/net/DatagramPacket;)V',
  );

  static final _send =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void send(java.net.DatagramPacket datagramPacket)`
  void send(jni$_.JObject? datagramPacket) {
    final _$datagramPacket = datagramPacket?.reference ?? jni$_.jNullReference;
    _send(
      reference.pointer,
      _id_send as jni$_.JMethodIDPtr,
      _$datagramPacket.pointer,
    ).check();
  }

  static final _id_setBroadcast = _class.instanceMethodId(
    r'setBroadcast',
    r'(Z)V',
  );

  static final _setBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setBroadcast(boolean z)`
  void setBroadcast(bool z) {
    _setBroadcast(
      reference.pointer,
      _id_setBroadcast as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setDatagramSocketImplFactory = _class.staticMethodId(
    r'setDatagramSocketImplFactory',
    r'(Ljava/net/DatagramSocketImplFactory;)V',
  );

  static final _setDatagramSocketImplFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDatagramSocketImplFactory(java.net.DatagramSocketImplFactory datagramSocketImplFactory)`
  static void setDatagramSocketImplFactory(
    jni$_.JObject? datagramSocketImplFactory,
  ) {
    final _$datagramSocketImplFactory =
        datagramSocketImplFactory?.reference ?? jni$_.jNullReference;
    _setDatagramSocketImplFactory(
      _class.reference.pointer,
      _id_setDatagramSocketImplFactory as jni$_.JMethodIDPtr,
      _$datagramSocketImplFactory.pointer,
    ).check();
  }

  static final _id_setOption = _class.instanceMethodId(
    r'setOption',
    r'(Ljava/net/SocketOption;Ljava/lang/Object;)Ljava/net/DatagramSocket;',
  );

  static final _setOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.DatagramSocket setOption(java.net.SocketOption<T> socketOption, T object)`
  /// The returned object must be released after use, by calling the [release] method.
  DatagramSocket? setOption<$T extends jni$_.JObject?>(
    jni$_.JObject? socketOption,
    $T? object, {
    required jni$_.JType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _setOption(
      reference.pointer,
      _id_setOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
      _$object.pointer,
    ).object<DatagramSocket?>(const $DatagramSocket$NullableType$());
  }

  static final _id_setReceiveBufferSize = _class.instanceMethodId(
    r'setReceiveBufferSize',
    r'(I)V',
  );

  static final _setReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReceiveBufferSize(int i)`
  void setReceiveBufferSize(int i) {
    _setReceiveBufferSize(
      reference.pointer,
      _id_setReceiveBufferSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setReuseAddress = _class.instanceMethodId(
    r'setReuseAddress',
    r'(Z)V',
  );

  static final _setReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReuseAddress(boolean z)`
  void setReuseAddress(bool z) {
    _setReuseAddress(
      reference.pointer,
      _id_setReuseAddress as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setSendBufferSize = _class.instanceMethodId(
    r'setSendBufferSize',
    r'(I)V',
  );

  static final _setSendBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSendBufferSize(int i)`
  void setSendBufferSize(int i) {
    _setSendBufferSize(
      reference.pointer,
      _id_setSendBufferSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setSoTimeout = _class.instanceMethodId(
    r'setSoTimeout',
    r'(I)V',
  );

  static final _setSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSoTimeout(int i)`
  void setSoTimeout(int i) {
    _setSoTimeout(
      reference.pointer,
      _id_setSoTimeout as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setTrafficClass = _class.instanceMethodId(
    r'setTrafficClass',
    r'(I)V',
  );

  static final _setTrafficClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTrafficClass(int i)`
  void setTrafficClass(int i) {
    _setTrafficClass(
      reference.pointer,
      _id_setTrafficClass as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_supportedOptions = _class.instanceMethodId(
    r'supportedOptions',
    r'()Ljava/util/Set;',
  );

  static final _supportedOptions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.net.SocketOption<?>> supportedOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JObject?>? supportedOptions() {
    return _supportedOptions(
      reference.pointer,
      _id_supportedOptions as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JObject?>?>(
      const jni$_.$JSet$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }
}

final class $DatagramSocket$NullableType$ extends jni$_.JType<DatagramSocket?> {
  @jni$_.internal
  const $DatagramSocket$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramSocket;';

  @jni$_.internal
  @core$_.override
  DatagramSocket? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DatagramSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<DatagramSocket?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramSocket$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DatagramSocket$NullableType$) &&
        other is $DatagramSocket$NullableType$;
  }
}

final class $DatagramSocket$Type$ extends jni$_.JType<DatagramSocket> {
  @jni$_.internal
  const $DatagramSocket$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramSocket;';

  @jni$_.internal
  @core$_.override
  DatagramSocket fromReference(jni$_.JReference reference) =>
      DatagramSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<DatagramSocket?> get nullableType =>
      const $DatagramSocket$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramSocket$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DatagramSocket$Type$) &&
        other is $DatagramSocket$Type$;
  }
}
