// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'InetAddress.dart' as inetaddress$_;

/// from: `java.net.NetworkInterface`
class NetworkInterface extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NetworkInterface> $type;

  @jni$_.internal
  NetworkInterface.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/NetworkInterface');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NetworkInterface?> nullableType =
      $NetworkInterface$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NetworkInterface> type = $NetworkInterface$Type$();
  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_getByIndex = _class.staticMethodId(
    r'getByIndex',
    r'(I)Ljava/net/NetworkInterface;',
  );

  static final _getByIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.net.NetworkInterface getByIndex(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static NetworkInterface? getByIndex(int i) {
    return _getByIndex(
      _class.reference.pointer,
      _id_getByIndex as jni$_.JMethodIDPtr,
      i,
    ).object<NetworkInterface?>(const $NetworkInterface$NullableType$());
  }

  static final _id_getByInetAddress = _class.staticMethodId(
    r'getByInetAddress',
    r'(Ljava/net/InetAddress;)Ljava/net/NetworkInterface;',
  );

  static final _getByInetAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.NetworkInterface getByInetAddress(java.net.InetAddress inetAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  static NetworkInterface? getByInetAddress(
    inetaddress$_.InetAddress? inetAddress,
  ) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return _getByInetAddress(
      _class.reference.pointer,
      _id_getByInetAddress as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
    ).object<NetworkInterface?>(const $NetworkInterface$NullableType$());
  }

  static final _id_getByName = _class.staticMethodId(
    r'getByName',
    r'(Ljava/lang/String;)Ljava/net/NetworkInterface;',
  );

  static final _getByName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.NetworkInterface getByName(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NetworkInterface? getByName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getByName(
      _class.reference.pointer,
      _id_getByName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NetworkInterface?>(const $NetworkInterface$NullableType$());
  }

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'()Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDisplayName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName() {
    return _getDisplayName(
      reference.pointer,
      _id_getDisplayName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getHardwareAddress = _class.instanceMethodId(
    r'getHardwareAddress',
    r'()[B',
  );

  static final _getHardwareAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] getHardwareAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getHardwareAddress() {
    return _getHardwareAddress(
      reference.pointer,
      _id_getHardwareAddress as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_getIndex = _class.instanceMethodId(r'getIndex', r'()I');

  static final _getIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getIndex()`
  int getIndex() {
    return _getIndex(
      reference.pointer,
      _id_getIndex as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getInetAddresses = _class.instanceMethodId(
    r'getInetAddresses',
    r'()Ljava/util/Enumeration;',
  );

  static final _getInetAddresses =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Enumeration<java.net.InetAddress> getInetAddresses()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getInetAddresses() {
    return _getInetAddresses(
      reference.pointer,
      _id_getInetAddresses as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getInterfaceAddresses = _class.instanceMethodId(
    r'getInterfaceAddresses',
    r'()Ljava/util/List;',
  );

  static final _getInterfaceAddresses =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<java.net.InterfaceAddress> getInterfaceAddresses()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getInterfaceAddresses() {
    return _getInterfaceAddresses(
      reference.pointer,
      _id_getInterfaceAddresses as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getMTU = _class.instanceMethodId(r'getMTU', r'()I');

  static final _getMTU =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMTU()`
  int getMTU() {
    return _getMTU(reference.pointer, _id_getMTU as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(
      reference.pointer,
      _id_getName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getNetworkInterfaces = _class.staticMethodId(
    r'getNetworkInterfaces',
    r'()Ljava/util/Enumeration;',
  );

  static final _getNetworkInterfaces =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Enumeration<java.net.NetworkInterface> getNetworkInterfaces()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getNetworkInterfaces() {
    return _getNetworkInterfaces(
      _class.reference.pointer,
      _id_getNetworkInterfaces as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getParent = _class.instanceMethodId(
    r'getParent',
    r'()Ljava/net/NetworkInterface;',
  );

  static final _getParent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.NetworkInterface getParent()`
  /// The returned object must be released after use, by calling the [release] method.
  NetworkInterface? getParent() {
    return _getParent(
      reference.pointer,
      _id_getParent as jni$_.JMethodIDPtr,
    ).object<NetworkInterface?>(const $NetworkInterface$NullableType$());
  }

  static final _id_getSubInterfaces = _class.instanceMethodId(
    r'getSubInterfaces',
    r'()Ljava/util/Enumeration;',
  );

  static final _getSubInterfaces =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Enumeration<java.net.NetworkInterface> getSubInterfaces()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSubInterfaces() {
    return _getSubInterfaces(
      reference.pointer,
      _id_getSubInterfaces as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isLoopback = _class.instanceMethodId(r'isLoopback', r'()Z');

  static final _isLoopback =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLoopback()`
  bool isLoopback() {
    return _isLoopback(
      reference.pointer,
      _id_isLoopback as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isPointToPoint = _class.instanceMethodId(
    r'isPointToPoint',
    r'()Z',
  );

  static final _isPointToPoint =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPointToPoint()`
  bool isPointToPoint() {
    return _isPointToPoint(
      reference.pointer,
      _id_isPointToPoint as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isUp = _class.instanceMethodId(r'isUp', r'()Z');

  static final _isUp =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isUp()`
  bool isUp() {
    return _isUp(reference.pointer, _id_isUp as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isVirtual = _class.instanceMethodId(r'isVirtual', r'()Z');

  static final _isVirtual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isVirtual()`
  bool isVirtual() {
    return _isVirtual(
      reference.pointer,
      _id_isVirtual as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_supportsMulticast = _class.instanceMethodId(
    r'supportsMulticast',
    r'()Z',
  );

  static final _supportsMulticast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean supportsMulticast()`
  bool supportsMulticast() {
    return _supportsMulticast(
      reference.pointer,
      _id_supportsMulticast as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $NetworkInterface$NullableType$
    extends jni$_.JType<NetworkInterface?> {
  @jni$_.internal
  const $NetworkInterface$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/NetworkInterface;';

  @jni$_.internal
  @core$_.override
  NetworkInterface? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NetworkInterface.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NetworkInterface?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NetworkInterface$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NetworkInterface$NullableType$) &&
        other is $NetworkInterface$NullableType$;
  }
}

final class $NetworkInterface$Type$ extends jni$_.JType<NetworkInterface> {
  @jni$_.internal
  const $NetworkInterface$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/NetworkInterface;';

  @jni$_.internal
  @core$_.override
  NetworkInterface fromReference(jni$_.JReference reference) =>
      NetworkInterface.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NetworkInterface?> get nullableType =>
      const $NetworkInterface$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NetworkInterface$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NetworkInterface$Type$) &&
        other is $NetworkInterface$Type$;
  }
}
