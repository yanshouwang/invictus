// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../io/InputStream.dart' as inputstream$_;

import '../io/OutputStream.dart' as outputstream$_;

import 'InetAddress.dart' as inetaddress$_;

import 'Proxy.dart' as proxy$_;

/// from: `java.net.Socket`
class Socket extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Socket> $type;

  @jni$_.internal
  Socket.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Socket');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Socket?> nullableType = $Socket$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Socket> type = $Socket$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket() {
    return Socket.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$1(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/lang/String;IZ)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$2(jni$_.JString? string, int i, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;ILjava/net/InetAddress;I)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i, java.net.InetAddress inetAddress, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$3(
    jni$_.JString? string,
    int i,
    inetaddress$_.InetAddress? inetAddress,
    int i1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
        _$inetAddress.pointer,
        i1,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(r'(Ljava/net/InetAddress;I)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.net.InetAddress inetAddress, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$4(inetaddress$_.InetAddress? inetAddress, int i) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$inetAddress.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'(Ljava/net/InetAddress;IZ)V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(java.net.InetAddress inetAddress, int i, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$5(inetaddress$_.InetAddress? inetAddress, int i, bool z) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$inetAddress.pointer,
        i,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(
    r'(Ljava/net/InetAddress;ILjava/net/InetAddress;I)V',
  );

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.net.InetAddress inetAddress, int i, java.net.InetAddress inetAddress1, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$6(
    inetaddress$_.InetAddress? inetAddress,
    int i,
    inetaddress$_.InetAddress? inetAddress1,
    int i1,
  ) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    final _$inetAddress1 = inetAddress1?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$inetAddress.pointer,
        i,
        _$inetAddress1.pointer,
        i1,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(r'(Ljava/net/Proxy;)V');

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.Proxy proxy)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$7(proxy$_.Proxy? proxy) {
    final _$proxy = proxy?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$proxy.pointer,
      ).reference,
    );
  }

  static final _id_bind = _class.instanceMethodId(
    r'bind',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _bind =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void bind(java.net.SocketAddress socketAddress)`
  void bind(jni$_.JObject? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _bind(
      reference.pointer,
      _id_bind as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.net.SocketAddress socketAddress)`
  void connect(jni$_.JObject? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_connect$1 = _class.instanceMethodId(
    r'connect',
    r'(Ljava/net/SocketAddress;I)V',
  );

  static final _connect$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void connect(java.net.SocketAddress socketAddress, int i)`
  void connect$1(jni$_.JObject? socketAddress, int i) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _connect$1(
      reference.pointer,
      _id_connect$1 as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
      i,
    ).check();
  }

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/SocketChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.channels.SocketChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() {
    return _getChannel(
      reference.pointer,
      _id_getChannel as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getInetAddress = _class.instanceMethodId(
    r'getInetAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getInetAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getInetAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  inetaddress$_.InetAddress? getInetAddress() {
    return _getInetAddress(
      reference.pointer,
      _id_getInetAddress as jni$_.JMethodIDPtr,
    ).object<inetaddress$_.InetAddress?>(
      const inetaddress$_.$InetAddress$NullableType$(),
    );
  }

  static final _id_getInputStream = _class.instanceMethodId(
    r'getInputStream',
    r'()Ljava/io/InputStream;',
  );

  static final _getInputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.InputStream getInputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  inputstream$_.InputStream? getInputStream() {
    return _getInputStream(
      reference.pointer,
      _id_getInputStream as jni$_.JMethodIDPtr,
    ).object<inputstream$_.InputStream?>(
      const inputstream$_.$InputStream$NullableType$(),
    );
  }

  static final _id_getKeepAlive = _class.instanceMethodId(
    r'getKeepAlive',
    r'()Z',
  );

  static final _getKeepAlive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getKeepAlive()`
  bool getKeepAlive() {
    return _getKeepAlive(
      reference.pointer,
      _id_getKeepAlive as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getLocalAddress = _class.instanceMethodId(
    r'getLocalAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getLocalAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  inetaddress$_.InetAddress? getLocalAddress() {
    return _getLocalAddress(
      reference.pointer,
      _id_getLocalAddress as jni$_.JMethodIDPtr,
    ).object<inetaddress$_.InetAddress?>(
      const inetaddress$_.$InetAddress$NullableType$(),
    );
  }

  static final _id_getLocalPort = _class.instanceMethodId(
    r'getLocalPort',
    r'()I',
  );

  static final _getLocalPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLocalPort()`
  int getLocalPort() {
    return _getLocalPort(
      reference.pointer,
      _id_getLocalPort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getLocalSocketAddress = _class.instanceMethodId(
    r'getLocalSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getLocalSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getLocalSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLocalSocketAddress() {
    return _getLocalSocketAddress(
      reference.pointer,
      _id_getLocalSocketAddress as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getOOBInline = _class.instanceMethodId(
    r'getOOBInline',
    r'()Z',
  );

  static final _getOOBInline =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getOOBInline()`
  bool getOOBInline() {
    return _getOOBInline(
      reference.pointer,
      _id_getOOBInline as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getOption = _class.instanceMethodId(
    r'getOption',
    r'(Ljava/net/SocketOption;)Ljava/lang/Object;',
  );

  static final _getOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T getOption(java.net.SocketOption<T> socketOption)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getOption<$T extends jni$_.JObject?>(
    jni$_.JObject? socketOption, {
    required jni$_.JType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    return _getOption(
      reference.pointer,
      _id_getOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_getOutputStream = _class.instanceMethodId(
    r'getOutputStream',
    r'()Ljava/io/OutputStream;',
  );

  static final _getOutputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.OutputStream getOutputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  outputstream$_.OutputStream? getOutputStream() {
    return _getOutputStream(
      reference.pointer,
      _id_getOutputStream as jni$_.JMethodIDPtr,
    ).object<outputstream$_.OutputStream?>(
      const outputstream$_.$OutputStream$NullableType$(),
    );
  }

  static final _id_getPort = _class.instanceMethodId(r'getPort', r'()I');

  static final _getPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPort()`
  int getPort() {
    return _getPort(
      reference.pointer,
      _id_getPort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getReceiveBufferSize = _class.instanceMethodId(
    r'getReceiveBufferSize',
    r'()I',
  );

  static final _getReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getReceiveBufferSize()`
  int getReceiveBufferSize() {
    return _getReceiveBufferSize(
      reference.pointer,
      _id_getReceiveBufferSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getRemoteSocketAddress = _class.instanceMethodId(
    r'getRemoteSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getRemoteSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getRemoteSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRemoteSocketAddress() {
    return _getRemoteSocketAddress(
      reference.pointer,
      _id_getRemoteSocketAddress as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getReuseAddress = _class.instanceMethodId(
    r'getReuseAddress',
    r'()Z',
  );

  static final _getReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getReuseAddress()`
  bool getReuseAddress() {
    return _getReuseAddress(
      reference.pointer,
      _id_getReuseAddress as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getSendBufferSize = _class.instanceMethodId(
    r'getSendBufferSize',
    r'()I',
  );

  static final _getSendBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSendBufferSize()`
  int getSendBufferSize() {
    return _getSendBufferSize(
      reference.pointer,
      _id_getSendBufferSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getSoLinger = _class.instanceMethodId(
    r'getSoLinger',
    r'()I',
  );

  static final _getSoLinger =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSoLinger()`
  int getSoLinger() {
    return _getSoLinger(
      reference.pointer,
      _id_getSoLinger as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getSoTimeout = _class.instanceMethodId(
    r'getSoTimeout',
    r'()I',
  );

  static final _getSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSoTimeout()`
  int getSoTimeout() {
    return _getSoTimeout(
      reference.pointer,
      _id_getSoTimeout as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getTcpNoDelay = _class.instanceMethodId(
    r'getTcpNoDelay',
    r'()Z',
  );

  static final _getTcpNoDelay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getTcpNoDelay()`
  bool getTcpNoDelay() {
    return _getTcpNoDelay(
      reference.pointer,
      _id_getTcpNoDelay as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getTrafficClass = _class.instanceMethodId(
    r'getTrafficClass',
    r'()I',
  );

  static final _getTrafficClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getTrafficClass()`
  int getTrafficClass() {
    return _getTrafficClass(
      reference.pointer,
      _id_getTrafficClass as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isBound = _class.instanceMethodId(r'isBound', r'()Z');

  static final _isBound =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBound()`
  bool isBound() {
    return _isBound(
      reference.pointer,
      _id_isBound as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isClosed = _class.instanceMethodId(r'isClosed', r'()Z');

  static final _isClosed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isClosed()`
  bool isClosed() {
    return _isClosed(
      reference.pointer,
      _id_isClosed as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isConnected = _class.instanceMethodId(
    r'isConnected',
    r'()Z',
  );

  static final _isConnected =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isConnected()`
  bool isConnected() {
    return _isConnected(
      reference.pointer,
      _id_isConnected as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isInputShutdown = _class.instanceMethodId(
    r'isInputShutdown',
    r'()Z',
  );

  static final _isInputShutdown =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isInputShutdown()`
  bool isInputShutdown() {
    return _isInputShutdown(
      reference.pointer,
      _id_isInputShutdown as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isOutputShutdown = _class.instanceMethodId(
    r'isOutputShutdown',
    r'()Z',
  );

  static final _isOutputShutdown =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isOutputShutdown()`
  bool isOutputShutdown() {
    return _isOutputShutdown(
      reference.pointer,
      _id_isOutputShutdown as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_sendUrgentData = _class.instanceMethodId(
    r'sendUrgentData',
    r'(I)V',
  );

  static final _sendUrgentData =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void sendUrgentData(int i)`
  void sendUrgentData(int i) {
    _sendUrgentData(
      reference.pointer,
      _id_sendUrgentData as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setKeepAlive = _class.instanceMethodId(
    r'setKeepAlive',
    r'(Z)V',
  );

  static final _setKeepAlive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setKeepAlive(boolean z)`
  void setKeepAlive(bool z) {
    _setKeepAlive(
      reference.pointer,
      _id_setKeepAlive as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setOOBInline = _class.instanceMethodId(
    r'setOOBInline',
    r'(Z)V',
  );

  static final _setOOBInline =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setOOBInline(boolean z)`
  void setOOBInline(bool z) {
    _setOOBInline(
      reference.pointer,
      _id_setOOBInline as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setOption = _class.instanceMethodId(
    r'setOption',
    r'(Ljava/net/SocketOption;Ljava/lang/Object;)Ljava/net/Socket;',
  );

  static final _setOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.Socket setOption(java.net.SocketOption<T> socketOption, T object)`
  /// The returned object must be released after use, by calling the [release] method.
  Socket? setOption<$T extends jni$_.JObject?>(
    jni$_.JObject? socketOption,
    $T? object, {
    required jni$_.JType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _setOption(
      reference.pointer,
      _id_setOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
      _$object.pointer,
    ).object<Socket?>(const $Socket$NullableType$());
  }

  static final _id_setPerformancePreferences = _class.instanceMethodId(
    r'setPerformancePreferences',
    r'(III)V',
  );

  static final _setPerformancePreferences =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void setPerformancePreferences(int i, int i1, int i2)`
  void setPerformancePreferences(int i, int i1, int i2) {
    _setPerformancePreferences(
      reference.pointer,
      _id_setPerformancePreferences as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).check();
  }

  static final _id_setReceiveBufferSize = _class.instanceMethodId(
    r'setReceiveBufferSize',
    r'(I)V',
  );

  static final _setReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReceiveBufferSize(int i)`
  void setReceiveBufferSize(int i) {
    _setReceiveBufferSize(
      reference.pointer,
      _id_setReceiveBufferSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setReuseAddress = _class.instanceMethodId(
    r'setReuseAddress',
    r'(Z)V',
  );

  static final _setReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReuseAddress(boolean z)`
  void setReuseAddress(bool z) {
    _setReuseAddress(
      reference.pointer,
      _id_setReuseAddress as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setSendBufferSize = _class.instanceMethodId(
    r'setSendBufferSize',
    r'(I)V',
  );

  static final _setSendBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSendBufferSize(int i)`
  void setSendBufferSize(int i) {
    _setSendBufferSize(
      reference.pointer,
      _id_setSendBufferSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setSoLinger = _class.instanceMethodId(
    r'setSoLinger',
    r'(ZI)V',
  );

  static final _setSoLinger =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void setSoLinger(boolean z, int i)`
  void setSoLinger(bool z, int i) {
    _setSoLinger(
      reference.pointer,
      _id_setSoLinger as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      i,
    ).check();
  }

  static final _id_setSoTimeout = _class.instanceMethodId(
    r'setSoTimeout',
    r'(I)V',
  );

  static final _setSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSoTimeout(int i)`
  void setSoTimeout(int i) {
    _setSoTimeout(
      reference.pointer,
      _id_setSoTimeout as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setSocketImplFactory = _class.staticMethodId(
    r'setSocketImplFactory',
    r'(Ljava/net/SocketImplFactory;)V',
  );

  static final _setSocketImplFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setSocketImplFactory(java.net.SocketImplFactory socketImplFactory)`
  static void setSocketImplFactory(jni$_.JObject? socketImplFactory) {
    final _$socketImplFactory =
        socketImplFactory?.reference ?? jni$_.jNullReference;
    _setSocketImplFactory(
      _class.reference.pointer,
      _id_setSocketImplFactory as jni$_.JMethodIDPtr,
      _$socketImplFactory.pointer,
    ).check();
  }

  static final _id_setTcpNoDelay = _class.instanceMethodId(
    r'setTcpNoDelay',
    r'(Z)V',
  );

  static final _setTcpNoDelay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTcpNoDelay(boolean z)`
  void setTcpNoDelay(bool z) {
    _setTcpNoDelay(
      reference.pointer,
      _id_setTcpNoDelay as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setTrafficClass = _class.instanceMethodId(
    r'setTrafficClass',
    r'(I)V',
  );

  static final _setTrafficClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTrafficClass(int i)`
  void setTrafficClass(int i) {
    _setTrafficClass(
      reference.pointer,
      _id_setTrafficClass as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_shutdownInput = _class.instanceMethodId(
    r'shutdownInput',
    r'()V',
  );

  static final _shutdownInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void shutdownInput()`
  void shutdownInput() {
    _shutdownInput(
      reference.pointer,
      _id_shutdownInput as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_shutdownOutput = _class.instanceMethodId(
    r'shutdownOutput',
    r'()V',
  );

  static final _shutdownOutput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void shutdownOutput()`
  void shutdownOutput() {
    _shutdownOutput(
      reference.pointer,
      _id_shutdownOutput as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_supportedOptions = _class.instanceMethodId(
    r'supportedOptions',
    r'()Ljava/util/Set;',
  );

  static final _supportedOptions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.net.SocketOption<?>> supportedOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JObject?>? supportedOptions() {
    return _supportedOptions(
      reference.pointer,
      _id_supportedOptions as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JObject?>?>(
      const jni$_.$JSet$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $Socket$NullableType$ extends jni$_.JType<Socket?> {
  @jni$_.internal
  const $Socket$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Socket;';

  @jni$_.internal
  @core$_.override
  Socket? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Socket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Socket?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Socket$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Socket$NullableType$) &&
        other is $Socket$NullableType$;
  }
}

final class $Socket$Type$ extends jni$_.JType<Socket> {
  @jni$_.internal
  const $Socket$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Socket;';

  @jni$_.internal
  @core$_.override
  Socket fromReference(jni$_.JReference reference) =>
      Socket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Socket?> get nullableType => const $Socket$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Socket$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Socket$Type$) && other is $Socket$Type$;
  }
}
