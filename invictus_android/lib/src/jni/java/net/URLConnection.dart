// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../io/InputStream.dart' as inputstream$_;

import '../io/OutputStream.dart' as outputstream$_;

import 'URL.dart' as url$_;

/// from: `java.net.URLConnection`
class URLConnection extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<URLConnection> $type;

  @jni$_.internal
  URLConnection.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URLConnection');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<URLConnection?> nullableType =
      $URLConnection$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<URLConnection> type = $URLConnection$Type$();
  static final _id_addRequestProperty = _class.instanceMethodId(
    r'addRequestProperty',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _addRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addRequestProperty(java.lang.String string, java.lang.String string1)`
  void addRequestProperty(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _addRequestProperty(
      reference.pointer,
      _id_addRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).check();
  }

  static final _id_connect = _class.instanceMethodId(r'connect', r'()V');

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void connect()`
  void connect() {
    _connect(reference.pointer, _id_connect as jni$_.JMethodIDPtr).check();
  }

  static final _id_getAllowUserInteraction = _class.instanceMethodId(
    r'getAllowUserInteraction',
    r'()Z',
  );

  static final _getAllowUserInteraction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getAllowUserInteraction()`
  bool getAllowUserInteraction() {
    return _getAllowUserInteraction(
      reference.pointer,
      _id_getAllowUserInteraction as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getConnectTimeout = _class.instanceMethodId(
    r'getConnectTimeout',
    r'()I',
  );

  static final _getConnectTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getConnectTimeout()`
  int getConnectTimeout() {
    return _getConnectTimeout(
      reference.pointer,
      _id_getConnectTimeout as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getContent = _class.instanceMethodId(
    r'getContent',
    r'()Ljava/lang/Object;',
  );

  static final _getContent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object getContent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent() {
    return _getContent(
      reference.pointer,
      _id_getContent as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getContent$1 = _class.instanceMethodId(
    r'getContent',
    r'([Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getContent$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object getContent(java.lang.Class[] classs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent$1(jni$_.JArray<jni$_.JObject?>? classs) {
    final _$classs = classs?.reference ?? jni$_.jNullReference;
    return _getContent$1(
      reference.pointer,
      _id_getContent$1 as jni$_.JMethodIDPtr,
      _$classs.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getContentEncoding = _class.instanceMethodId(
    r'getContentEncoding',
    r'()Ljava/lang/String;',
  );

  static final _getContentEncoding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getContentEncoding()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getContentEncoding() {
    return _getContentEncoding(
      reference.pointer,
      _id_getContentEncoding as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getContentLength = _class.instanceMethodId(
    r'getContentLength',
    r'()I',
  );

  static final _getContentLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getContentLength()`
  int getContentLength() {
    return _getContentLength(
      reference.pointer,
      _id_getContentLength as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getContentLengthLong = _class.instanceMethodId(
    r'getContentLengthLong',
    r'()J',
  );

  static final _getContentLengthLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getContentLengthLong()`
  int getContentLengthLong() {
    return _getContentLengthLong(
      reference.pointer,
      _id_getContentLengthLong as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getContentType = _class.instanceMethodId(
    r'getContentType',
    r'()Ljava/lang/String;',
  );

  static final _getContentType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getContentType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getContentType() {
    return _getContentType(
      reference.pointer,
      _id_getContentType as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDate = _class.instanceMethodId(r'getDate', r'()J');

  static final _getDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getDate()`
  int getDate() {
    return _getDate(reference.pointer, _id_getDate as jni$_.JMethodIDPtr).long;
  }

  static final _id_getDefaultAllowUserInteraction = _class.staticMethodId(
    r'getDefaultAllowUserInteraction',
    r'()Z',
  );

  static final _getDefaultAllowUserInteraction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public boolean getDefaultAllowUserInteraction()`
  static bool getDefaultAllowUserInteraction() {
    return _getDefaultAllowUserInteraction(
      _class.reference.pointer,
      _id_getDefaultAllowUserInteraction as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getDefaultRequestProperty = _class.staticMethodId(
    r'getDefaultRequestProperty',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getDefaultRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String getDefaultRequestProperty(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getDefaultRequestProperty(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getDefaultRequestProperty(
      _class.reference.pointer,
      _id_getDefaultRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDefaultUseCaches = _class.instanceMethodId(
    r'getDefaultUseCaches',
    r'()Z',
  );

  static final _getDefaultUseCaches =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getDefaultUseCaches()`
  bool getDefaultUseCaches() {
    return _getDefaultUseCaches(
      reference.pointer,
      _id_getDefaultUseCaches as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getDoInput = _class.instanceMethodId(r'getDoInput', r'()Z');

  static final _getDoInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getDoInput()`
  bool getDoInput() {
    return _getDoInput(
      reference.pointer,
      _id_getDoInput as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getDoOutput = _class.instanceMethodId(
    r'getDoOutput',
    r'()Z',
  );

  static final _getDoOutput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getDoOutput()`
  bool getDoOutput() {
    return _getDoOutput(
      reference.pointer,
      _id_getDoOutput as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getExpiration = _class.instanceMethodId(
    r'getExpiration',
    r'()J',
  );

  static final _getExpiration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getExpiration()`
  int getExpiration() {
    return _getExpiration(
      reference.pointer,
      _id_getExpiration as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getFileNameMap = _class.staticMethodId(
    r'getFileNameMap',
    r'()Ljava/net/FileNameMap;',
  );

  static final _getFileNameMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.FileNameMap getFileNameMap()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getFileNameMap() {
    return _getFileNameMap(
      _class.reference.pointer,
      _id_getFileNameMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getHeaderField = _class.instanceMethodId(
    r'getHeaderField',
    r'(I)Ljava/lang/String;',
  );

  static final _getHeaderField =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String getHeaderField(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHeaderField(int i) {
    return _getHeaderField(
      reference.pointer,
      _id_getHeaderField as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getHeaderField$1 = _class.instanceMethodId(
    r'getHeaderField',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getHeaderField$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getHeaderField(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHeaderField$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHeaderField$1(
      reference.pointer,
      _id_getHeaderField$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getHeaderFieldDate = _class.instanceMethodId(
    r'getHeaderFieldDate',
    r'(Ljava/lang/String;J)J',
  );

  static final _getHeaderFieldDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public long getHeaderFieldDate(java.lang.String string, long j)`
  int getHeaderFieldDate(jni$_.JString? string, int j) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHeaderFieldDate(
      reference.pointer,
      _id_getHeaderFieldDate as jni$_.JMethodIDPtr,
      _$string.pointer,
      j,
    ).long;
  }

  static final _id_getHeaderFieldInt = _class.instanceMethodId(
    r'getHeaderFieldInt',
    r'(Ljava/lang/String;I)I',
  );

  static final _getHeaderFieldInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public int getHeaderFieldInt(java.lang.String string, int i)`
  int getHeaderFieldInt(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHeaderFieldInt(
      reference.pointer,
      _id_getHeaderFieldInt as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).integer;
  }

  static final _id_getHeaderFieldKey = _class.instanceMethodId(
    r'getHeaderFieldKey',
    r'(I)Ljava/lang/String;',
  );

  static final _getHeaderFieldKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String getHeaderFieldKey(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHeaderFieldKey(int i) {
    return _getHeaderFieldKey(
      reference.pointer,
      _id_getHeaderFieldKey as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getHeaderFieldLong = _class.instanceMethodId(
    r'getHeaderFieldLong',
    r'(Ljava/lang/String;J)J',
  );

  static final _getHeaderFieldLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public long getHeaderFieldLong(java.lang.String string, long j)`
  int getHeaderFieldLong(jni$_.JString? string, int j) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHeaderFieldLong(
      reference.pointer,
      _id_getHeaderFieldLong as jni$_.JMethodIDPtr,
      _$string.pointer,
      j,
    ).long;
  }

  static final _id_getHeaderFields = _class.instanceMethodId(
    r'getHeaderFields',
    r'()Ljava/util/Map;',
  );

  static final _getHeaderFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Map<java.lang.String, java.util.List<java.lang.String>> getHeaderFields()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? getHeaderFields() {
    return _getHeaderFields(
      reference.pointer,
      _id_getHeaderFields as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?>(
      const jni$_.$JMap$NullableType$<
        jni$_.JString?,
        jni$_.JList<jni$_.JString?>?
      >(
        jni$_.$JString$NullableType$(),
        jni$_.$JList$NullableType$<jni$_.JString?>(
          jni$_.$JString$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getIfModifiedSince = _class.instanceMethodId(
    r'getIfModifiedSince',
    r'()J',
  );

  static final _getIfModifiedSince =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getIfModifiedSince()`
  int getIfModifiedSince() {
    return _getIfModifiedSince(
      reference.pointer,
      _id_getIfModifiedSince as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getInputStream = _class.instanceMethodId(
    r'getInputStream',
    r'()Ljava/io/InputStream;',
  );

  static final _getInputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.InputStream getInputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  inputstream$_.InputStream? getInputStream() {
    return _getInputStream(
      reference.pointer,
      _id_getInputStream as jni$_.JMethodIDPtr,
    ).object<inputstream$_.InputStream?>(
      const inputstream$_.$InputStream$NullableType$(),
    );
  }

  static final _id_getLastModified = _class.instanceMethodId(
    r'getLastModified',
    r'()J',
  );

  static final _getLastModified =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getLastModified()`
  int getLastModified() {
    return _getLastModified(
      reference.pointer,
      _id_getLastModified as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getOutputStream = _class.instanceMethodId(
    r'getOutputStream',
    r'()Ljava/io/OutputStream;',
  );

  static final _getOutputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.OutputStream getOutputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  outputstream$_.OutputStream? getOutputStream() {
    return _getOutputStream(
      reference.pointer,
      _id_getOutputStream as jni$_.JMethodIDPtr,
    ).object<outputstream$_.OutputStream?>(
      const outputstream$_.$OutputStream$NullableType$(),
    );
  }

  static final _id_getPermission = _class.instanceMethodId(
    r'getPermission',
    r'()Ljava/security/Permission;',
  );

  static final _getPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.security.Permission getPermission()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPermission() {
    return _getPermission(
      reference.pointer,
      _id_getPermission as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getReadTimeout = _class.instanceMethodId(
    r'getReadTimeout',
    r'()I',
  );

  static final _getReadTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getReadTimeout()`
  int getReadTimeout() {
    return _getReadTimeout(
      reference.pointer,
      _id_getReadTimeout as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getRequestProperties = _class.instanceMethodId(
    r'getRequestProperties',
    r'()Ljava/util/Map;',
  );

  static final _getRequestProperties =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Map<java.lang.String, java.util.List<java.lang.String>> getRequestProperties()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?
  getRequestProperties() {
    return _getRequestProperties(
      reference.pointer,
      _id_getRequestProperties as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?>(
      const jni$_.$JMap$NullableType$<
        jni$_.JString?,
        jni$_.JList<jni$_.JString?>?
      >(
        jni$_.$JString$NullableType$(),
        jni$_.$JList$NullableType$<jni$_.JString?>(
          jni$_.$JString$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getRequestProperty = _class.instanceMethodId(
    r'getRequestProperty',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getRequestProperty(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRequestProperty(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getRequestProperty(
      reference.pointer,
      _id_getRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getURL = _class.instanceMethodId(
    r'getURL',
    r'()Ljava/net/URL;',
  );

  static final _getURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URL getURL()`
  /// The returned object must be released after use, by calling the [release] method.
  url$_.URL? getURL() {
    return _getURL(
      reference.pointer,
      _id_getURL as jni$_.JMethodIDPtr,
    ).object<url$_.URL?>(const url$_.$URL$NullableType$());
  }

  static final _id_getUseCaches = _class.instanceMethodId(
    r'getUseCaches',
    r'()Z',
  );

  static final _getUseCaches =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getUseCaches()`
  bool getUseCaches() {
    return _getUseCaches(
      reference.pointer,
      _id_getUseCaches as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_guessContentTypeFromName = _class.staticMethodId(
    r'guessContentTypeFromName',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _guessContentTypeFromName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String guessContentTypeFromName(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? guessContentTypeFromName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _guessContentTypeFromName(
      _class.reference.pointer,
      _id_guessContentTypeFromName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_guessContentTypeFromStream = _class.staticMethodId(
    r'guessContentTypeFromStream',
    r'(Ljava/io/InputStream;)Ljava/lang/String;',
  );

  static final _guessContentTypeFromStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String guessContentTypeFromStream(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? guessContentTypeFromStream(
    inputstream$_.InputStream? inputStream,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return _guessContentTypeFromStream(
      _class.reference.pointer,
      _id_guessContentTypeFromStream as jni$_.JMethodIDPtr,
      _$inputStream.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_setAllowUserInteraction = _class.instanceMethodId(
    r'setAllowUserInteraction',
    r'(Z)V',
  );

  static final _setAllowUserInteraction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setAllowUserInteraction(boolean z)`
  void setAllowUserInteraction(bool z) {
    _setAllowUserInteraction(
      reference.pointer,
      _id_setAllowUserInteraction as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setConnectTimeout = _class.instanceMethodId(
    r'setConnectTimeout',
    r'(I)V',
  );

  static final _setConnectTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setConnectTimeout(int i)`
  void setConnectTimeout(int i) {
    _setConnectTimeout(
      reference.pointer,
      _id_setConnectTimeout as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setContentHandlerFactory = _class.staticMethodId(
    r'setContentHandlerFactory',
    r'(Ljava/net/ContentHandlerFactory;)V',
  );

  static final _setContentHandlerFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setContentHandlerFactory(java.net.ContentHandlerFactory contentHandlerFactory)`
  static void setContentHandlerFactory(jni$_.JObject? contentHandlerFactory) {
    final _$contentHandlerFactory =
        contentHandlerFactory?.reference ?? jni$_.jNullReference;
    _setContentHandlerFactory(
      _class.reference.pointer,
      _id_setContentHandlerFactory as jni$_.JMethodIDPtr,
      _$contentHandlerFactory.pointer,
    ).check();
  }

  static final _id_setDefaultAllowUserInteraction = _class.staticMethodId(
    r'setDefaultAllowUserInteraction',
    r'(Z)V',
  );

  static final _setDefaultAllowUserInteraction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public void setDefaultAllowUserInteraction(boolean z)`
  static void setDefaultAllowUserInteraction(bool z) {
    _setDefaultAllowUserInteraction(
      _class.reference.pointer,
      _id_setDefaultAllowUserInteraction as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setDefaultRequestProperty = _class.staticMethodId(
    r'setDefaultRequestProperty',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setDefaultRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDefaultRequestProperty(java.lang.String string, java.lang.String string1)`
  static void setDefaultRequestProperty(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setDefaultRequestProperty(
      _class.reference.pointer,
      _id_setDefaultRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).check();
  }

  static final _id_setDefaultUseCaches = _class.instanceMethodId(
    r'setDefaultUseCaches',
    r'(Z)V',
  );

  static final _setDefaultUseCaches =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDefaultUseCaches(boolean z)`
  void setDefaultUseCaches(bool z) {
    _setDefaultUseCaches(
      reference.pointer,
      _id_setDefaultUseCaches as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setDoInput = _class.instanceMethodId(r'setDoInput', r'(Z)V');

  static final _setDoInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDoInput(boolean z)`
  void setDoInput(bool z) {
    _setDoInput(
      reference.pointer,
      _id_setDoInput as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setDoOutput = _class.instanceMethodId(
    r'setDoOutput',
    r'(Z)V',
  );

  static final _setDoOutput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDoOutput(boolean z)`
  void setDoOutput(bool z) {
    _setDoOutput(
      reference.pointer,
      _id_setDoOutput as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setFileNameMap = _class.staticMethodId(
    r'setFileNameMap',
    r'(Ljava/net/FileNameMap;)V',
  );

  static final _setFileNameMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setFileNameMap(java.net.FileNameMap fileNameMap)`
  static void setFileNameMap(jni$_.JObject? fileNameMap) {
    final _$fileNameMap = fileNameMap?.reference ?? jni$_.jNullReference;
    _setFileNameMap(
      _class.reference.pointer,
      _id_setFileNameMap as jni$_.JMethodIDPtr,
      _$fileNameMap.pointer,
    ).check();
  }

  static final _id_setIfModifiedSince = _class.instanceMethodId(
    r'setIfModifiedSince',
    r'(J)V',
  );

  static final _setIfModifiedSince =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setIfModifiedSince(long j)`
  void setIfModifiedSince(int j) {
    _setIfModifiedSince(
      reference.pointer,
      _id_setIfModifiedSince as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_setReadTimeout = _class.instanceMethodId(
    r'setReadTimeout',
    r'(I)V',
  );

  static final _setReadTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReadTimeout(int i)`
  void setReadTimeout(int i) {
    _setReadTimeout(
      reference.pointer,
      _id_setReadTimeout as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setRequestProperty = _class.instanceMethodId(
    r'setRequestProperty',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setRequestProperty(java.lang.String string, java.lang.String string1)`
  void setRequestProperty(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setRequestProperty(
      reference.pointer,
      _id_setRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).check();
  }

  static final _id_setUseCaches = _class.instanceMethodId(
    r'setUseCaches',
    r'(Z)V',
  );

  static final _setUseCaches =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setUseCaches(boolean z)`
  void setUseCaches(bool z) {
    _setUseCaches(
      reference.pointer,
      _id_setUseCaches as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $URLConnection$NullableType$ extends jni$_.JType<URLConnection?> {
  @jni$_.internal
  const $URLConnection$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLConnection;';

  @jni$_.internal
  @core$_.override
  URLConnection? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URLConnection.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<URLConnection?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLConnection$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($URLConnection$NullableType$) &&
        other is $URLConnection$NullableType$;
  }
}

final class $URLConnection$Type$ extends jni$_.JType<URLConnection> {
  @jni$_.internal
  const $URLConnection$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLConnection;';

  @jni$_.internal
  @core$_.override
  URLConnection fromReference(jni$_.JReference reference) =>
      URLConnection.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<URLConnection?> get nullableType =>
      const $URLConnection$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLConnection$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($URLConnection$Type$) &&
        other is $URLConnection$Type$;
  }
}
