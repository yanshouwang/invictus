// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'Collection.dart' as collection$_;

/// from: `java.util.AbstractMap$SimpleEntry`
class AbstractMap$SimpleEntry<
  $K extends jni$_.JObject?,
  $V extends jni$_.JObject?
>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<AbstractMap$SimpleEntry<$K, $V>> $type;

  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  AbstractMap$SimpleEntry.fromReference(
    this.K,
    this.V,
    jni$_.JReference reference,
  ) : $type = type<$K, $V>(K, V),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/util/AbstractMap$SimpleEntry',
  );

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<AbstractMap$SimpleEntry<$K, $V>?> nullableType<
    $K extends jni$_.JObject?,
    $V extends jni$_.JObject?
  >(jni$_.JType<$K> K, jni$_.JType<$V> V) {
    return $AbstractMap$SimpleEntry$NullableType$<$K, $V>(K, V);
  }

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<AbstractMap$SimpleEntry<$K, $V>> type<
    $K extends jni$_.JObject?,
    $V extends jni$_.JObject?
  >(jni$_.JType<$K> K, jni$_.JType<$V> V) {
    return $AbstractMap$SimpleEntry$Type$<$K, $V>(K, V);
  }

  static final _id_new$ = _class.constructorId(r'(Ljava/util/Map$Entry;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.util.Map$Entry<? extends K, ? extends V> entry)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AbstractMap$SimpleEntry(
    jni$_.JObject? entry, {
    required jni$_.JType<$K> K,
    required jni$_.JType<$V> V,
  }) {
    final _$entry = entry?.reference ?? jni$_.jNullReference;
    return AbstractMap$SimpleEntry<$K, $V>.fromReference(
      K,
      V,
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$entry.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AbstractMap$SimpleEntry.new$1(
    $K? object,
    $V? object1, {
    required jni$_.JType<$K> K,
    required jni$_.JType<$V> V,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return AbstractMap$SimpleEntry<$K, $V>.fromReference(
      K,
      V,
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$object.pointer,
        _$object1.pointer,
      ).reference,
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_getKey = _class.instanceMethodId(
    r'getKey',
    r'()Ljava/lang/Object;',
  );

  static final _getKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public K getKey()`
  /// The returned object must be released after use, by calling the [release] method.
  $K? getKey() {
    return _getKey(
      reference.pointer,
      _id_getKey as jni$_.JMethodIDPtr,
    ).object<$K?>(K.nullableType);
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Ljava/lang/Object;',
  );

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public V getValue()`
  /// The returned object must be released after use, by calling the [release] method.
  $V? getValue() {
    return _getValue(
      reference.pointer,
      _id_getValue as jni$_.JMethodIDPtr,
    ).object<$V?>(V.nullableType);
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setValue = _class.instanceMethodId(
    r'setValue',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _setValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V setValue(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? setValue($V? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _setValue(
      reference.pointer,
      _id_setValue as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $AbstractMap$SimpleEntry$NullableType$<
  $K extends jni$_.JObject?,
  $V extends jni$_.JObject?
>
    extends jni$_.JType<AbstractMap$SimpleEntry<$K, $V>?> {
  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  const $AbstractMap$SimpleEntry$NullableType$(this.K, this.V);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/AbstractMap$SimpleEntry;';

  @jni$_.internal
  @core$_.override
  AbstractMap$SimpleEntry<$K, $V>? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : AbstractMap$SimpleEntry<$K, $V>.fromReference(K, V, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<AbstractMap$SimpleEntry<$K, $V>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($AbstractMap$SimpleEntry$NullableType$, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AbstractMap$SimpleEntry$NullableType$<$K, $V>) &&
        other is $AbstractMap$SimpleEntry$NullableType$<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

final class $AbstractMap$SimpleEntry$Type$<
  $K extends jni$_.JObject?,
  $V extends jni$_.JObject?
>
    extends jni$_.JType<AbstractMap$SimpleEntry<$K, $V>> {
  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  const $AbstractMap$SimpleEntry$Type$(this.K, this.V);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/AbstractMap$SimpleEntry;';

  @jni$_.internal
  @core$_.override
  AbstractMap$SimpleEntry<$K, $V> fromReference(jni$_.JReference reference) =>
      AbstractMap$SimpleEntry<$K, $V>.fromReference(K, V, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<AbstractMap$SimpleEntry<$K, $V>?> get nullableType =>
      $AbstractMap$SimpleEntry$NullableType$<$K, $V>(K, V);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($AbstractMap$SimpleEntry$Type$, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AbstractMap$SimpleEntry$Type$<$K, $V>) &&
        other is $AbstractMap$SimpleEntry$Type$<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `java.util.AbstractMap$SimpleImmutableEntry`
class AbstractMap$SimpleImmutableEntry<
  $K extends jni$_.JObject?,
  $V extends jni$_.JObject?
>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<AbstractMap$SimpleImmutableEntry<$K, $V>> $type;

  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  AbstractMap$SimpleImmutableEntry.fromReference(
    this.K,
    this.V,
    jni$_.JReference reference,
  ) : $type = type<$K, $V>(K, V),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/util/AbstractMap$SimpleImmutableEntry',
  );

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<AbstractMap$SimpleImmutableEntry<$K, $V>?> nullableType<
    $K extends jni$_.JObject?,
    $V extends jni$_.JObject?
  >(jni$_.JType<$K> K, jni$_.JType<$V> V) {
    return $AbstractMap$SimpleImmutableEntry$NullableType$<$K, $V>(K, V);
  }

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<AbstractMap$SimpleImmutableEntry<$K, $V>> type<
    $K extends jni$_.JObject?,
    $V extends jni$_.JObject?
  >(jni$_.JType<$K> K, jni$_.JType<$V> V) {
    return $AbstractMap$SimpleImmutableEntry$Type$<$K, $V>(K, V);
  }

  static final _id_new$ = _class.constructorId(r'(Ljava/util/Map$Entry;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.util.Map$Entry<? extends K, ? extends V> entry)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AbstractMap$SimpleImmutableEntry(
    jni$_.JObject? entry, {
    required jni$_.JType<$K> K,
    required jni$_.JType<$V> V,
  }) {
    final _$entry = entry?.reference ?? jni$_.jNullReference;
    return AbstractMap$SimpleImmutableEntry<$K, $V>.fromReference(
      K,
      V,
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$entry.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AbstractMap$SimpleImmutableEntry.new$1(
    $K? object,
    $V? object1, {
    required jni$_.JType<$K> K,
    required jni$_.JType<$V> V,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return AbstractMap$SimpleImmutableEntry<$K, $V>.fromReference(
      K,
      V,
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$object.pointer,
        _$object1.pointer,
      ).reference,
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_getKey = _class.instanceMethodId(
    r'getKey',
    r'()Ljava/lang/Object;',
  );

  static final _getKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public K getKey()`
  /// The returned object must be released after use, by calling the [release] method.
  $K? getKey() {
    return _getKey(
      reference.pointer,
      _id_getKey as jni$_.JMethodIDPtr,
    ).object<$K?>(K.nullableType);
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Ljava/lang/Object;',
  );

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public V getValue()`
  /// The returned object must be released after use, by calling the [release] method.
  $V? getValue() {
    return _getValue(
      reference.pointer,
      _id_getValue as jni$_.JMethodIDPtr,
    ).object<$V?>(V.nullableType);
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setValue = _class.instanceMethodId(
    r'setValue',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _setValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V setValue(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? setValue($V? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _setValue(
      reference.pointer,
      _id_setValue as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $AbstractMap$SimpleImmutableEntry$NullableType$<
  $K extends jni$_.JObject?,
  $V extends jni$_.JObject?
>
    extends jni$_.JType<AbstractMap$SimpleImmutableEntry<$K, $V>?> {
  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  const $AbstractMap$SimpleImmutableEntry$NullableType$(this.K, this.V);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/AbstractMap$SimpleImmutableEntry;';

  @jni$_.internal
  @core$_.override
  AbstractMap$SimpleImmutableEntry<$K, $V>? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : AbstractMap$SimpleImmutableEntry<$K, $V>.fromReference(K, V, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<AbstractMap$SimpleImmutableEntry<$K, $V>?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      Object.hash($AbstractMap$SimpleImmutableEntry$NullableType$, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AbstractMap$SimpleImmutableEntry$NullableType$<$K, $V>) &&
        other is $AbstractMap$SimpleImmutableEntry$NullableType$<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

final class $AbstractMap$SimpleImmutableEntry$Type$<
  $K extends jni$_.JObject?,
  $V extends jni$_.JObject?
>
    extends jni$_.JType<AbstractMap$SimpleImmutableEntry<$K, $V>> {
  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  const $AbstractMap$SimpleImmutableEntry$Type$(this.K, this.V);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/AbstractMap$SimpleImmutableEntry;';

  @jni$_.internal
  @core$_.override
  AbstractMap$SimpleImmutableEntry<$K, $V> fromReference(
    jni$_.JReference reference,
  ) => AbstractMap$SimpleImmutableEntry<$K, $V>.fromReference(K, V, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<AbstractMap$SimpleImmutableEntry<$K, $V>?> get nullableType =>
      $AbstractMap$SimpleImmutableEntry$NullableType$<$K, $V>(K, V);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      Object.hash($AbstractMap$SimpleImmutableEntry$Type$, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AbstractMap$SimpleImmutableEntry$Type$<$K, $V>) &&
        other is $AbstractMap$SimpleImmutableEntry$Type$<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `java.util.AbstractMap`
class AbstractMap<$K extends jni$_.JObject?, $V extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<AbstractMap<$K, $V>> $type;

  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  AbstractMap.fromReference(this.K, this.V, jni$_.JReference reference)
    : $type = type<$K, $V>(K, V),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/AbstractMap');

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<AbstractMap<$K, $V>?> nullableType<
    $K extends jni$_.JObject?,
    $V extends jni$_.JObject?
  >(jni$_.JType<$K> K, jni$_.JType<$V> V) {
    return $AbstractMap$NullableType$<$K, $V>(K, V);
  }

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<AbstractMap<$K, $V>> type<
    $K extends jni$_.JObject?,
    $V extends jni$_.JObject?
  >(jni$_.JType<$K> K, jni$_.JType<$V> V) {
    return $AbstractMap$Type$<$K, $V>(K, V);
  }

  static final _id_clear = _class.instanceMethodId(r'clear', r'()V');

  static final _clear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_containsKey = _class.instanceMethodId(
    r'containsKey',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean containsKey(java.lang.Object object)`
  bool containsKey(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _containsKey(
      reference.pointer,
      _id_containsKey as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_containsValue = _class.instanceMethodId(
    r'containsValue',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean containsValue(java.lang.Object object)`
  bool containsValue(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _containsValue(
      reference.pointer,
      _id_containsValue as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_entrySet = _class.instanceMethodId(
    r'entrySet',
    r'()Ljava/util/Set;',
  );

  static final _entrySet =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JObject?>? entrySet() {
    return _entrySet(
      reference.pointer,
      _id_entrySet as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JObject?>?>(
      const jni$_.$JSet$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V get(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isEmpty = _class.instanceMethodId(r'isEmpty', r'()Z');

  static final _isEmpty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isEmpty()`
  bool isEmpty() {
    return _isEmpty(
      reference.pointer,
      _id_isEmpty as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_keySet = _class.instanceMethodId(
    r'keySet',
    r'()Ljava/util/Set;',
  );

  static final _keySet =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<K> keySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<$K?>? keySet() {
    return _keySet(
      reference.pointer,
      _id_keySet as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<$K?>?>(jni$_.$JSet$NullableType$<$K?>(K.nullableType));
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V put(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? put($K? object, $V? object1) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _put(
      reference.pointer,
      _id_put as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$object1.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_putAll = _class.instanceMethodId(
    r'putAll',
    r'(Ljava/util/Map;)V',
  );

  static final _putAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void putAll(java.util.Map<? extends K, ? extends V> map)`
  void putAll(jni$_.JMap<$K?, $V?>? map) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _putAll(
      reference.pointer,
      _id_putAll as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).check();
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _remove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V remove(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? remove(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _remove(
      reference.pointer,
      _id_remove as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_values = _class.instanceMethodId(
    r'values',
    r'()Ljava/util/Collection;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Collection<V> values()`
  /// The returned object must be released after use, by calling the [release] method.
  collection$_.Collection<$V?>? values() {
    return _values(
      reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<collection$_.Collection<$V?>?>(
      collection$_.$Collection$NullableType$<$V?>(V.nullableType),
    );
  }
}

final class $AbstractMap$NullableType$<
  $K extends jni$_.JObject?,
  $V extends jni$_.JObject?
>
    extends jni$_.JType<AbstractMap<$K, $V>?> {
  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  const $AbstractMap$NullableType$(this.K, this.V);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/AbstractMap;';

  @jni$_.internal
  @core$_.override
  AbstractMap<$K, $V>? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : AbstractMap<$K, $V>.fromReference(K, V, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<AbstractMap<$K, $V>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($AbstractMap$NullableType$, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AbstractMap$NullableType$<$K, $V>) &&
        other is $AbstractMap$NullableType$<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

final class $AbstractMap$Type$<
  $K extends jni$_.JObject?,
  $V extends jni$_.JObject?
>
    extends jni$_.JType<AbstractMap<$K, $V>> {
  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  const $AbstractMap$Type$(this.K, this.V);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/AbstractMap;';

  @jni$_.internal
  @core$_.override
  AbstractMap<$K, $V> fromReference(jni$_.JReference reference) =>
      AbstractMap<$K, $V>.fromReference(K, V, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<AbstractMap<$K, $V>?> get nullableType =>
      $AbstractMap$NullableType$<$K, $V>(K, V);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($AbstractMap$Type$, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AbstractMap$Type$<$K, $V>) &&
        other is $AbstractMap$Type$<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}
