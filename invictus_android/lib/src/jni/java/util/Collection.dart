// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.util.Collection`
class Collection<$E extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Collection<$E>> $type;

  @jni$_.internal
  final jni$_.JType<$E> E;

  @jni$_.internal
  Collection.fromReference(this.E, jni$_.JReference reference)
    : $type = type<$E>(E),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/Collection');

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<Collection<$E>?> nullableType<$E extends jni$_.JObject?>(
    jni$_.JType<$E> E,
  ) {
    return $Collection$NullableType$<$E>(E);
  }

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<Collection<$E>> type<$E extends jni$_.JObject?>(
    jni$_.JType<$E> E,
  ) {
    return $Collection$Type$<$E>(E);
  }

  static final _id_add = _class.instanceMethodId(
    r'add',
    r'(Ljava/lang/Object;)Z',
  );

  static final _add =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean add(E object)`
  bool add($E? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _add(
      reference.pointer,
      _id_add as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_addAll = _class.instanceMethodId(
    r'addAll',
    r'(Ljava/util/Collection;)Z',
  );

  static final _addAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean addAll(java.util.Collection<? extends E> collection)`
  bool addAll(Collection<$E?>? collection) {
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    return _addAll(
      reference.pointer,
      _id_addAll as jni$_.JMethodIDPtr,
      _$collection.pointer,
    ).boolean;
  }

  static final _id_clear = _class.instanceMethodId(r'clear', r'()V');

  static final _clear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_contains = _class.instanceMethodId(
    r'contains',
    r'(Ljava/lang/Object;)Z',
  );

  static final _contains =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean contains(java.lang.Object object)`
  bool contains(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _contains(
      reference.pointer,
      _id_contains as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_containsAll = _class.instanceMethodId(
    r'containsAll',
    r'(Ljava/util/Collection;)Z',
  );

  static final _containsAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean containsAll(java.util.Collection<?> collection)`
  bool containsAll(Collection<jni$_.JObject?>? collection) {
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    return _containsAll(
      reference.pointer,
      _id_containsAll as jni$_.JMethodIDPtr,
      _$collection.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isEmpty = _class.instanceMethodId(r'isEmpty', r'()Z');

  static final _isEmpty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean isEmpty()`
  bool isEmpty() {
    return _isEmpty(
      reference.pointer,
      _id_isEmpty as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_iterator = _class.instanceMethodId(
    r'iterator',
    r'()Ljava/util/Iterator;',
  );

  static final _iterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.Iterator<E> iterator()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIterator<$E?>? iterator() {
    return _iterator(
      reference.pointer,
      _id_iterator as jni$_.JMethodIDPtr,
    ).object<jni$_.JIterator<$E?>?>(
      jni$_.$JIterator$NullableType$<$E?>(E.nullableType),
    );
  }

  static final _id_parallelStream = _class.instanceMethodId(
    r'parallelStream',
    r'()Ljava/util/stream/Stream;',
  );

  static final _parallelStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.stream.Stream<E> parallelStream()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? parallelStream() {
    return _parallelStream(
      reference.pointer,
      _id_parallelStream as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;)Z',
  );

  static final _remove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean remove(java.lang.Object object)`
  bool remove(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _remove(
      reference.pointer,
      _id_remove as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_removeAll = _class.instanceMethodId(
    r'removeAll',
    r'(Ljava/util/Collection;)Z',
  );

  static final _removeAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean removeAll(java.util.Collection<?> collection)`
  bool removeAll(Collection<jni$_.JObject?>? collection) {
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    return _removeAll(
      reference.pointer,
      _id_removeAll as jni$_.JMethodIDPtr,
      _$collection.pointer,
    ).boolean;
  }

  static final _id_removeIf = _class.instanceMethodId(
    r'removeIf',
    r'(Ljava/util/function/Predicate;)Z',
  );

  static final _removeIf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean removeIf(java.util.function.Predicate<? super E> predicate)`
  bool removeIf(jni$_.JObject? predicate) {
    final _$predicate = predicate?.reference ?? jni$_.jNullReference;
    return _removeIf(
      reference.pointer,
      _id_removeIf as jni$_.JMethodIDPtr,
      _$predicate.pointer,
    ).boolean;
  }

  static final _id_retainAll = _class.instanceMethodId(
    r'retainAll',
    r'(Ljava/util/Collection;)Z',
  );

  static final _retainAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean retainAll(java.util.Collection<?> collection)`
  bool retainAll(Collection<jni$_.JObject?>? collection) {
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    return _retainAll(
      reference.pointer,
      _id_retainAll as jni$_.JMethodIDPtr,
      _$collection.pointer,
    ).boolean;
  }

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }

  static final _id_spliterator = _class.instanceMethodId(
    r'spliterator',
    r'()Ljava/util/Spliterator;',
  );

  static final _spliterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Spliterator<E> spliterator()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? spliterator() {
    return _spliterator(
      reference.pointer,
      _id_spliterator as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_stream = _class.instanceMethodId(
    r'stream',
    r'()Ljava/util/stream/Stream;',
  );

  static final _stream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.stream.Stream<E> stream()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? stream() {
    return _stream(
      reference.pointer,
      _id_stream as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_toArray = _class.instanceMethodId(
    r'toArray',
    r'()[Ljava/lang/Object;',
  );

  static final _toArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.Object[] toArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? toArray() {
    return _toArray(
      reference.pointer,
      _id_toArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JObject?>?>(
      const jni$_.$JArray$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_toArray$1 = _class.instanceMethodId(
    r'toArray',
    r'(Ljava/util/function/IntFunction;)[Ljava/lang/Object;',
  );

  static final _toArray$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T[] toArray(java.util.function.IntFunction<T[]> intFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<$T?>? toArray$1<$T extends jni$_.JObject?>(
    jni$_.JObject? intFunction, {
    required jni$_.JType<$T> T,
  }) {
    final _$intFunction = intFunction?.reference ?? jni$_.jNullReference;
    return _toArray$1(
      reference.pointer,
      _id_toArray$1 as jni$_.JMethodIDPtr,
      _$intFunction.pointer,
    ).object<jni$_.JArray<$T?>?>(
      jni$_.$JArray$NullableType$<$T?>(T.nullableType),
    );
  }

  static final _id_toArray$2 = _class.instanceMethodId(
    r'toArray',
    r'([Ljava/lang/Object;)[Ljava/lang/Object;',
  );

  static final _toArray$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract T[] toArray(T[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<$T?>? toArray$2<$T extends jni$_.JObject?>(
    jni$_.JArray<$T?>? objects, {
    required jni$_.JType<$T> T,
  }) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _toArray$2(
      reference.pointer,
      _id_toArray$2 as jni$_.JMethodIDPtr,
      _$objects.pointer,
    ).object<jni$_.JArray<$T?>?>(
      jni$_.$JArray$NullableType$<$T?>(T.nullableType),
    );
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Collection> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'add(Ljava/lang/Object;)Z') {
        final $r = _$impls[$p]!.add(
          $a![0]?.as(_$impls[$p]!.E, releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'addAll(Ljava/util/Collection;)Z') {
        final $r = _$impls[$p]!.addAll(
          $a![0]?.as(
            const $Collection$Type$<jni$_.JObject?>(
              jni$_.$JObject$NullableType$(),
            ),
            releaseOriginal: true,
          ),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'clear()V') {
        _$impls[$p]!.clear();
        return jni$_.nullptr;
      }
      if ($d == r'contains(Ljava/lang/Object;)Z') {
        final $r = _$impls[$p]!.contains(
          $a![0]?.as(const jni$_.$JObject$Type$(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'containsAll(Ljava/util/Collection;)Z') {
        final $r = _$impls[$p]!.containsAll(
          $a![0]?.as(
            const $Collection$Type$<jni$_.JObject?>(
              jni$_.$JObject$NullableType$(),
            ),
            releaseOriginal: true,
          ),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'equals(Ljava/lang/Object;)Z') {
        final $r = _$impls[$p]!.equals(
          $a![0]?.as(const jni$_.$JObject$Type$(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'hashCode()I') {
        final $r = _$impls[$p]!.hashCode$1();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'isEmpty()Z') {
        final $r = _$impls[$p]!.isEmpty();
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'iterator()Ljava/util/Iterator;') {
        final $r = _$impls[$p]!.iterator();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'parallelStream()Ljava/util/stream/Stream;') {
        final $r = _$impls[$p]!.parallelStream();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'remove(Ljava/lang/Object;)Z') {
        final $r = _$impls[$p]!.remove(
          $a![0]?.as(const jni$_.$JObject$Type$(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'removeAll(Ljava/util/Collection;)Z') {
        final $r = _$impls[$p]!.removeAll(
          $a![0]?.as(
            const $Collection$Type$<jni$_.JObject?>(
              jni$_.$JObject$NullableType$(),
            ),
            releaseOriginal: true,
          ),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'removeIf(Ljava/util/function/Predicate;)Z') {
        final $r = _$impls[$p]!.removeIf(
          $a![0]?.as(const jni$_.$JObject$Type$(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'retainAll(Ljava/util/Collection;)Z') {
        final $r = _$impls[$p]!.retainAll(
          $a![0]?.as(
            const $Collection$Type$<jni$_.JObject?>(
              jni$_.$JObject$NullableType$(),
            ),
            releaseOriginal: true,
          ),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'size()I') {
        final $r = _$impls[$p]!.size();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'spliterator()Ljava/util/Spliterator;') {
        final $r = _$impls[$p]!.spliterator();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'stream()Ljava/util/stream/Stream;') {
        final $r = _$impls[$p]!.stream();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'toArray()[Ljava/lang/Object;') {
        final $r = _$impls[$p]!.toArray();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'toArray(Ljava/util/function/IntFunction;)[Ljava/lang/Object;') {
        final $r = _$impls[$p]!.toArray$1(
          $a![0]?.as(const jni$_.$JObject$Type$(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'toArray([Ljava/lang/Object;)[Ljava/lang/Object;') {
        final $r = _$impls[$p]!.toArray$2(
          $a![0]?.as(
            const jni$_.$JArray$Type$<jni$_.JObject?>(
              jni$_.$JObject$NullableType$(),
            ),
            releaseOriginal: true,
          ),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$E extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $Collection<$E> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.util.Collection', $p, _$invokePointer, [
      if ($impl.clear$async) r'clear()V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Collection.implement($Collection<$E> $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Collection<$E>.fromReference($impl.E, $i.implementReference());
  }
}

abstract base mixin class $Collection<$E extends jni$_.JObject?> {
  factory $Collection({
    required jni$_.JType<$E> E,
    required bool Function($E? object) add,
    required bool Function(Collection<jni$_.JObject?>? collection) addAll,
    required void Function() clear,
    bool clear$async,
    required bool Function(jni$_.JObject? object) contains,
    required bool Function(Collection<jni$_.JObject?>? collection) containsAll,
    required bool Function(jni$_.JObject? object) equals,
    required int Function() hashCode$1,
    required bool Function() isEmpty,
    required jni$_.JIterator<jni$_.JObject?>? Function() iterator,
    required jni$_.JObject? Function() parallelStream,
    required bool Function(jni$_.JObject? object) remove,
    required bool Function(Collection<jni$_.JObject?>? collection) removeAll,
    required bool Function(jni$_.JObject? predicate) removeIf,
    required bool Function(Collection<jni$_.JObject?>? collection) retainAll,
    required int Function() size,
    required jni$_.JObject? Function() spliterator,
    required jni$_.JObject? Function() stream,
    required jni$_.JArray<jni$_.JObject?>? Function() toArray,
    required jni$_.JArray<jni$_.JObject?>? Function(jni$_.JObject? intFunction)
    toArray$1,
    required jni$_.JArray<jni$_.JObject?>? Function(
      jni$_.JArray<jni$_.JObject?>? objects,
    )
    toArray$2,
  }) = _$Collection<$E>;

  jni$_.JType<$E> get E;

  bool add($E? object);
  bool addAll(Collection<jni$_.JObject?>? collection);
  void clear();
  bool get clear$async => false;
  bool contains(jni$_.JObject? object);
  bool containsAll(Collection<jni$_.JObject?>? collection);
  bool equals(jni$_.JObject? object);
  int hashCode$1();
  bool isEmpty();
  jni$_.JIterator<jni$_.JObject?>? iterator();
  jni$_.JObject? parallelStream();
  bool remove(jni$_.JObject? object);
  bool removeAll(Collection<jni$_.JObject?>? collection);
  bool removeIf(jni$_.JObject? predicate);
  bool retainAll(Collection<jni$_.JObject?>? collection);
  int size();
  jni$_.JObject? spliterator();
  jni$_.JObject? stream();
  jni$_.JArray<jni$_.JObject?>? toArray();
  jni$_.JArray<jni$_.JObject?>? toArray$1(jni$_.JObject? intFunction);
  jni$_.JArray<jni$_.JObject?>? toArray$2(
    jni$_.JArray<jni$_.JObject?>? objects,
  );
}

final class _$Collection<$E extends jni$_.JObject?> with $Collection<$E> {
  _$Collection({
    required this.E,
    required bool Function($E? object) add,
    required bool Function(Collection<jni$_.JObject?>? collection) addAll,
    required void Function() clear,
    this.clear$async = false,
    required bool Function(jni$_.JObject? object) contains,
    required bool Function(Collection<jni$_.JObject?>? collection) containsAll,
    required bool Function(jni$_.JObject? object) equals,
    required int Function() hashCode$1,
    required bool Function() isEmpty,
    required jni$_.JIterator<jni$_.JObject?>? Function() iterator,
    required jni$_.JObject? Function() parallelStream,
    required bool Function(jni$_.JObject? object) remove,
    required bool Function(Collection<jni$_.JObject?>? collection) removeAll,
    required bool Function(jni$_.JObject? predicate) removeIf,
    required bool Function(Collection<jni$_.JObject?>? collection) retainAll,
    required int Function() size,
    required jni$_.JObject? Function() spliterator,
    required jni$_.JObject? Function() stream,
    required jni$_.JArray<jni$_.JObject?>? Function() toArray,
    required jni$_.JArray<jni$_.JObject?>? Function(jni$_.JObject? intFunction)
    toArray$1,
    required jni$_.JArray<jni$_.JObject?>? Function(
      jni$_.JArray<jni$_.JObject?>? objects,
    )
    toArray$2,
  }) : _add = add,
       _addAll = addAll,
       _clear = clear,
       _contains = contains,
       _containsAll = containsAll,
       _equals = equals,
       _hashCode$1 = hashCode$1,
       _isEmpty = isEmpty,
       _iterator = iterator,
       _parallelStream = parallelStream,
       _remove = remove,
       _removeAll = removeAll,
       _removeIf = removeIf,
       _retainAll = retainAll,
       _size = size,
       _spliterator = spliterator,
       _stream = stream,
       _toArray = toArray,
       _toArray$1 = toArray$1,
       _toArray$2 = toArray$2;

  @core$_.override
  final jni$_.JType<$E> E;

  final bool Function($E? object) _add;
  final bool Function(Collection<jni$_.JObject?>? collection) _addAll;
  final void Function() _clear;
  final bool clear$async;
  final bool Function(jni$_.JObject? object) _contains;
  final bool Function(Collection<jni$_.JObject?>? collection) _containsAll;
  final bool Function(jni$_.JObject? object) _equals;
  final int Function() _hashCode$1;
  final bool Function() _isEmpty;
  final jni$_.JIterator<jni$_.JObject?>? Function() _iterator;
  final jni$_.JObject? Function() _parallelStream;
  final bool Function(jni$_.JObject? object) _remove;
  final bool Function(Collection<jni$_.JObject?>? collection) _removeAll;
  final bool Function(jni$_.JObject? predicate) _removeIf;
  final bool Function(Collection<jni$_.JObject?>? collection) _retainAll;
  final int Function() _size;
  final jni$_.JObject? Function() _spliterator;
  final jni$_.JObject? Function() _stream;
  final jni$_.JArray<jni$_.JObject?>? Function() _toArray;
  final jni$_.JArray<jni$_.JObject?>? Function(jni$_.JObject? intFunction)
  _toArray$1;
  final jni$_.JArray<jni$_.JObject?>? Function(
    jni$_.JArray<jni$_.JObject?>? objects,
  )
  _toArray$2;

  bool add($E? object) {
    return _add(object);
  }

  bool addAll(Collection<jni$_.JObject?>? collection) {
    return _addAll(collection);
  }

  void clear() {
    return _clear();
  }

  bool contains(jni$_.JObject? object) {
    return _contains(object);
  }

  bool containsAll(Collection<jni$_.JObject?>? collection) {
    return _containsAll(collection);
  }

  bool equals(jni$_.JObject? object) {
    return _equals(object);
  }

  int hashCode$1() {
    return _hashCode$1();
  }

  bool isEmpty() {
    return _isEmpty();
  }

  jni$_.JIterator<jni$_.JObject?>? iterator() {
    return _iterator();
  }

  jni$_.JObject? parallelStream() {
    return _parallelStream();
  }

  bool remove(jni$_.JObject? object) {
    return _remove(object);
  }

  bool removeAll(Collection<jni$_.JObject?>? collection) {
    return _removeAll(collection);
  }

  bool removeIf(jni$_.JObject? predicate) {
    return _removeIf(predicate);
  }

  bool retainAll(Collection<jni$_.JObject?>? collection) {
    return _retainAll(collection);
  }

  int size() {
    return _size();
  }

  jni$_.JObject? spliterator() {
    return _spliterator();
  }

  jni$_.JObject? stream() {
    return _stream();
  }

  jni$_.JArray<jni$_.JObject?>? toArray() {
    return _toArray();
  }

  jni$_.JArray<jni$_.JObject?>? toArray$1(jni$_.JObject? intFunction) {
    return _toArray$1(intFunction);
  }

  jni$_.JArray<jni$_.JObject?>? toArray$2(
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    return _toArray$2(objects);
  }
}

final class $Collection$NullableType$<$E extends jni$_.JObject?>
    extends jni$_.JType<Collection<$E>?> {
  @jni$_.internal
  final jni$_.JType<$E> E;

  @jni$_.internal
  const $Collection$NullableType$(this.E);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Collection;';

  @jni$_.internal
  @core$_.override
  Collection<$E>? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Collection<$E>.fromReference(E, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Collection<$E>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Collection$NullableType$, E);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Collection$NullableType$<$E>) &&
        other is $Collection$NullableType$<$E> &&
        E == other.E;
  }
}

final class $Collection$Type$<$E extends jni$_.JObject?>
    extends jni$_.JType<Collection<$E>> {
  @jni$_.internal
  final jni$_.JType<$E> E;

  @jni$_.internal
  const $Collection$Type$(this.E);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Collection;';

  @jni$_.internal
  @core$_.override
  Collection<$E> fromReference(jni$_.JReference reference) =>
      Collection<$E>.fromReference(E, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Collection<$E>?> get nullableType =>
      $Collection$NullableType$<$E>(E);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Collection$Type$, E);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Collection$Type$<$E>) &&
        other is $Collection$Type$<$E> &&
        E == other.E;
  }
}
