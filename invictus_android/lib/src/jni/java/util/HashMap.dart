// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'AbstractMap.dart' as abstractmap$_;

import 'Collection.dart' as collection$_;

/// from: `java.util.HashMap`
class HashMap<$K extends jni$_.JObject?, $V extends jni$_.JObject?>
    extends abstractmap$_.AbstractMap<$K?, $V?> {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<HashMap<$K, $V>> $type;

  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  HashMap.fromReference(this.K, this.V, jni$_.JReference reference)
    : $type = type<$K, $V>(K, V),
      super.fromReference(K.nullableType, V.nullableType, reference);

  static final _class = jni$_.JClass.forName(r'java/util/HashMap');

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<HashMap<$K, $V>?> nullableType<
    $K extends jni$_.JObject?,
    $V extends jni$_.JObject?
  >(jni$_.JType<$K> K, jni$_.JType<$V> V) {
    return $HashMap$NullableType$<$K, $V>(K, V);
  }

  /// The type which includes information such as the signature of this class.
  static jni$_.JType<HashMap<$K, $V>> type<
    $K extends jni$_.JObject?,
    $V extends jni$_.JObject?
  >(jni$_.JType<$K> K, jni$_.JType<$V> V) {
    return $HashMap$Type$<$K, $V>(K, V);
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap({required jni$_.JType<$K> K, required jni$_.JType<$V> V}) {
    return HashMap<$K, $V>.fromReference(
      K,
      V,
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$1(
    int i, {
    required jni$_.JType<$K> K,
    required jni$_.JType<$V> V,
  }) {
    return HashMap<$K, $V>.fromReference(
      K,
      V,
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(IF)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Double)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              double,
            )
          >();

  /// from: `public void <init>(int i, float f)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$2(
    int i,
    double f, {
    required jni$_.JType<$K> K,
    required jni$_.JType<$V> V,
  }) {
    return HashMap<$K, $V>.fromReference(
      K,
      V,
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        i,
        f,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/util/Map;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.util.Map<? extends K, ? extends V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$3(
    jni$_.JMap<$K?, $V?>? map, {
    required jni$_.JType<$K> K,
    required jni$_.JType<$V> V,
  }) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return HashMap<$K, $V>.fromReference(
      K,
      V,
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$map.pointer,
      ).reference,
    );
  }

  static final _id_clear = _class.instanceMethodId(r'clear', r'()V');

  static final _clear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() {
    return _clone(
      reference.pointer,
      _id_clone as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_compute = _class.instanceMethodId(
    r'compute',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _compute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V compute(K object, java.util.function.BiFunction<? super K, ? super V, ? extends V> biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? compute($K? object, jni$_.JObject? biFunction) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    return _compute(
      reference.pointer,
      _id_compute as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$biFunction.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_computeIfAbsent = _class.instanceMethodId(
    r'computeIfAbsent',
    r'(Ljava/lang/Object;Ljava/util/function/Function;)Ljava/lang/Object;',
  );

  static final _computeIfAbsent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V computeIfAbsent(K object, java.util.function.Function<? super K, ? extends V> function)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? computeIfAbsent($K? object, jni$_.JObject? function) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$function = function?.reference ?? jni$_.jNullReference;
    return _computeIfAbsent(
      reference.pointer,
      _id_computeIfAbsent as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$function.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_computeIfPresent = _class.instanceMethodId(
    r'computeIfPresent',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _computeIfPresent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V computeIfPresent(K object, java.util.function.BiFunction<? super K, ? super V, ? extends V> biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? computeIfPresent($K? object, jni$_.JObject? biFunction) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    return _computeIfPresent(
      reference.pointer,
      _id_computeIfPresent as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$biFunction.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_containsKey = _class.instanceMethodId(
    r'containsKey',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean containsKey(java.lang.Object object)`
  bool containsKey(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _containsKey(
      reference.pointer,
      _id_containsKey as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_containsValue = _class.instanceMethodId(
    r'containsValue',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean containsValue(java.lang.Object object)`
  bool containsValue(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _containsValue(
      reference.pointer,
      _id_containsValue as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_entrySet = _class.instanceMethodId(
    r'entrySet',
    r'()Ljava/util/Set;',
  );

  static final _entrySet =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.util.Map$Entry<K, V>> entrySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JObject?>? entrySet() {
    return _entrySet(
      reference.pointer,
      _id_entrySet as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JObject?>?>(
      const jni$_.$JSet$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_forEach = _class.instanceMethodId(
    r'forEach',
    r'(Ljava/util/function/BiConsumer;)V',
  );

  static final _forEach =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void forEach(java.util.function.BiConsumer<? super K, ? super V> biConsumer)`
  void forEach(jni$_.JObject? biConsumer) {
    final _$biConsumer = biConsumer?.reference ?? jni$_.jNullReference;
    _forEach(
      reference.pointer,
      _id_forEach as jni$_.JMethodIDPtr,
      _$biConsumer.pointer,
    ).check();
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V get(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_getOrDefault = _class.instanceMethodId(
    r'getOrDefault',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _getOrDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V getOrDefault(java.lang.Object object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? getOrDefault(jni$_.JObject? object, $V? object1) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _getOrDefault(
      reference.pointer,
      _id_getOrDefault as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$object1.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_isEmpty = _class.instanceMethodId(r'isEmpty', r'()Z');

  static final _isEmpty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isEmpty()`
  bool isEmpty() {
    return _isEmpty(
      reference.pointer,
      _id_isEmpty as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_keySet = _class.instanceMethodId(
    r'keySet',
    r'()Ljava/util/Set;',
  );

  static final _keySet =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<K> keySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<$K?>? keySet() {
    return _keySet(
      reference.pointer,
      _id_keySet as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<$K?>?>(jni$_.$JSet$NullableType$<$K?>(K.nullableType));
  }

  static final _id_merge = _class.instanceMethodId(
    r'merge',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _merge =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V merge(K object, V object1, java.util.function.BiFunction<? super V, ? super V, ? extends V> biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? merge($K? object, $V? object1, jni$_.JObject? biFunction) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    return _merge(
      reference.pointer,
      _id_merge as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$object1.pointer,
      _$biFunction.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_newHashMap = _class.staticMethodId(
    r'newHashMap',
    r'(I)Ljava/util/HashMap;',
  );

  static final _newHashMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.util.HashMap<K, V> newHashMap(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static HashMap<$K?, $V?>? newHashMap<
    $K extends jni$_.JObject?,
    $V extends jni$_.JObject?
  >(int i, {required jni$_.JType<$K> K, required jni$_.JType<$V> V}) {
    return _newHashMap(
      _class.reference.pointer,
      _id_newHashMap as jni$_.JMethodIDPtr,
      i,
    ).object<HashMap<$K?, $V?>?>(
      $HashMap$NullableType$<$K?, $V?>(K.nullableType, V.nullableType),
    );
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V put(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? put($K? object, $V? object1) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _put(
      reference.pointer,
      _id_put as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$object1.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_putAll = _class.instanceMethodId(
    r'putAll',
    r'(Ljava/util/Map;)V',
  );

  static final _putAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void putAll(java.util.Map<? extends K, ? extends V> map)`
  void putAll(jni$_.JMap<$K?, $V?>? map) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _putAll(
      reference.pointer,
      _id_putAll as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).check();
  }

  static final _id_putIfAbsent = _class.instanceMethodId(
    r'putIfAbsent',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _putIfAbsent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V putIfAbsent(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? putIfAbsent($K? object, $V? object1) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _putIfAbsent(
      reference.pointer,
      _id_putIfAbsent as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$object1.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _remove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V remove(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? remove(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _remove(
      reference.pointer,
      _id_remove as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_remove$1 = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _remove$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean remove(java.lang.Object object, java.lang.Object object1)`
  bool remove$1(jni$_.JObject? object, jni$_.JObject? object1) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _remove$1(
      reference.pointer,
      _id_remove$1 as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$object1.pointer,
    ).boolean;
  }

  static final _id_replace = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _replace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public V replace(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? replace($K? object, $V? object1) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _replace(
      reference.pointer,
      _id_replace as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$object1.pointer,
    ).object<$V?>(V.nullableType);
  }

  static final _id_replace$1 = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _replace$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean replace(K object, V object1, V object2)`
  bool replace$1($K? object, $V? object1, $V? object2) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    final _$object2 = object2?.reference ?? jni$_.jNullReference;
    return _replace$1(
      reference.pointer,
      _id_replace$1 as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$object1.pointer,
      _$object2.pointer,
    ).boolean;
  }

  static final _id_replaceAll = _class.instanceMethodId(
    r'replaceAll',
    r'(Ljava/util/function/BiFunction;)V',
  );

  static final _replaceAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V> biFunction)`
  void replaceAll(jni$_.JObject? biFunction) {
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    _replaceAll(
      reference.pointer,
      _id_replaceAll as jni$_.JMethodIDPtr,
      _$biFunction.pointer,
    ).check();
  }

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.instanceMethodId(
    r'values',
    r'()Ljava/util/Collection;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Collection<V> values()`
  /// The returned object must be released after use, by calling the [release] method.
  collection$_.Collection<$V?>? values() {
    return _values(
      reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<collection$_.Collection<$V?>?>(
      collection$_.$Collection$NullableType$<$V?>(V.nullableType),
    );
  }
}

final class $HashMap$NullableType$<
  $K extends jni$_.JObject?,
  $V extends jni$_.JObject?
>
    extends jni$_.JType<HashMap<$K, $V>?> {
  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  const $HashMap$NullableType$(this.K, this.V);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/HashMap;';

  @jni$_.internal
  @core$_.override
  HashMap<$K, $V>? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : HashMap<$K, $V>.fromReference(K, V, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => abstractmap$_
      .$AbstractMap$NullableType$<$K?, $V?>(K.nullableType, V.nullableType);

  @jni$_.internal
  @core$_.override
  jni$_.JType<HashMap<$K, $V>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => Object.hash($HashMap$NullableType$, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashMap$NullableType$<$K, $V>) &&
        other is $HashMap$NullableType$<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

final class $HashMap$Type$<$K extends jni$_.JObject?, $V extends jni$_.JObject?>
    extends jni$_.JType<HashMap<$K, $V>> {
  @jni$_.internal
  final jni$_.JType<$K> K;

  @jni$_.internal
  final jni$_.JType<$V> V;

  @jni$_.internal
  const $HashMap$Type$(this.K, this.V);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/HashMap;';

  @jni$_.internal
  @core$_.override
  HashMap<$K, $V> fromReference(jni$_.JReference reference) =>
      HashMap<$K, $V>.fromReference(K, V, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => abstractmap$_
      .$AbstractMap$NullableType$<$K?, $V?>(K.nullableType, V.nullableType);

  @jni$_.internal
  @core$_.override
  jni$_.JType<HashMap<$K, $V>?> get nullableType =>
      $HashMap$NullableType$<$K, $V>(K, V);

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => Object.hash($HashMap$Type$, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashMap$Type$<$K, $V>) &&
        other is $HashMap$Type$<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}
