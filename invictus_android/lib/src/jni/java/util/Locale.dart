// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'Collection.dart' as collection$_;

/// from: `java.util.Locale$Builder`
class Locale$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Locale$Builder> $type;

  @jni$_.internal
  Locale$Builder.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/Locale$Builder');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$Builder?> nullableType =
      $Locale$Builder$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$Builder> type = $Locale$Builder$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Locale$Builder() {
    return Locale$Builder.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_addUnicodeLocaleAttribute = _class.instanceMethodId(
    r'addUnicodeLocaleAttribute',
    r'(Ljava/lang/String;)Ljava/util/Locale$Builder;',
  );

  static final _addUnicodeLocaleAttribute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder addUnicodeLocaleAttribute(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? addUnicodeLocaleAttribute(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _addUnicodeLocaleAttribute(
      reference.pointer,
      _id_addUnicodeLocaleAttribute as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Ljava/util/Locale;',
  );

  static final _build =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Locale build()`
  /// The returned object must be released after use, by calling the [release] method.
  Locale? build() {
    return _build(
      reference.pointer,
      _id_build as jni$_.JMethodIDPtr,
    ).object<Locale?>(const $Locale$NullableType$());
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()Ljava/util/Locale$Builder;',
  );

  static final _clear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Locale$Builder clear()`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? clear() {
    return _clear(
      reference.pointer,
      _id_clear as jni$_.JMethodIDPtr,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_clearExtensions = _class.instanceMethodId(
    r'clearExtensions',
    r'()Ljava/util/Locale$Builder;',
  );

  static final _clearExtensions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Locale$Builder clearExtensions()`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? clearExtensions() {
    return _clearExtensions(
      reference.pointer,
      _id_clearExtensions as jni$_.JMethodIDPtr,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_removeUnicodeLocaleAttribute = _class.instanceMethodId(
    r'removeUnicodeLocaleAttribute',
    r'(Ljava/lang/String;)Ljava/util/Locale$Builder;',
  );

  static final _removeUnicodeLocaleAttribute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder removeUnicodeLocaleAttribute(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? removeUnicodeLocaleAttribute(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _removeUnicodeLocaleAttribute(
      reference.pointer,
      _id_removeUnicodeLocaleAttribute as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_setExtension = _class.instanceMethodId(
    r'setExtension',
    r'(CLjava/lang/String;)Ljava/util/Locale$Builder;',
  );

  static final _setExtension =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder setExtension(char c, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? setExtension(int c, jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setExtension(
      reference.pointer,
      _id_setExtension as jni$_.JMethodIDPtr,
      c,
      _$string.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_setLanguage = _class.instanceMethodId(
    r'setLanguage',
    r'(Ljava/lang/String;)Ljava/util/Locale$Builder;',
  );

  static final _setLanguage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder setLanguage(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? setLanguage(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setLanguage(
      reference.pointer,
      _id_setLanguage as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_setLanguageTag = _class.instanceMethodId(
    r'setLanguageTag',
    r'(Ljava/lang/String;)Ljava/util/Locale$Builder;',
  );

  static final _setLanguageTag =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder setLanguageTag(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? setLanguageTag(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setLanguageTag(
      reference.pointer,
      _id_setLanguageTag as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_setLocale = _class.instanceMethodId(
    r'setLocale',
    r'(Ljava/util/Locale;)Ljava/util/Locale$Builder;',
  );

  static final _setLocale =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder setLocale(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? setLocale(Locale? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _setLocale(
      reference.pointer,
      _id_setLocale as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_setRegion = _class.instanceMethodId(
    r'setRegion',
    r'(Ljava/lang/String;)Ljava/util/Locale$Builder;',
  );

  static final _setRegion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder setRegion(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? setRegion(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setRegion(
      reference.pointer,
      _id_setRegion as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_setScript = _class.instanceMethodId(
    r'setScript',
    r'(Ljava/lang/String;)Ljava/util/Locale$Builder;',
  );

  static final _setScript =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder setScript(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? setScript(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setScript(
      reference.pointer,
      _id_setScript as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_setUnicodeLocaleKeyword = _class.instanceMethodId(
    r'setUnicodeLocaleKeyword',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/util/Locale$Builder;',
  );

  static final _setUnicodeLocaleKeyword =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder setUnicodeLocaleKeyword(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? setUnicodeLocaleKeyword(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _setUnicodeLocaleKeyword(
      reference.pointer,
      _id_setUnicodeLocaleKeyword as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }

  static final _id_setVariant = _class.instanceMethodId(
    r'setVariant',
    r'(Ljava/lang/String;)Ljava/util/Locale$Builder;',
  );

  static final _setVariant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Locale$Builder setVariant(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Locale$Builder? setVariant(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setVariant(
      reference.pointer,
      _id_setVariant as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Locale$Builder?>(const $Locale$Builder$NullableType$());
  }
}

final class $Locale$Builder$NullableType$ extends jni$_.JType<Locale$Builder?> {
  @jni$_.internal
  const $Locale$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$Builder;';

  @jni$_.internal
  @core$_.override
  Locale$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Locale$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$Builder$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$Builder$NullableType$) &&
        other is $Locale$Builder$NullableType$;
  }
}

final class $Locale$Builder$Type$ extends jni$_.JType<Locale$Builder> {
  @jni$_.internal
  const $Locale$Builder$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$Builder;';

  @jni$_.internal
  @core$_.override
  Locale$Builder fromReference(jni$_.JReference reference) =>
      Locale$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$Builder?> get nullableType =>
      const $Locale$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$Builder$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$Builder$Type$) &&
        other is $Locale$Builder$Type$;
  }
}

/// from: `java.util.Locale$Category`
class Locale$Category extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Locale$Category> $type;

  @jni$_.internal
  Locale$Category.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/Locale$Category');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$Category?> nullableType =
      $Locale$Category$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$Category> type = $Locale$Category$Type$();
  static final _id_DISPLAY = _class.staticFieldId(
    r'DISPLAY',
    r'Ljava/util/Locale$Category;',
  );

  /// from: `static public final java.util.Locale$Category DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$Category get DISPLAY =>
      _id_DISPLAY.get(_class, const $Locale$Category$Type$());

  static final _id_FORMAT = _class.staticFieldId(
    r'FORMAT',
    r'Ljava/util/Locale$Category;',
  );

  /// from: `static public final java.util.Locale$Category FORMAT`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$Category get FORMAT =>
      _id_FORMAT.get(_class, const $Locale$Category$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/util/Locale$Category;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale$Category[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Locale$Category?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Locale$Category?>?>(
      const jni$_.$JArray$NullableType$<Locale$Category?>(
        $Locale$Category$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/util/Locale$Category;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Locale$Category valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$Category? valueOf(jni$_.JString? synthetic) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$synthetic.pointer,
    ).object<Locale$Category?>(const $Locale$Category$NullableType$());
  }
}

final class $Locale$Category$NullableType$
    extends jni$_.JType<Locale$Category?> {
  @jni$_.internal
  const $Locale$Category$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$Category;';

  @jni$_.internal
  @core$_.override
  Locale$Category? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Locale$Category.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$Category?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$Category$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$Category$NullableType$) &&
        other is $Locale$Category$NullableType$;
  }
}

final class $Locale$Category$Type$ extends jni$_.JType<Locale$Category> {
  @jni$_.internal
  const $Locale$Category$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$Category;';

  @jni$_.internal
  @core$_.override
  Locale$Category fromReference(jni$_.JReference reference) =>
      Locale$Category.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$Category?> get nullableType =>
      const $Locale$Category$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$Category$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$Category$Type$) &&
        other is $Locale$Category$Type$;
  }
}

/// from: `java.util.Locale$FilteringMode`
class Locale$FilteringMode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Locale$FilteringMode> $type;

  @jni$_.internal
  Locale$FilteringMode.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/Locale$FilteringMode');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$FilteringMode?> nullableType =
      $Locale$FilteringMode$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$FilteringMode> type =
      $Locale$FilteringMode$Type$();
  static final _id_AUTOSELECT_FILTERING = _class.staticFieldId(
    r'AUTOSELECT_FILTERING',
    r'Ljava/util/Locale$FilteringMode;',
  );

  /// from: `static public final java.util.Locale$FilteringMode AUTOSELECT_FILTERING`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$FilteringMode get AUTOSELECT_FILTERING =>
      _id_AUTOSELECT_FILTERING.get(_class, const $Locale$FilteringMode$Type$());

  static final _id_EXTENDED_FILTERING = _class.staticFieldId(
    r'EXTENDED_FILTERING',
    r'Ljava/util/Locale$FilteringMode;',
  );

  /// from: `static public final java.util.Locale$FilteringMode EXTENDED_FILTERING`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$FilteringMode get EXTENDED_FILTERING =>
      _id_EXTENDED_FILTERING.get(_class, const $Locale$FilteringMode$Type$());

  static final _id_IGNORE_EXTENDED_RANGES = _class.staticFieldId(
    r'IGNORE_EXTENDED_RANGES',
    r'Ljava/util/Locale$FilteringMode;',
  );

  /// from: `static public final java.util.Locale$FilteringMode IGNORE_EXTENDED_RANGES`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$FilteringMode get IGNORE_EXTENDED_RANGES =>
      _id_IGNORE_EXTENDED_RANGES.get(
        _class,
        const $Locale$FilteringMode$Type$(),
      );

  static final _id_MAP_EXTENDED_RANGES = _class.staticFieldId(
    r'MAP_EXTENDED_RANGES',
    r'Ljava/util/Locale$FilteringMode;',
  );

  /// from: `static public final java.util.Locale$FilteringMode MAP_EXTENDED_RANGES`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$FilteringMode get MAP_EXTENDED_RANGES =>
      _id_MAP_EXTENDED_RANGES.get(_class, const $Locale$FilteringMode$Type$());

  static final _id_REJECT_EXTENDED_RANGES = _class.staticFieldId(
    r'REJECT_EXTENDED_RANGES',
    r'Ljava/util/Locale$FilteringMode;',
  );

  /// from: `static public final java.util.Locale$FilteringMode REJECT_EXTENDED_RANGES`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$FilteringMode get REJECT_EXTENDED_RANGES =>
      _id_REJECT_EXTENDED_RANGES.get(
        _class,
        const $Locale$FilteringMode$Type$(),
      );

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/util/Locale$FilteringMode;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale$FilteringMode[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Locale$FilteringMode?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Locale$FilteringMode?>?>(
      const jni$_.$JArray$NullableType$<Locale$FilteringMode?>(
        $Locale$FilteringMode$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/util/Locale$FilteringMode;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Locale$FilteringMode valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$FilteringMode? valueOf(jni$_.JString? synthetic) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$synthetic.pointer,
    ).object<Locale$FilteringMode?>(
      const $Locale$FilteringMode$NullableType$(),
    );
  }
}

final class $Locale$FilteringMode$NullableType$
    extends jni$_.JType<Locale$FilteringMode?> {
  @jni$_.internal
  const $Locale$FilteringMode$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$FilteringMode;';

  @jni$_.internal
  @core$_.override
  Locale$FilteringMode? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Locale$FilteringMode.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$FilteringMode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$FilteringMode$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$FilteringMode$NullableType$) &&
        other is $Locale$FilteringMode$NullableType$;
  }
}

final class $Locale$FilteringMode$Type$
    extends jni$_.JType<Locale$FilteringMode> {
  @jni$_.internal
  const $Locale$FilteringMode$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$FilteringMode;';

  @jni$_.internal
  @core$_.override
  Locale$FilteringMode fromReference(jni$_.JReference reference) =>
      Locale$FilteringMode.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$FilteringMode?> get nullableType =>
      const $Locale$FilteringMode$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$FilteringMode$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$FilteringMode$Type$) &&
        other is $Locale$FilteringMode$Type$;
  }
}

/// from: `java.util.Locale$IsoCountryCode`
class Locale$IsoCountryCode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Locale$IsoCountryCode> $type;

  @jni$_.internal
  Locale$IsoCountryCode.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/util/Locale$IsoCountryCode',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$IsoCountryCode?> nullableType =
      $Locale$IsoCountryCode$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$IsoCountryCode> type =
      $Locale$IsoCountryCode$Type$();
  static final _id_PART1_ALPHA2 = _class.staticFieldId(
    r'PART1_ALPHA2',
    r'Ljava/util/Locale$IsoCountryCode;',
  );

  /// from: `static public final java.util.Locale$IsoCountryCode PART1_ALPHA2`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$IsoCountryCode get PART1_ALPHA2 =>
      _id_PART1_ALPHA2.get(_class, const $Locale$IsoCountryCode$Type$());

  static final _id_PART1_ALPHA3 = _class.staticFieldId(
    r'PART1_ALPHA3',
    r'Ljava/util/Locale$IsoCountryCode;',
  );

  /// from: `static public final java.util.Locale$IsoCountryCode PART1_ALPHA3`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$IsoCountryCode get PART1_ALPHA3 =>
      _id_PART1_ALPHA3.get(_class, const $Locale$IsoCountryCode$Type$());

  static final _id_PART3 = _class.staticFieldId(
    r'PART3',
    r'Ljava/util/Locale$IsoCountryCode;',
  );

  /// from: `static public final java.util.Locale$IsoCountryCode PART3`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$IsoCountryCode get PART3 =>
      _id_PART3.get(_class, const $Locale$IsoCountryCode$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/util/Locale$IsoCountryCode;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale$IsoCountryCode[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Locale$IsoCountryCode?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Locale$IsoCountryCode?>?>(
      const jni$_.$JArray$NullableType$<Locale$IsoCountryCode?>(
        $Locale$IsoCountryCode$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/util/Locale$IsoCountryCode;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Locale$IsoCountryCode valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale$IsoCountryCode? valueOf(jni$_.JString? synthetic) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$synthetic.pointer,
    ).object<Locale$IsoCountryCode?>(
      const $Locale$IsoCountryCode$NullableType$(),
    );
  }
}

final class $Locale$IsoCountryCode$NullableType$
    extends jni$_.JType<Locale$IsoCountryCode?> {
  @jni$_.internal
  const $Locale$IsoCountryCode$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$IsoCountryCode;';

  @jni$_.internal
  @core$_.override
  Locale$IsoCountryCode? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Locale$IsoCountryCode.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$IsoCountryCode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$IsoCountryCode$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$IsoCountryCode$NullableType$) &&
        other is $Locale$IsoCountryCode$NullableType$;
  }
}

final class $Locale$IsoCountryCode$Type$
    extends jni$_.JType<Locale$IsoCountryCode> {
  @jni$_.internal
  const $Locale$IsoCountryCode$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$IsoCountryCode;';

  @jni$_.internal
  @core$_.override
  Locale$IsoCountryCode fromReference(jni$_.JReference reference) =>
      Locale$IsoCountryCode.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$IsoCountryCode?> get nullableType =>
      const $Locale$IsoCountryCode$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$IsoCountryCode$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$IsoCountryCode$Type$) &&
        other is $Locale$IsoCountryCode$Type$;
  }
}

/// from: `java.util.Locale$LanguageRange`
class Locale$LanguageRange extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Locale$LanguageRange> $type;

  @jni$_.internal
  Locale$LanguageRange.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/Locale$LanguageRange');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$LanguageRange?> nullableType =
      $Locale$LanguageRange$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale$LanguageRange> type =
      $Locale$LanguageRange$Type$();

  /// from: `static public final double MAX_WEIGHT`
  static const MAX_WEIGHT = 1.0;

  /// from: `static public final double MIN_WEIGHT`
  static const MIN_WEIGHT = 0.0;
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Locale$LanguageRange(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Locale$LanguageRange.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;D)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public void <init>(java.lang.String string, double d)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Locale$LanguageRange.new$1(jni$_.JString? string, double d) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Locale$LanguageRange.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        d,
      ).reference,
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_getRange = _class.instanceMethodId(
    r'getRange',
    r'()Ljava/lang/String;',
  );

  static final _getRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRange()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRange() {
    return _getRange(
      reference.pointer,
      _id_getRange as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getWeight = _class.instanceMethodId(r'getWeight', r'()D');

  static final _getWeight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double getWeight()`
  double getWeight() {
    return _getWeight(
      reference.pointer,
      _id_getWeight as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_mapEquivalents = _class.staticMethodId(
    r'mapEquivalents',
    r'(Ljava/util/List;Ljava/util/Map;)Ljava/util/List;',
  );

  static final _mapEquivalents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.List<java.util.Locale$LanguageRange> mapEquivalents(java.util.List<java.util.Locale$LanguageRange> list, java.util.Map<java.lang.String, java.util.List<java.lang.String>> map)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<Locale$LanguageRange?>? mapEquivalents(
    jni$_.JList<Locale$LanguageRange?>? list,
    jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? map,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _mapEquivalents(
      _class.reference.pointer,
      _id_mapEquivalents as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$map.pointer,
    ).object<jni$_.JList<Locale$LanguageRange?>?>(
      const jni$_.$JList$NullableType$<Locale$LanguageRange?>(
        $Locale$LanguageRange$NullableType$(),
      ),
    );
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/String;)Ljava/util/List;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.List<java.util.Locale$LanguageRange> parse(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<Locale$LanguageRange?>? parse(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JList<Locale$LanguageRange?>?>(
      const jni$_.$JList$NullableType$<Locale$LanguageRange?>(
        $Locale$LanguageRange$NullableType$(),
      ),
    );
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/util/Map;)Ljava/util/List;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.List<java.util.Locale$LanguageRange> parse(java.lang.String string, java.util.Map<java.lang.String, java.util.List<java.lang.String>> map)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<Locale$LanguageRange?>? parse$1(
    jni$_.JString? string,
    jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? map,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$map.pointer,
    ).object<jni$_.JList<Locale$LanguageRange?>?>(
      const jni$_.$JList$NullableType$<Locale$LanguageRange?>(
        $Locale$LanguageRange$NullableType$(),
      ),
    );
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $Locale$LanguageRange$NullableType$
    extends jni$_.JType<Locale$LanguageRange?> {
  @jni$_.internal
  const $Locale$LanguageRange$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$LanguageRange;';

  @jni$_.internal
  @core$_.override
  Locale$LanguageRange? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Locale$LanguageRange.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$LanguageRange?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$LanguageRange$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$LanguageRange$NullableType$) &&
        other is $Locale$LanguageRange$NullableType$;
  }
}

final class $Locale$LanguageRange$Type$
    extends jni$_.JType<Locale$LanguageRange> {
  @jni$_.internal
  const $Locale$LanguageRange$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale$LanguageRange;';

  @jni$_.internal
  @core$_.override
  Locale$LanguageRange fromReference(jni$_.JReference reference) =>
      Locale$LanguageRange.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale$LanguageRange?> get nullableType =>
      const $Locale$LanguageRange$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$LanguageRange$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$LanguageRange$Type$) &&
        other is $Locale$LanguageRange$Type$;
  }
}

/// from: `java.util.Locale`
class Locale extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Locale> $type;

  @jni$_.internal
  Locale.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/Locale');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale?> nullableType = $Locale$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Locale> type = $Locale$Type$();
  static final _id_CANADA = _class.staticFieldId(
    r'CANADA',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale CANADA`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get CANADA =>
      _id_CANADA.get(_class, const $Locale$NullableType$());

  static final _id_CANADA_FRENCH = _class.staticFieldId(
    r'CANADA_FRENCH',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale CANADA_FRENCH`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get CANADA_FRENCH =>
      _id_CANADA_FRENCH.get(_class, const $Locale$NullableType$());

  static final _id_CHINA = _class.staticFieldId(
    r'CHINA',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale CHINA`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get CHINA =>
      _id_CHINA.get(_class, const $Locale$NullableType$());

  static final _id_CHINESE = _class.staticFieldId(
    r'CHINESE',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale CHINESE`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get CHINESE =>
      _id_CHINESE.get(_class, const $Locale$NullableType$());

  static final _id_ENGLISH = _class.staticFieldId(
    r'ENGLISH',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale ENGLISH`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get ENGLISH =>
      _id_ENGLISH.get(_class, const $Locale$NullableType$());

  static final _id_FRANCE = _class.staticFieldId(
    r'FRANCE',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale FRANCE`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get FRANCE =>
      _id_FRANCE.get(_class, const $Locale$NullableType$());

  static final _id_FRENCH = _class.staticFieldId(
    r'FRENCH',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale FRENCH`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get FRENCH =>
      _id_FRENCH.get(_class, const $Locale$NullableType$());

  static final _id_GERMAN = _class.staticFieldId(
    r'GERMAN',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale GERMAN`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get GERMAN =>
      _id_GERMAN.get(_class, const $Locale$NullableType$());

  static final _id_GERMANY = _class.staticFieldId(
    r'GERMANY',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale GERMANY`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get GERMANY =>
      _id_GERMANY.get(_class, const $Locale$NullableType$());

  static final _id_ITALIAN = _class.staticFieldId(
    r'ITALIAN',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale ITALIAN`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get ITALIAN =>
      _id_ITALIAN.get(_class, const $Locale$NullableType$());

  static final _id_ITALY = _class.staticFieldId(
    r'ITALY',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale ITALY`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get ITALY =>
      _id_ITALY.get(_class, const $Locale$NullableType$());

  static final _id_JAPAN = _class.staticFieldId(
    r'JAPAN',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale JAPAN`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get JAPAN =>
      _id_JAPAN.get(_class, const $Locale$NullableType$());

  static final _id_JAPANESE = _class.staticFieldId(
    r'JAPANESE',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale JAPANESE`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get JAPANESE =>
      _id_JAPANESE.get(_class, const $Locale$NullableType$());

  static final _id_KOREA = _class.staticFieldId(
    r'KOREA',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale KOREA`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get KOREA =>
      _id_KOREA.get(_class, const $Locale$NullableType$());

  static final _id_KOREAN = _class.staticFieldId(
    r'KOREAN',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale KOREAN`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get KOREAN =>
      _id_KOREAN.get(_class, const $Locale$NullableType$());

  static final _id_PRC = _class.staticFieldId(r'PRC', r'Ljava/util/Locale;');

  /// from: `static public final java.util.Locale PRC`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get PRC => _id_PRC.get(_class, const $Locale$NullableType$());

  /// from: `static public final char PRIVATE_USE_EXTENSION`
  static const PRIVATE_USE_EXTENSION = 120;
  static final _id_ROOT = _class.staticFieldId(r'ROOT', r'Ljava/util/Locale;');

  /// from: `static public final java.util.Locale ROOT`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get ROOT =>
      _id_ROOT.get(_class, const $Locale$NullableType$());

  static final _id_SIMPLIFIED_CHINESE = _class.staticFieldId(
    r'SIMPLIFIED_CHINESE',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale SIMPLIFIED_CHINESE`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get SIMPLIFIED_CHINESE =>
      _id_SIMPLIFIED_CHINESE.get(_class, const $Locale$NullableType$());

  static final _id_TAIWAN = _class.staticFieldId(
    r'TAIWAN',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale TAIWAN`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get TAIWAN =>
      _id_TAIWAN.get(_class, const $Locale$NullableType$());

  static final _id_TRADITIONAL_CHINESE = _class.staticFieldId(
    r'TRADITIONAL_CHINESE',
    r'Ljava/util/Locale;',
  );

  /// from: `static public final java.util.Locale TRADITIONAL_CHINESE`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get TRADITIONAL_CHINESE =>
      _id_TRADITIONAL_CHINESE.get(_class, const $Locale$NullableType$());

  static final _id_UK = _class.staticFieldId(r'UK', r'Ljava/util/Locale;');

  /// from: `static public final java.util.Locale UK`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get UK => _id_UK.get(_class, const $Locale$NullableType$());

  /// from: `static public final char UNICODE_LOCALE_EXTENSION`
  static const UNICODE_LOCALE_EXTENSION = 117;
  static final _id_US = _class.staticFieldId(r'US', r'Ljava/util/Locale;');

  /// from: `static public final java.util.Locale US`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? get US => _id_US.get(_class, const $Locale$NullableType$());

  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Locale(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Locale.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Locale.new$1(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return Locale.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Locale.new$2(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return Locale.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        _$string2.pointer,
      ).reference,
    );
  }

  static final _id_availableLocales = _class.staticMethodId(
    r'availableLocales',
    r'()Ljava/util/stream/Stream;',
  );

  static final _availableLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.stream.Stream<java.util.Locale> availableLocales()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? availableLocales() {
    return _availableLocales(
      _class.reference.pointer,
      _id_availableLocales as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() {
    return _clone(
      reference.pointer,
      _id_clone as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_filter = _class.staticMethodId(
    r'filter',
    r'(Ljava/util/List;Ljava/util/Collection;)Ljava/util/List;',
  );

  static final _filter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.List<java.util.Locale> filter(java.util.List<java.util.Locale$LanguageRange> list, java.util.Collection<java.util.Locale> collection)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<Locale?>? filter(
    jni$_.JList<Locale$LanguageRange?>? list,
    collection$_.Collection<Locale?>? collection,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    return _filter(
      _class.reference.pointer,
      _id_filter as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$collection.pointer,
    ).object<jni$_.JList<Locale?>?>(
      const jni$_.$JList$NullableType$<Locale?>($Locale$NullableType$()),
    );
  }

  static final _id_filter$1 = _class.staticMethodId(
    r'filter',
    r'(Ljava/util/List;Ljava/util/Collection;Ljava/util/Locale$FilteringMode;)Ljava/util/List;',
  );

  static final _filter$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.List<java.util.Locale> filter(java.util.List<java.util.Locale$LanguageRange> list, java.util.Collection<java.util.Locale> collection, java.util.Locale$FilteringMode filteringMode)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<Locale?>? filter$1(
    jni$_.JList<Locale$LanguageRange?>? list,
    collection$_.Collection<Locale?>? collection,
    Locale$FilteringMode? filteringMode,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    final _$filteringMode = filteringMode?.reference ?? jni$_.jNullReference;
    return _filter$1(
      _class.reference.pointer,
      _id_filter$1 as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$collection.pointer,
      _$filteringMode.pointer,
    ).object<jni$_.JList<Locale?>?>(
      const jni$_.$JList$NullableType$<Locale?>($Locale$NullableType$()),
    );
  }

  static final _id_filterTags = _class.staticMethodId(
    r'filterTags',
    r'(Ljava/util/List;Ljava/util/Collection;)Ljava/util/List;',
  );

  static final _filterTags =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.List<java.lang.String> filterTags(java.util.List<java.util.Locale$LanguageRange> list, java.util.Collection<java.lang.String> collection)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<jni$_.JString?>? filterTags(
    jni$_.JList<Locale$LanguageRange?>? list,
    collection$_.Collection<jni$_.JString?>? collection,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    return _filterTags(
      _class.reference.pointer,
      _id_filterTags as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$collection.pointer,
    ).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_filterTags$1 = _class.staticMethodId(
    r'filterTags',
    r'(Ljava/util/List;Ljava/util/Collection;Ljava/util/Locale$FilteringMode;)Ljava/util/List;',
  );

  static final _filterTags$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.List<java.lang.String> filterTags(java.util.List<java.util.Locale$LanguageRange> list, java.util.Collection<java.lang.String> collection, java.util.Locale$FilteringMode filteringMode)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<jni$_.JString?>? filterTags$1(
    jni$_.JList<Locale$LanguageRange?>? list,
    collection$_.Collection<jni$_.JString?>? collection,
    Locale$FilteringMode? filteringMode,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    final _$filteringMode = filteringMode?.reference ?? jni$_.jNullReference;
    return _filterTags$1(
      _class.reference.pointer,
      _id_filterTags$1 as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$collection.pointer,
      _$filteringMode.pointer,
    ).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_forLanguageTag = _class.staticMethodId(
    r'forLanguageTag',
    r'(Ljava/lang/String;)Ljava/util/Locale;',
  );

  static final _forLanguageTag =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Locale forLanguageTag(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? forLanguageTag(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _forLanguageTag(
      _class.reference.pointer,
      _id_forLanguageTag as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Locale?>(const $Locale$NullableType$());
  }

  static final _id_getAvailableLocales = _class.staticMethodId(
    r'getAvailableLocales',
    r'()[Ljava/util/Locale;',
  );

  static final _getAvailableLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale[] getAvailableLocales()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Locale?>? getAvailableLocales() {
    return _getAvailableLocales(
      _class.reference.pointer,
      _id_getAvailableLocales as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Locale?>?>(
      const jni$_.$JArray$NullableType$<Locale?>($Locale$NullableType$()),
    );
  }

  static final _id_getCountry = _class.instanceMethodId(
    r'getCountry',
    r'()Ljava/lang/String;',
  );

  static final _getCountry =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getCountry()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCountry() {
    return _getCountry(
      reference.pointer,
      _id_getCountry as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDefault = _class.staticMethodId(
    r'getDefault',
    r'()Ljava/util/Locale;',
  );

  static final _getDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale getDefault()`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? getDefault() {
    return _getDefault(
      _class.reference.pointer,
      _id_getDefault as jni$_.JMethodIDPtr,
    ).object<Locale?>(const $Locale$NullableType$());
  }

  static final _id_getDefault$1 = _class.staticMethodId(
    r'getDefault',
    r'(Ljava/util/Locale$Category;)Ljava/util/Locale;',
  );

  static final _getDefault$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Locale getDefault(java.util.Locale$Category category)`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? getDefault$1(Locale$Category? category) {
    final _$category = category?.reference ?? jni$_.jNullReference;
    return _getDefault$1(
      _class.reference.pointer,
      _id_getDefault$1 as jni$_.JMethodIDPtr,
      _$category.pointer,
    ).object<Locale?>(const $Locale$NullableType$());
  }

  static final _id_getDisplayCountry = _class.instanceMethodId(
    r'getDisplayCountry',
    r'()Ljava/lang/String;',
  );

  static final _getDisplayCountry =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDisplayCountry()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayCountry() {
    return _getDisplayCountry(
      reference.pointer,
      _id_getDisplayCountry as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDisplayCountry$1 = _class.instanceMethodId(
    r'getDisplayCountry',
    r'(Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayCountry$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayCountry(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayCountry$1(Locale? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayCountry$1(
      reference.pointer,
      _id_getDisplayCountry$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDisplayLanguage = _class.instanceMethodId(
    r'getDisplayLanguage',
    r'()Ljava/lang/String;',
  );

  static final _getDisplayLanguage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDisplayLanguage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayLanguage() {
    return _getDisplayLanguage(
      reference.pointer,
      _id_getDisplayLanguage as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDisplayLanguage$1 = _class.instanceMethodId(
    r'getDisplayLanguage',
    r'(Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayLanguage$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayLanguage(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayLanguage$1(Locale? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayLanguage$1(
      reference.pointer,
      _id_getDisplayLanguage$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'()Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDisplayName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName() {
    return _getDisplayName(
      reference.pointer,
      _id_getDisplayName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDisplayName$1 = _class.instanceMethodId(
    r'getDisplayName',
    r'(Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayName$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayName(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName$1(Locale? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayName$1(
      reference.pointer,
      _id_getDisplayName$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDisplayScript = _class.instanceMethodId(
    r'getDisplayScript',
    r'()Ljava/lang/String;',
  );

  static final _getDisplayScript =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDisplayScript()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayScript() {
    return _getDisplayScript(
      reference.pointer,
      _id_getDisplayScript as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDisplayScript$1 = _class.instanceMethodId(
    r'getDisplayScript',
    r'(Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayScript$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayScript(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayScript$1(Locale? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayScript$1(
      reference.pointer,
      _id_getDisplayScript$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDisplayVariant = _class.instanceMethodId(
    r'getDisplayVariant',
    r'()Ljava/lang/String;',
  );

  static final _getDisplayVariant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDisplayVariant()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayVariant() {
    return _getDisplayVariant(
      reference.pointer,
      _id_getDisplayVariant as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getDisplayVariant$1 = _class.instanceMethodId(
    r'getDisplayVariant',
    r'(Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayVariant$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayVariant(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayVariant$1(Locale? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayVariant$1(
      reference.pointer,
      _id_getDisplayVariant$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getExtension = _class.instanceMethodId(
    r'getExtension',
    r'(C)Ljava/lang/String;',
  );

  static final _getExtension =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String getExtension(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getExtension(int c) {
    return _getExtension(
      reference.pointer,
      _id_getExtension as jni$_.JMethodIDPtr,
      c,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getExtensionKeys = _class.instanceMethodId(
    r'getExtensionKeys',
    r'()Ljava/util/Set;',
  );

  static final _getExtensionKeys =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.lang.Character> getExtensionKeys()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JCharacter?>? getExtensionKeys() {
    return _getExtensionKeys(
      reference.pointer,
      _id_getExtensionKeys as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JCharacter?>?>(
      const jni$_.$JSet$NullableType$<jni$_.JCharacter?>(
        jni$_.$JCharacter$NullableType$(),
      ),
    );
  }

  static final _id_getISO3Country = _class.instanceMethodId(
    r'getISO3Country',
    r'()Ljava/lang/String;',
  );

  static final _getISO3Country =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getISO3Country()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getISO3Country() {
    return _getISO3Country(
      reference.pointer,
      _id_getISO3Country as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getISO3Language = _class.instanceMethodId(
    r'getISO3Language',
    r'()Ljava/lang/String;',
  );

  static final _getISO3Language =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getISO3Language()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getISO3Language() {
    return _getISO3Language(
      reference.pointer,
      _id_getISO3Language as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getISOCountries = _class.staticMethodId(
    r'getISOCountries',
    r'()[Ljava/lang/String;',
  );

  static final _getISOCountries =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.lang.String[] getISOCountries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? getISOCountries() {
    return _getISOCountries(
      _class.reference.pointer,
      _id_getISOCountries as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JString?>?>(
      const jni$_.$JArray$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getISOCountries$1 = _class.staticMethodId(
    r'getISOCountries',
    r'(Ljava/util/Locale$IsoCountryCode;)Ljava/util/Set;',
  );

  static final _getISOCountries$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Set<java.lang.String> getISOCountries(java.util.Locale$IsoCountryCode isoCountryCode)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JSet<jni$_.JString?>? getISOCountries$1(
    Locale$IsoCountryCode? isoCountryCode,
  ) {
    final _$isoCountryCode = isoCountryCode?.reference ?? jni$_.jNullReference;
    return _getISOCountries$1(
      _class.reference.pointer,
      _id_getISOCountries$1 as jni$_.JMethodIDPtr,
      _$isoCountryCode.pointer,
    ).object<jni$_.JSet<jni$_.JString?>?>(
      const jni$_.$JSet$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getISOLanguages = _class.staticMethodId(
    r'getISOLanguages',
    r'()[Ljava/lang/String;',
  );

  static final _getISOLanguages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.lang.String[] getISOLanguages()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? getISOLanguages() {
    return _getISOLanguages(
      _class.reference.pointer,
      _id_getISOLanguages as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JString?>?>(
      const jni$_.$JArray$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getLanguage = _class.instanceMethodId(
    r'getLanguage',
    r'()Ljava/lang/String;',
  );

  static final _getLanguage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getLanguage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getLanguage() {
    return _getLanguage(
      reference.pointer,
      _id_getLanguage as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getScript = _class.instanceMethodId(
    r'getScript',
    r'()Ljava/lang/String;',
  );

  static final _getScript =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getScript()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getScript() {
    return _getScript(
      reference.pointer,
      _id_getScript as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getUnicodeLocaleAttributes = _class.instanceMethodId(
    r'getUnicodeLocaleAttributes',
    r'()Ljava/util/Set;',
  );

  static final _getUnicodeLocaleAttributes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.lang.String> getUnicodeLocaleAttributes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JString?>? getUnicodeLocaleAttributes() {
    return _getUnicodeLocaleAttributes(
      reference.pointer,
      _id_getUnicodeLocaleAttributes as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JString?>?>(
      const jni$_.$JSet$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getUnicodeLocaleKeys = _class.instanceMethodId(
    r'getUnicodeLocaleKeys',
    r'()Ljava/util/Set;',
  );

  static final _getUnicodeLocaleKeys =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.lang.String> getUnicodeLocaleKeys()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JString?>? getUnicodeLocaleKeys() {
    return _getUnicodeLocaleKeys(
      reference.pointer,
      _id_getUnicodeLocaleKeys as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JString?>?>(
      const jni$_.$JSet$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getUnicodeLocaleType = _class.instanceMethodId(
    r'getUnicodeLocaleType',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getUnicodeLocaleType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getUnicodeLocaleType(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUnicodeLocaleType(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getUnicodeLocaleType(
      reference.pointer,
      _id_getUnicodeLocaleType as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getVariant = _class.instanceMethodId(
    r'getVariant',
    r'()Ljava/lang/String;',
  );

  static final _getVariant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getVariant()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getVariant() {
    return _getVariant(
      reference.pointer,
      _id_getVariant as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_hasExtensions = _class.instanceMethodId(
    r'hasExtensions',
    r'()Z',
  );

  static final _hasExtensions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasExtensions()`
  bool hasExtensions() {
    return _hasExtensions(
      reference.pointer,
      _id_hasExtensions as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_lookup = _class.staticMethodId(
    r'lookup',
    r'(Ljava/util/List;Ljava/util/Collection;)Ljava/util/Locale;',
  );

  static final _lookup =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Locale lookup(java.util.List<java.util.Locale$LanguageRange> list, java.util.Collection<java.util.Locale> collection)`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? lookup(
    jni$_.JList<Locale$LanguageRange?>? list,
    collection$_.Collection<Locale?>? collection,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    return _lookup(
      _class.reference.pointer,
      _id_lookup as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$collection.pointer,
    ).object<Locale?>(const $Locale$NullableType$());
  }

  static final _id_lookupTag = _class.staticMethodId(
    r'lookupTag',
    r'(Ljava/util/List;Ljava/util/Collection;)Ljava/lang/String;',
  );

  static final _lookupTag =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String lookupTag(java.util.List<java.util.Locale$LanguageRange> list, java.util.Collection<java.lang.String> collection)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? lookupTag(
    jni$_.JList<Locale$LanguageRange?>? list,
    collection$_.Collection<jni$_.JString?>? collection,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    return _lookupTag(
      _class.reference.pointer,
      _id_lookupTag as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$collection.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;)Ljava/util/Locale;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Locale of(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? of(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Locale?>(const $Locale$NullableType$());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/util/Locale;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Locale of(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? of$1(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).object<Locale?>(const $Locale$NullableType$());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/util/Locale;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.Locale of(java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Locale? of$2(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
      _$string2.pointer,
    ).object<Locale?>(const $Locale$NullableType$());
  }

  static final _id_setDefault = _class.staticMethodId(
    r'setDefault',
    r'(Ljava/util/Locale;)V',
  );

  static final _setDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDefault(java.util.Locale locale)`
  static void setDefault(Locale? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    _setDefault(
      _class.reference.pointer,
      _id_setDefault as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).check();
  }

  static final _id_setDefault$1 = _class.staticMethodId(
    r'setDefault',
    r'(Ljava/util/Locale$Category;Ljava/util/Locale;)V',
  );

  static final _setDefault$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDefault(java.util.Locale$Category category, java.util.Locale locale)`
  static void setDefault$1(Locale$Category? category, Locale? locale) {
    final _$category = category?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    _setDefault$1(
      _class.reference.pointer,
      _id_setDefault$1 as jni$_.JMethodIDPtr,
      _$category.pointer,
      _$locale.pointer,
    ).check();
  }

  static final _id_stripExtensions = _class.instanceMethodId(
    r'stripExtensions',
    r'()Ljava/util/Locale;',
  );

  static final _stripExtensions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Locale stripExtensions()`
  /// The returned object must be released after use, by calling the [release] method.
  Locale? stripExtensions() {
    return _stripExtensions(
      reference.pointer,
      _id_stripExtensions as jni$_.JMethodIDPtr,
    ).object<Locale?>(const $Locale$NullableType$());
  }

  static final _id_toLanguageTag = _class.instanceMethodId(
    r'toLanguageTag',
    r'()Ljava/lang/String;',
  );

  static final _toLanguageTag =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toLanguageTag()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toLanguageTag() {
    return _toLanguageTag(
      reference.pointer,
      _id_toLanguageTag as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $Locale$NullableType$ extends jni$_.JType<Locale?> {
  @jni$_.internal
  const $Locale$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale;';

  @jni$_.internal
  @core$_.override
  Locale? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Locale.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$NullableType$) &&
        other is $Locale$NullableType$;
  }
}

final class $Locale$Type$ extends jni$_.JType<Locale> {
  @jni$_.internal
  const $Locale$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/Locale;';

  @jni$_.internal
  @core$_.override
  Locale fromReference(jni$_.JReference reference) =>
      Locale.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Locale?> get nullableType => const $Locale$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Locale$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Locale$Type$) && other is $Locale$Type$;
  }
}
